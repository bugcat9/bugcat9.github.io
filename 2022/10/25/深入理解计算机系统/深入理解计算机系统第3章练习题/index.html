<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
<meta name="google-site-verification" content="h6mqk4DHw-91R-MekBrLgCwD8GSHlkGduz8ltdkIfFI" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">



<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bugcat.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="深入理解计算机系统第3章练习题练习题3.1假设下面的值存放在指明的内存地址和寄存器中:     操作数 值     %rax 0x100   0x104 0xAB   $0x108 0x108   (%rax) 0xFF   4(%rax) 0xAB   9(%rax,%rdx) 0x11   260(%rcx,%rdx) 0x13   0xFC(,%rcx,4) 0xFF   (%rax,%rd">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解计算机系统第3章练习题">
<meta property="og:url" content="https://bugcat.top/2022/10/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/index.html">
<meta property="og:site_name" content="bugCat&#39;s Blog">
<meta property="og:description" content="深入理解计算机系统第3章练习题练习题3.1假设下面的值存放在指明的内存地址和寄存器中:     操作数 值     %rax 0x100   0x104 0xAB   $0x108 0x108   (%rax) 0xFF   4(%rax) 0xAB   9(%rax,%rdx) 0x11   260(%rcx,%rdx) 0x13   0xFC(,%rcx,4) 0xFF   (%rax,%rd">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221025203611818.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221025222250940.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221026110728710.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221027211920652.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221027211934019.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221030184524281.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221030192217880.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221108153523592.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221110194157270.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/3-43b">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221110194231170.png">
<meta property="article:published_time" content="2022-10-25T20:29:45.000Z">
<meta property="article:modified_time" content="2024-10-20T13:34:26.728Z">
<meta property="article:author" content="bugCat">
<meta property="article:tag" content="深入理解计算机系统第2章">
<meta property="article:tag" content="CSAPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221025203611818.png">

<link rel="canonical" href="https://bugcat.top/2022/10/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>深入理解计算机系统第3章练习题 | bugCat's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="bugCat's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bugCat's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">毛的感情的程序猿</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/bugcat9" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bugcat.top/2022/10/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/avatar/zhouning.png">
      <meta itemprop="name" content="bugCat">
      <meta itemprop="description" content="啥都不会">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bugCat's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解计算机系统第3章练习题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-25 20:29:45" itemprop="dateCreated datePublished" datetime="2022-10-25T20:29:45+00:00">2022-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-20 13:34:26" itemprop="dateModified" datetime="2024-10-20T13:34:26+00:00">2024-10-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">深入理解计算机系统</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="深入理解计算机系统第3章练习题"><a href="#深入理解计算机系统第3章练习题" class="headerlink" title="深入理解计算机系统第3章练习题"></a>深入理解计算机系统第3章练习题</h1><h2 id="练习题3-1假设下面的值存放在指明的内存地址和寄存器中"><a href="#练习题3-1假设下面的值存放在指明的内存地址和寄存器中" class="headerlink" title="练习题3.1假设下面的值存放在指明的内存地址和寄存器中:"></a>练习题3.1假设下面的值存放在指明的内存地址和寄存器中:</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221025203611818.png" alt="image-20221025203611818"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作数</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%rax</td>
<td style="text-align:center">0x100</td>
</tr>
<tr>
<td style="text-align:center">0x104</td>
<td style="text-align:center">0xAB</td>
</tr>
<tr>
<td style="text-align:center">$0x108</td>
<td style="text-align:center">0x108</td>
</tr>
<tr>
<td style="text-align:center">(%rax)</td>
<td style="text-align:center">0xFF</td>
</tr>
<tr>
<td style="text-align:center">4(%rax)</td>
<td style="text-align:center">0xAB</td>
</tr>
<tr>
<td style="text-align:center">9(%rax,%rdx)</td>
<td style="text-align:center">0x11</td>
</tr>
<tr>
<td style="text-align:center">260(%rcx,%rdx)</td>
<td style="text-align:center">0x13</td>
</tr>
<tr>
<td style="text-align:center">0xFC(,%rcx,4)</td>
<td style="text-align:center">0xFF</td>
</tr>
<tr>
<td style="text-align:center">(%rax,%rdx,4)</td>
<td style="text-align:center">0x11</td>
</tr>
</tbody>
</table>
</div>
<span id="more"></span>
<h2 id="练习题3-2对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。-例如，mov-可以被重写成movb、movw、movl或者movq。）"><a href="#练习题3-2对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。-例如，mov-可以被重写成movb、movw、movl或者movq。）" class="headerlink" title="练习题3.2对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。(例如，mov 可以被重写成movb、movw、movl或者movq。）"></a>练习题3.2对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。(例如，mov 可以被重写成movb、movw、movl或者movq。）</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221025222250940.png" alt="image-20221025222250940"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movl %eax, (%rsp)		;%eax是2个字的，传输2字，所以是movl</span><br><span class="line">movw (%rax), %dx		;%dx是1个字的，传输1字，所以是movw</span><br><span class="line">movb $0xFF, %b1			;%b1是1个字节的，传输1字，所以是movb</span><br><span class="line">movb (%rsp,%rdx,4), %dl ;%dl是1个字的，传输1字，所以是movb</span><br><span class="line">movq (%rdx), %rax		;%rax是4个字的，传输1字，所以是movq</span><br><span class="line">movbw %dx, (%rax)		;%dx是1个字的，传输1字，所以是movw</span><br></pre></td></tr></table></figure>
<h2 id="练习题3-3当我们调用汇编器的时候，下面代码的每一行都会产生一个错误消息。解释每一行都是哪里出了错。"><a href="#练习题3-3当我们调用汇编器的时候，下面代码的每一行都会产生一个错误消息。解释每一行都是哪里出了错。" class="headerlink" title="练习题3.3当我们调用汇编器的时候，下面代码的每一行都会产生一个错误消息。解释每一行都是哪里出了错。"></a>练习题3.3当我们调用汇编器的时候，下面代码的每一行都会产生一个错误消息。解释每一行都是哪里出了错。</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221026110728710.png" alt="image-20221026110728710"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movb $0xF, (%ebx) 		;内存引用的寄存器必须是四个字的，改成movb $0xF, (%rbx)</span><br><span class="line">movl %rax, (%rsp) 		;%rax是四个字而l代表两个字，改成movl %eax, (%rsp) 或者 movq %rax, (%rsp)</span><br><span class="line">movw (%rax), 4(%rsp)	;两个操作数不能都是内存引用</span><br><span class="line">movb %al, %sl			;没有寄存器名字叫%sl</span><br><span class="line">movq %rax,$0x123		;立即数不能作为des操作数</span><br><span class="line">movl %eax, %rdx			;答案上说目标操作数大小不正确（destination operand incorrect size），这个有点不太理解</span><br><span class="line">movb %si, 8(%rbp)		;%si是一个字而b代表一个字节，改成movb %sil, 8(%rbp) 或者 movw %si, 8(%rbp)</span><br></pre></td></tr></table></figure>
<h2 id="练习题3-4假设变量sp和dp被声明为类型"><a href="#练习题3-4假设变量sp和dp被声明为类型" class="headerlink" title="练习题3.4假设变量sp和dp被声明为类型"></a>练习题3.4假设变量sp和dp被声明为类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">src_t</span> *sp;</span><br><span class="line"><span class="type">dest_t</span> *dp;</span><br></pre></td></tr></table></figure>
<p>这里src_t和dest_t是用typedef声明的数据类型。我们想使用适当的数据传送指令来实现下面的操作;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*dp = (<span class="type">dest_t</span>) *sp;</span><br></pre></td></tr></table></figure>
<p>假设 sp 和 dp 的值分别存储在寄存器 %rdi 和 %rsi 中。对于表中的每个表项，给出实现指定数据传送的两条指令。其中第一条指令应该从内存中读数，做适当的转换，并设置寄存器 %rax 的适当部分。然后，第二条指令要把 %rax 的适当部分写到内存。在这两种情况中，寄存器的部分可以是 %rax、%eax、%ax 或 %al，两者可以互不相同。</p>
<p>记住，当执行强制类型转换既涉及大小变化又涉及 C 语言中符号变化时，操作应该先改变大小。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">src_t</th>
<th style="text-align:center">dest_t</th>
<th style="text-align:left">指令</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">long</td>
<td style="text-align:left">movq (%rdi), %rax <br/>movq %rax, (%rsi)</td>
<td style="text-align:center">long 为 8 字节，目标字节数也为 8，所以都用 movq 。</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">int</td>
<td style="text-align:left">movsbl (%rdi), %eax<br/> movl %eax, (%rsi)</td>
<td style="text-align:center">因为源有符号，所以用 movs 。又因为是 char 到 int ，所以使用 bl 。</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">unsigned</td>
<td style="text-align:left">movsbl (%rdi), %eax<br/> movl %eax, (%rsi)</td>
<td style="text-align:center">同上。</td>
</tr>
<tr>
<td style="text-align:center">unsigned char</td>
<td style="text-align:center">long</td>
<td style="text-align:left">movzbl (%rdi), %eax<br/> movq %rax, (%rsi)</td>
<td style="text-align:center">需要把字节扩展成四字，由于是 unsigned，所以用零扩展。</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">char</td>
<td style="text-align:left">movl (%rdi), %edx<br/> movb %al, (%rsi)</td>
<td style="text-align:center">原始字节还是要读出来的，但是只传送低位字节，即按目标大小进行截断。源有无符号无所谓。</td>
</tr>
<tr>
<td style="text-align:center">unsigned</td>
<td style="text-align:center">unsigned char</td>
<td style="text-align:left">movl (%rdi), %al<br/> movb %al, (%rsi)</td>
<td style="text-align:center">本质同上。</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">short</td>
<td style="text-align:left">movsbw (%rdi), %ax<br/> movw %ax, (%rsi)</td>
<td style="text-align:center">需要进行符号拓展。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题3-5已知信息如下。将一个原型为"><a href="#练习题3-5已知信息如下。将一个原型为" class="headerlink" title="练习题3.5已知信息如下。将一个原型为"></a>练习题3.5已知信息如下。将一个原型为</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">decode1</span><span class="params">(<span class="type">long</span> *p, <span class="type">long</span> *yp, <span class="type">long</span> *zp)</span>;</span><br></pre></td></tr></table></figure>
<p>的函数编译成汇编代码，得到如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  void decode1(1ong *xp, long *yp, long *zp);</span><br><span class="line">  xp in %rdi, yp in %rsi, zp in %rdx</span><br><span class="line">decode1:</span><br><span class="line">  movq  (%rdi), %r8</span><br><span class="line">  movq  (%rsi), %rcx</span><br><span class="line">  movq  (%rdx), %rax</span><br><span class="line">  movq  %r8, (%rsi)</span><br><span class="line">  movq  (%rcx), (%rdx)</span><br><span class="line">  movq  (%rax), (%rdi)</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>参数 xp、yp 和 zp 分别存储在对应的寄存器 %rdi、%rsi 和 %rdx 中。</p>
<p>请写出等效于上面汇编代码的 decode1 的 C 代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">decode1</span><span class="params">(<span class="type">long</span> *p, <span class="type">long</span> *yp, <span class="type">long</span> *zp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> x = *xp;</span><br><span class="line">	<span class="type">long</span> y = *yp;</span><br><span class="line">	<span class="type">long</span> z = *zp;</span><br><span class="line">	</span><br><span class="line">    *yp = x;</span><br><span class="line">    *zp = y;</span><br><span class="line">    *xp = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题3-6-假设寄存器-rax-的值为-x，-rcx-的值为-y。填写下表，指明下面每条汇编代码指令存储在寄存器-rdx-中的值："><a href="#练习题3-6-假设寄存器-rax-的值为-x，-rcx-的值为-y。填写下表，指明下面每条汇编代码指令存储在寄存器-rdx-中的值：" class="headerlink" title="练习题3.6 假设寄存器 %rax 的值为 x，%rcx 的值为 y。填写下表，指明下面每条汇编代码指令存储在寄存器 %rdx 中的值："></a>练习题3.6 假设寄存器 %rax 的值为 x，%rcx 的值为 y。填写下表，指明下面每条汇编代码指令存储在寄存器 %rdx 中的值：</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">leaq 6 (%rax), %rdx</td>
<td style="text-align:center"><code>x + 6</code></td>
</tr>
<tr>
<td style="text-align:center">leaq (%rax, %rcx), %rdx</td>
<td style="text-align:center"><code>x + y</code></td>
</tr>
<tr>
<td style="text-align:center">leaq (%rax, %rcx, 4), %rdx</td>
<td style="text-align:center"><code>x + 4y</code></td>
</tr>
<tr>
<td style="text-align:center">leaq 7 (%rax, %rax, 8), %rdx</td>
<td style="text-align:center"><code>9x + 7</code></td>
</tr>
<tr>
<td style="text-align:center">leaq 0xA (, %rcx, 4), %rdx</td>
<td style="text-align:center"><code>4y + 10</code></td>
</tr>
<tr>
<td style="text-align:center">leaq 9 (%rax, %rcx, 2), %rdx</td>
<td style="text-align:center"><code>x + 2y + 9</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题3-7考虑下面的代码，我们省略了被计算的表达式："><a href="#练习题3-7考虑下面的代码，我们省略了被计算的表达式：" class="headerlink" title="练习题3.7考虑下面的代码，我们省略了被计算的表达式："></a>练习题3.7考虑下面的代码，我们省略了被计算的表达式：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">scale2</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = ____________________;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 GCC 编译实际的函数得到如下的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  long scale2(long x, long y, long z)</span><br><span class="line">  x in %rdi, y in %rsi, z in %rdx</span><br><span class="line">scale2:</span><br><span class="line">  leaq  (%rdi, %rdi, 4), %rax</span><br><span class="line">  leaq  (%rax, %rsi, 2), %rax</span><br><span class="line">  leaq  (%rax, %rdx, 8), %rax</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>填写出 C 代码中缺失的表达式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> t = <span class="number">5</span>*x + <span class="number">2</span>*y + <span class="number">8</span>*z</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-8-假设下面的值存放指定的内存地址和寄存器中："><a href="#练习题-3-8-假设下面的值存放指定的内存地址和寄存器中：" class="headerlink" title="练习题 3.8 假设下面的值存放指定的内存地址和寄存器中："></a>练习题 3.8 假设下面的值存放指定的内存地址和寄存器中：</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221027211920652.png" alt="image-20221027211920652"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221027211934019.png" alt="image-20221027211934019"></p>
<p>填写下表，给出下面指令的效果，说明将被更新的寄存器或内存位置，以及得到的值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">目的</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">addq %rcx, (%rax)</td>
<td style="text-align:center">0x100</td>
<td style="text-align:center">0xFF + 0x1 = 0x100</td>
</tr>
<tr>
<td style="text-align:center">subq %rdx, 8 (%rax)</td>
<td style="text-align:center">0x108</td>
<td style="text-align:center">0xAB - 0x3 = 0xA8</td>
</tr>
<tr>
<td style="text-align:center">imulq $16, (%rax, %rdx, 8)</td>
<td style="text-align:center">0x100 + 0x3 * 8 = 0x118</td>
<td style="text-align:center">0x11 * 16 = 0x110</td>
</tr>
<tr>
<td style="text-align:center">incq 16 (%rax)</td>
<td style="text-align:center">0x110</td>
<td style="text-align:center">0x14</td>
</tr>
<tr>
<td style="text-align:center">decq %rcx</td>
<td style="text-align:center">%rcx</td>
<td style="text-align:center">0x0</td>
</tr>
<tr>
<td style="text-align:center">subq %rdx, %rax</td>
<td style="text-align:center">%rax</td>
<td style="text-align:center">0x0FD</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-9设我们想生成以下-C-函数的汇编代码："><a href="#练习题-3-9设我们想生成以下-C-函数的汇编代码：" class="headerlink" title="练习题 3.9设我们想生成以下 C 函数的汇编代码："></a>练习题 3.9设我们想生成以下 C 函数的汇编代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">shift_left4_rightn</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    x &lt;&lt;= <span class="number">4</span>;</span><br><span class="line">    x &gt;&gt;= n;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这段汇编代码执行实际的移位，并将最后的结果放在寄存器 %rax 中。此处省略了两条关键的指令。参数 x 和 n 分别存放在寄存器 %rdi 和 %rsi 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  long shift_left4_rightn(long x, long n)</span><br><span class="line">  x in %rdi, n in %rsi</span><br><span class="line">shift_left4_rightn:</span><br><span class="line">  movq  %rdi, %rax    Get x</span><br><span class="line">  ________________    x &lt;&lt;= 4</span><br><span class="line">  movl  %esi, %ecx    Get n (4 bytes)</span><br><span class="line">  ________________    x &gt;&gt;= n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据右边的注释，填出缺失的指令。请使用算术右移操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salq  $4, %rax      x &lt;&lt;= 4</span><br><span class="line">sarq  %cl, %rax     x &gt;&gt;= n</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-10-下面的函数是图3-11a中函数一个变种，其中有些表达式用空格替代"><a href="#练习题-3-10-下面的函数是图3-11a中函数一个变种，其中有些表达式用空格替代" class="headerlink" title="练习题 3.10 下面的函数是图3-11a中函数一个变种，其中有些表达式用空格替代:"></a>练习题 3.10 下面的函数是图3-11a中函数一个变种，其中有些表达式用空格替代:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">arith2</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t1 = _____;</span><br><span class="line">    <span class="type">long</span> t2 = _____;</span><br><span class="line">    <span class="type">long</span> t3 = _____;</span><br><span class="line">    <span class="type">long</span> t4 = _____;</span><br><span class="line">    <span class="keyword">return</span> t4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现这些表达式的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  long arith2(long x, long y, long z)</span><br><span class="line">  x in %rdi, y in %rsi, z in %rdx</span><br><span class="line">arith2:</span><br><span class="line">  orq   %rsi, %rdi</span><br><span class="line">  sarq  $3, %rdi</span><br><span class="line">  notq  %rdi</span><br><span class="line">  movq  %rdx, %rax</span><br><span class="line">  subq  %rdi, %rax</span><br><span class="line">  ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基于这些汇编代码，填写 C 语言代码中缺失的部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> t1 = x | y;</span><br><span class="line"><span class="type">long</span> t2 = t1 &gt;&gt; <span class="number">3</span>;</span><br><span class="line"><span class="type">long</span> t3 = ~ t2;</span><br><span class="line"><span class="type">long</span> t4 = z - t3;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-11常常可以看见以下形式的汇编代码行："><a href="#练习题-3-11常常可以看见以下形式的汇编代码行：" class="headerlink" title="练习题 3.11常常可以看见以下形式的汇编代码行："></a>练习题 3.11常常可以看见以下形式的汇编代码行：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xorq %rdx, %rdx</span><br></pre></td></tr></table></figure>
<p>但是在产生这段汇编代码的 C 代码中，并没有出现 EXCLUSIVE-OR 操作。</p>
<p>A. 解释这条特殊的 EXCLUSIVE-OR 指令的效果，它实现了什么有用的操作。</p>
<p>B. 更直接地表达这个操作的汇编代码是什么？</p>
<p>C. 比较同样一个操作的两种不同实现的编码字节长度。</p>
<blockquote>
<p>A. 这个指令用来将寄存器 %rdx 设置为 0，运用了对任意 x，x^x=0 这一属性。它对应于 C 语句 x=0 。</p>
<p>B. 将寄存器 %rdx 设置为 0 的更直接的方法是用指令 movq $0, %rdx 。</p>
<p>C. 汇编和反汇编这段代码，我们发现使用 xorq 的版本只需要 3 个字节，而使用 movq 的版本需要 7 个字节。其他将 %rdx 设置为 0 的方法都依赖于这样一个属性，即任何更新低位 4 字节的指令都会把高位字节设置为 0 。因此，我们可以使用 xorl %edx, %edx（2 字节）或 movl $0, %edx（5 字节）。</p>
</blockquote>
<h2 id="练习题-3-12-考虑如下函数，它计算两个无符号-64-位数的商和余数："><a href="#练习题-3-12-考虑如下函数，它计算两个无符号-64-位数的商和余数：" class="headerlink" title="练习题 3.12 考虑如下函数，它计算两个无符号 64 位数的商和余数："></a>练习题 3.12 考虑如下函数，它计算两个无符号 64 位数的商和余数：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uremdiv</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x, <span class="type">unsigned</span> <span class="type">long</span> y, <span class="type">unsigned</span> <span class="type">long</span> *qp, <span class="type">unsigned</span> <span class="type">long</span> *rp)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> q = x / y;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r = x % y;</span><br><span class="line">    *qp = q;</span><br><span class="line">    *rp = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改有符号除法的汇编代码来实现这个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  void uremdiv(unsigned long x, unsigned long y, unsigned long *qp, unsigned long *rp)</span><br><span class="line">  x in %rdi, y in %rsi, qp in %rdx, rp in %rcx</span><br><span class="line">uremdiv:</span><br><span class="line">  movq  %rdx, %r8      Copy qp</span><br><span class="line">  movq  %rdi, %rax     Move x to lower 8 bytes of dividend</span><br><span class="line">  movl  $0, %edx       Set upper 8 bytes of divended to 0</span><br><span class="line">  divq  %rsi           Divide by y</span><br><span class="line">  movq  %rax, (%r8)    Store quotient at qp</span><br><span class="line">  movq  %rdx, (%rcx)   Store remainder at rp</span><br><span class="line">  ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-13-虑下列的-C-语言代码："><a href="#练习题-3-13-虑下列的-C-语言代码：" class="headerlink" title="练习题 3.13 虑下列的 C 语言代码："></a>练习题 3.13 虑下列的 C 语言代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(<span class="type">data_t</span> a, <span class="type">data_t</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a COMP b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它给出了参数 a 和 b 之间比较的一般形式，这里，参数的数据类型 <code>data_t</code>（通过 <code>typedef</code>）被声明为表 3-1 中列出的某种整数类型，可以是有符号的也可以是无符号的。 COMP 通过 <code>#define</code> 来定义。</p>
<p>假设 a 在 %rdi 中某个部分，b 在 %rsi 中某个部分。对于下面每个指令序列，确定哪种数据类型 <code>data_t</code> 和比较 COMP 会导致编译器产生这样的代码。（可能有多个正确答案，请列出所有的正确答案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221030184524281.png" alt="image-20221030184524281"></p>
<p>A.后缀 ‘l’ 和寄存器指示符表明是 32 位操作数，而且调用的是有符号的小于比较。所以 <code>data_t</code> 一定是 int 。</p>
<p>B.后缀 ‘w’ 和寄存器指示符表明是 16 位操作数，而且调用的是有符号的大于等于。所以 <code>data_t</code> 一定是 short。</p>
<p>C.后缀 ‘b’ 和寄存器指示符表明是 8 位操作数，而且调用的是无符号小于等于。所以 <code>data_t</code> 一定是 unsigned char 。</p>
<p>D.后缀 ‘q’ 和寄存器指示符表明是 64 位操作数，同时比较符号是 <code>!=</code> ，有符号、无符号和指针参数都是一样的。所以 <code>data_t</code> 可以是 long、unsigned long 或 char * 。</p>
<h2 id="练习题-3-14-考虑下面的-C-语言代码："><a href="#练习题-3-14-考虑下面的-C-语言代码：" class="headerlink" title="练习题 3.14 考虑下面的 C 语言代码："></a>练习题 3.14 考虑下面的 C 语言代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">data_t</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a TEST <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它给出了参数 a 和 0 之间比较的一般形式，这里，我们可以用 <code>typedef</code> 来声明 <code>data_t</code> ，从而设置参数的数据类型，用 <code>#define</code> 来声明 TEST，从而设置比较的类型。对于下面每个指令序列，确定哪种数据类型 <code>data_t</code> 和比较 <code>TEST</code> 会导致编译器产生这样的代码。（可能有多个正确答案，请列出所有的正确答案。）</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221030192217880.png" alt="image-20221030192217880"></p>
<p>A.后缀 ‘q’ 和寄存器指示符表明是 64 位操作数，而且调用有符号大于等于，所以 <code>data_t</code> 一定是 long 。</p>
<p>B.后缀 ‘w’ 和寄存器指示符表明是 16 位操作数，比较符 <code>==</code> 对于有无符号都是一样的。所以 <code>data_t</code> 可以是 <code>short</code> 或者 <code>unsigned short</code> 。</p>
<p>C.后缀 ‘b’ 和寄存器指示符表明是 8 位操作数，使用的是无符号大于，所以 <code>data_t</code> 一定是 <code>unsigned char</code> 。</p>
<p>D.后缀 ‘l’ 和寄存器指示符表明是 32 位操作数，使用的是带符号的小于等于，所以 <code>data_t</code> 一定是 <code>int</code> 。</p>
<h2 id="练习题-3-15在下面这些反汇编二进制代码节选中，有些信息被-X-代替了。回答下列关于这些指令的问题。"><a href="#练习题-3-15在下面这些反汇编二进制代码节选中，有些信息被-X-代替了。回答下列关于这些指令的问题。" class="headerlink" title="练习题 3.15在下面这些反汇编二进制代码节选中，有些信息被 X 代替了。回答下列关于这些指令的问题。"></a>练习题 3.15在下面这些反汇编二进制代码节选中，有些信息被 X 代替了。回答下列关于这些指令的问题。</h2><p>A. 下面 je 指令的目标是什么？（在此，你不需要知道任何有关 callq 指令的信息。）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4003fa: 74 02    je    XXXXXX</span><br><span class="line">4003fc: ff do    callq *%rax</span><br></pre></td></tr></table></figure>
<p>je 指令的目标为 <code>0x4003fc + 0x02 = 0x4003fe</code> 。</p>
<p>B. 下面 je 指令的目标是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">40042f: 74 f4    je   XXXXXX</span><br><span class="line">400431: 5d       pop  %rbp</span><br></pre></td></tr></table></figure>
<p>je 指令的目标为 <code>0x400431 - 12（由于 0xf4 是 -12 的一个字节的补码表示）= 0x400425</code> 。</p>
<p>C. ja 和 pop 指令的地址是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XXXXXX: 77 02    ja   400547</span><br><span class="line">XXXXXX: 5d       pop  %rbp</span><br></pre></td></tr></table></figure>
<p>跳转目标是绝对地址 <code>0x400547</code> 。根据字节编码，一定在距离 pop 指令 <code>0x2</code> 的地址处。所以，pop 指令地址为 <code>0x400547 - 0x2 = 0x400545</code> 。<strong>注意，ja 指令的编码需要 2 个字节。</strong>所以 ja 指令的地址为 <code>0x400543</code> 处。</p>
<p>D. 在下面的代码中，跳转目标的编码是 PC 相对的，且是一个 4 字节补码数。字节按照从最低位到最高位的顺序列出，反映出 x86-64 的小端法字节顺序。跳转目标的地址是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4005e8: e9 73 ff ff ff     jmp  XXXXXX</span><br><span class="line">4005ed: 90                 nop</span><br></pre></td></tr></table></figure>
<p>以相反的顺序来读这些字节，我们看到目标偏移量是 <code>0xffffff73</code> ，或者十进制数 <code>-141</code> 。所以跳转目标为 <code>0x4005ed - 141 = 0x400560</code> 。</p>
<h2 id="练习题-3-16已知下列-C-代码："><a href="#练习题-3-16已知下列-C-代码：" class="headerlink" title="练习题 3.16已知下列 C 代码："></a>练习题 3.16已知下列 C 代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cond</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; a &gt; *p)</span><br><span class="line">        *p = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 会产生下面的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># void cond(long a, long *p)</span><br><span class="line"># a in %rdi, p in %rsi</span><br><span class="line">cond:</span><br><span class="line">  testq  %rsi, %rsi   # 测试 p</span><br><span class="line">  je     .L1          # 如果是 0 就跳转到 L1 </span><br><span class="line">  comq   %rdi, (%rsi) # 比较 *p 和 a</span><br><span class="line">  jge    .L1          # 如果 *p &gt;= a，跳转到 L1</span><br><span class="line">  movq   %rdi, (%rsi) # *p = a</span><br><span class="line">.L1:</span><br><span class="line">  rep; ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. 按照图 3-16b 中所示的风格，用 C 语言写一个 goto 版本，执行同样的计算，并模拟汇编代码的控制流。像示例中那样给汇编代码加上注解可能会有所帮助。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">goto_cond</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    <span class="keyword">if</span> (*p &gt;= a)</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    *p = a;</span><br><span class="line">  done:</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>B. 请说明为什么 C 语言代码中只有一个 if 语句，而汇编代码包含两个条件分支。</p>
<p>第一个条件分支是 &amp;&amp; 表达式实现的一部分。如果对 p 为非空的测试失败，代码会跳过对 <code>a &gt; *p</code> 的测试。</p>
<h2 id="练习题-3-17将-if-语句翻译成-goto-代码的另一种可行的规则如下："><a href="#练习题-3-17将-if-语句翻译成-goto-代码的另一种可行的规则如下：" class="headerlink" title="练习题 3.17将 if 语句翻译成 goto 代码的另一种可行的规则如下："></a>练习题 3.17将 if 语句翻译成 goto 代码的另一种可行的规则如下：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    t = test-expr;</span><br><span class="line">    if (t)</span><br><span class="line">        goto true;</span><br><span class="line">    else-statement</span><br><span class="line">    goto done;</span><br><span class="line">true:</span><br><span class="line">    then-statement</span><br><span class="line">done:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. 基于这种规则，重写 absdiff_se 的 goto 版本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">gotodiff_se_alt</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">        <span class="keyword">goto</span> x_lt_y;</span><br><span class="line">    go_cnt++</span><br><span class="line">    result = x - y;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">x_lt_y:</span><br><span class="line">    lt_cnt++;</span><br><span class="line">    result = y - x;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B. 你能想出选用一种规则而不选用另一种规则的理由吗？</p>
<p>大多数情况下，可以在这两种方式中任意选择。但是原来的方法对常见的没有 else 语句的情况更好一些。对于这种情况，我们只用简单地将翻译规则修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    t = test-expr;</span><br><span class="line">    if (!t)</span><br><span class="line">        goto done;</span><br><span class="line">    then-statement</span><br><span class="line">done:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-18从如下形式的-C-语言代码开始："><a href="#练习题-3-18从如下形式的-C-语言代码开始：" class="headerlink" title="练习题 3.18从如下形式的 C 语言代码开始："></a>练习题 3.18从如下形式的 C 语言代码开始：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">test</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = ___________;</span><br><span class="line">    <span class="keyword">if</span> (______) &#123;</span><br><span class="line">        <span class="keyword">if</span> (______)</span><br><span class="line">            val = ______;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            val = ______;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (______)</span><br><span class="line">        val = ______;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 产生如下的汇编代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># long test(long x, long y, long z)</span></span><br><span class="line"><span class="meta"># x in %rdi, y in %rsi, z in %rdx</span></span><br><span class="line">test:</span><br><span class="line">  leaq  (%rdi, %rsi), %rax  <span class="meta"># long temp1 = x + y</span></span><br><span class="line">  addq  %rdx, %rax          # temp1 = temp1 + z</span><br><span class="line">  cmpq  $<span class="number">-3</span>, %rdi           # 比较 x 和 <span class="number">-3</span></span><br><span class="line">  jge   .L2                 <span class="meta"># x &gt;= -3 时跳转到 L2</span></span><br><span class="line">  cmpq  %rdx, %rsi          # 比较 y 和 z</span><br><span class="line">  jge   .L3                 <span class="meta"># y &gt;= z 时跳转到 L3</span></span><br><span class="line">  movq  %rdi, %rax          # temp1 = x</span><br><span class="line">  imulq %rsi, %rax          # temp1 = temp1 * y</span><br><span class="line">  ret                       <span class="meta"># return</span></span><br><span class="line">.L3:</span><br><span class="line">  movq  %rsi, %rax          # 此时 x &lt; <span class="number">-3</span>，y &gt;= z；temp1 = y</span><br><span class="line">  imulq %rdx, %rax          # temp1 = temp1 * z</span><br><span class="line">  ret                       <span class="meta"># return</span></span><br><span class="line">.L2:</span><br><span class="line">  cmpq  $<span class="number">2</span>, %rdi            # 此时 x &gt;= <span class="number">-3</span>；比较 x 和 <span class="number">2</span></span><br><span class="line">  jle   .L4                 <span class="meta"># x &lt;= 2 时跳转到 L4</span></span><br><span class="line">  movq  %rdi, %rax          # temp1 = x</span><br><span class="line">  imulq %rdx, %rax          # temp1 = temp1 * z</span><br><span class="line">.L4:</span><br><span class="line">  rep; ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>填写 C 代码中缺失的表达式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">test</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, longz)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = x + y + z;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">-3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; z)</span><br><span class="line">            val = x * y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            val = y * z;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">2</span>) </span><br><span class="line">        val = x * z;</span><br><span class="line">   <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-20-下面的-C-函数中，我们对-OP-操作的定义是不完整的：下面的-C-函数中，我们对-OP-操作的定义是不完整的：下面的-C-函数中，我们对-OP-操作的定义是不完整的："><a href="#练习题-3-20-下面的-C-函数中，我们对-OP-操作的定义是不完整的：下面的-C-函数中，我们对-OP-操作的定义是不完整的：下面的-C-函数中，我们对-OP-操作的定义是不完整的：" class="headerlink" title="练习题 3.20 下面的 C 函数中，我们对 OP 操作的定义是不完整的：下面的 C 函数中，我们对 OP 操作的定义是不完整的：下面的 C 函数中，我们对 OP 操作的定义是不完整的："></a>练习题 3.20 下面的 C 函数中，我们对 OP 操作的定义是不完整的：下面的 C 函数中，我们对 OP 操作的定义是不完整的：下面的 C 函数中，我们对 OP 操作的定义是不完整的：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> OP _________ <span class="comment">/* Unknown operator */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">arith</span><span class="params">(<span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x OP <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当编译时，GCC 会产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># long arith(long x)</span><br><span class="line"># x in %rdi</span><br><span class="line">arith:</span><br><span class="line">  leaq  7(%rdi), %rax   # temp = x + 7</span><br><span class="line">  testq %rdi, %rdi      # Test x</span><br><span class="line">  cmovns %rdi, %rax     # if x &gt;= 0, temp = x</span><br><span class="line">  sarq   $3, %rax       # result = temp &gt;&gt; 3 (= x / 8)</span><br><span class="line">  ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. OP 进行的是什么操作？</p>
<p>运算符是 ‘/’ 。可以看到这是一个通过右移实现除以 2 的 3 次幂的例子。在移位 <code>k = 3</code> 之前，如果被除数是负数的话，必须加上偏移量 2k−1=7 （向上舍入）。</p>
<p>B. 给代码添加注释，解释它是如何工作的。</p>
<h2 id="练习题-3-21-C-代码开始的形式如下："><a href="#练习题-3-21-C-代码开始的形式如下：" class="headerlink" title="练习题 3.21 C 代码开始的形式如下："></a>练习题 3.21 C 代码开始的形式如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">test</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = _____;</span><br><span class="line">    <span class="keyword">if</span> (_____) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_____)</span><br><span class="line">            val = ______;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            val = ______;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (______)</span><br><span class="line">        val = ________;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 会产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># long test(long x, long y)</span><br><span class="line"># x in %rdi, y in %rsi</span><br><span class="line">test:</span><br><span class="line">  leaq  0(, %rdi, 8), %rax  # long temp = 8 * x</span><br><span class="line">  testq %rsi, %rsi          # test y</span><br><span class="line">  jle   .L2                 # y &lt;= 0</span><br><span class="line">  movq  %rsi, %rax          # temp = y</span><br><span class="line">  subq  %rdi, %rax          # temp = temp - x</span><br><span class="line">  movq  %rdi, %rdx          # long temp2 = x</span><br><span class="line">  andq  %rsi, %rdx          # temp2 = temp2 &amp; y</span><br><span class="line">  cmpq  %rsi, %rdi          # 比较 x 和 y</span><br><span class="line">  cmovge %rdx, %rax         # x &gt;= y, temp = temp2</span><br><span class="line">  ret</span><br><span class="line">.L2:</span><br><span class="line">  addq  %rsi, %rdi          # x = x + y</span><br><span class="line">  cmpq  $-2, $rsi           # 比较 y 和 -2</span><br><span class="line">  cmovle %rdi, %rax         # y &lt;= -2, temp = x + y</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>填补 C 代码中缺失的表达式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">test</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">8</span> * x;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">            val = y - x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            val = x &amp; y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y &lt;= <span class="number">-2</span>)</span><br><span class="line">        val = x + y;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-22"><a href="#练习题-3-22" class="headerlink" title="练习题 3.22"></a>练习题 3.22</h2><p>A. 用一个 32 位 int 表示 n! ，最大的 n 的值是多少？</p>
<p>如果构建一张使用数据类型 int 来计算的阶乘表，得到下面这样的结果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>n</th>
<th>n!</th>
<th>OK?</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>Y</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>Y</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>Y</td>
</tr>
<tr>
<td>4</td>
<td>24</td>
<td>Y</td>
</tr>
<tr>
<td>5</td>
<td>120</td>
<td>Y</td>
</tr>
<tr>
<td>6</td>
<td>720</td>
<td>Y</td>
</tr>
<tr>
<td>7</td>
<td>5040</td>
<td>Y</td>
</tr>
<tr>
<td>8</td>
<td>40320</td>
<td>Y</td>
</tr>
<tr>
<td>9</td>
<td>362880</td>
<td>Y</td>
</tr>
<tr>
<td>10</td>
<td>3628800</td>
<td>Y</td>
</tr>
<tr>
<td>11</td>
<td>39916800</td>
<td>Y</td>
</tr>
<tr>
<td>12</td>
<td>479001600</td>
<td>Y</td>
</tr>
<tr>
<td>13</td>
<td>1932053504</td>
<td>N</td>
</tr>
</tbody>
</table>
</div>
<p>当 <code>n = 13</code> 时发生溢出，可以通过$x/n$看它是否等于$(n-1)!$进行判断。</p>
<p>B. 如果用一个 64 位 long 表示，最大的 n 的值是多少？</p>
<p>用long表示的话，最大的 n 值为 20，才溢出，也就是知道20！long类型才溢出。</p>
<h2 id="练习题-3-23-已知-C-代码如下："><a href="#练习题-3-23-已知-C-代码如下：" class="headerlink" title="练习题 3.23 已知 C 代码如下："></a>练习题 3.23 已知 C 代码如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">dw_loop</span><span class="params">(<span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="type">long</span> y = x * x;</span><br><span class="line">    <span class="type">long</span> *p = &amp;x;</span><br><span class="line">    <span class="type">long</span> n = <span class="number">2</span> * x;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x += y;</span><br><span class="line">        (*p)++;</span><br><span class="line">        n--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 产生的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># long dw_loop(long x)</span><br><span class="line"># x initially in %rdi</span><br><span class="line"></span><br><span class="line">long dw_loop(long x)</span><br><span class="line">dw_loop:</span><br><span class="line">    movq   %rdi, %rax            # Copy x to %rax   </span><br><span class="line">    movq   %rdi, %rcx               </span><br><span class="line">    imulq  %rdi, %rcx            # Compute y = x*x   </span><br><span class="line">    leaq   (%rdi, %rdi), %rdx    # Compute n = x+x   </span><br><span class="line"></span><br><span class="line">  .L2:                           # loop:</span><br><span class="line">    leaq   1(%rcx, %rax), %rax   # Compute x += y + 1   </span><br><span class="line">    subq   $1, %rdx              # Decrement n   </span><br><span class="line">    testq  %rdx, %rdx            # Test n   </span><br><span class="line">    jg     .L2                   # If &gt; 0, goto loop   </span><br><span class="line">    rep;ret                      # Return   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. 哪些寄存器用来存放程序值 x、y 和 n ？</p>
<p><code>%rax</code> 存放 x ，<code>%rcx</code> 存放 y ，<code>%rdx</code> 存放 n 。</p>
<p>B. 编译器如何消除对指针变量 p 和表达式 <code>(*p)++</code> 隐含的指针间接引用的需求？</p>
<p>编译器认为指针 p 总是指向 x ，因此表达式 <code>(*p)++</code> 就能够实现 x 加一。代码通过 <code>leaq</code> 指令，把这个加一和加 y 组合起来。</p>
<p>C. 对汇编代码添加一些注释，描述程序操作。</p>
<h2 id="练习题-3-24对于如下-C-代码："><a href="#练习题-3-24对于如下-C-代码：" class="headerlink" title="练习题 3.24对于如下 C 代码："></a>练习题 3.24对于如下 C 代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop_while</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = ____;</span><br><span class="line">    <span class="keyword">while</span> (____) &#123;</span><br><span class="line">        result = ____;</span><br><span class="line">        a = ____ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以命令行选项 <code>-Og</code> 运行 GCC 产生如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># long loop_while(long a, long b)</span><br><span class="line"># a in %rdi, b in %rsi</span><br><span class="line">loop_while:</span><br><span class="line">    movl   $1, %eax            </span><br><span class="line">    jmp    .L2                 </span><br><span class="line"></span><br><span class="line">  .L3:</span><br><span class="line">    leaq   (%rdi, %rsi), %rdx  </span><br><span class="line">    imulq  %rdx, %rax          </span><br><span class="line">    addq   $1, %rdi            </span><br><span class="line"></span><br><span class="line">  .L2:</span><br><span class="line">    cmpq   %rsi, %rdi          </span><br><span class="line">    jl     .L3                 </span><br><span class="line">    rep; ret                   </span><br></pre></td></tr></table></figure>
<p>可以看到编译器使用了跳转到中间的翻译方法，在用 jmp 跳转到标号 .L2 开始测试。填写 C 代码中缺失的部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop_while</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a &lt; b) &#123;</span><br><span class="line">        result = result * (a + b);</span><br><span class="line">        a = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-25对于如下-C-代码："><a href="#练习题-3-25对于如下-C-代码：" class="headerlink" title="练习题 3.25对于如下 C 代码："></a>练习题 3.25对于如下 C 代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop_while2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = ____;</span><br><span class="line">    <span class="keyword">while</span> (____) &#123;</span><br><span class="line">        result = ____;</span><br><span class="line">        b = ____ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以命令行选项 <code>-ol</code> 运行 GCC ，产生如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># a in %rdi, b in %rsi</span><br><span class="line">loop_while2:</span><br><span class="line">    testq   %rsi, %rsi      </span><br><span class="line">    jle     .L8             </span><br><span class="line">    movq    %rsi, %rax      </span><br><span class="line">  .L7:</span><br><span class="line">    imulq   %rdi, %rax      </span><br><span class="line">    subq    %rdi, %rsi      </span><br><span class="line">    testq   %rsi, %rsi      </span><br><span class="line">    jg      .L7             </span><br><span class="line">    rep; ret                </span><br><span class="line">  .L8:</span><br><span class="line">    movq    %rsi, %rax      </span><br><span class="line">    ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到编译器使用了 guarded-do 的翻译方法，使用了 <code>jle</code> 指令使得当初始测试不成立时，忽略循环代码。填写缺失的 C 代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop_while2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = b;</span><br><span class="line">    <span class="keyword">while</span> (b&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        result = result * a;</span><br><span class="line">        b = b - a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-26-函数-fun-a-有如下整体结构："><a href="#练习题-3-26-函数-fun-a-有如下整体结构：" class="headerlink" title="练习题 3.26 函数 fun_a 有如下整体结构："></a>练习题 3.26 函数 fun_a 有如下整体结构：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fun_a</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC C 编译器产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># long fun_a(unsigned long x)</span><br><span class="line"># x in %rdi</span><br><span class="line">long fun_a(unsigned long x)</span><br><span class="line"></span><br><span class="line">fun_a:</span><br><span class="line">    movl   $0, eax      </span><br><span class="line">    jmp    .L5          </span><br><span class="line"></span><br><span class="line">  .L6:</span><br><span class="line">    xorq   %rdi, %rax   </span><br><span class="line">    shrq   %rdi         # Shift right by 1</span><br><span class="line"></span><br><span class="line">  .L5:</span><br><span class="line">    testq  %rdi, %rdi   </span><br><span class="line">    jne    .L6          </span><br><span class="line">    andl   $1, %eax     </span><br><span class="line">    ret                 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>逆向工程这段代码的操作，然后完成下面作业：</p>
<p>A. 确定这段代码使用的循环翻译方法。</p>
<p>使用的是跳转到中间翻译方法。汇编中使用了 <code>jmp</code> 指令。</p>
<p>B. 根据汇编代码版本填写完 C 代码中缺失的部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fun_a</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        val ^= x ;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> val &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C. 用自然语言描述这个函数是计算什么的。</p>
<p>这个代码计算参数 x 的奇偶性。也就是，如果 x 中有奇数个 1，就返回 1，如果有偶数个 1，就返回 0。</p>
<h2 id="练习题-3-27"><a href="#练习题-3-27" class="headerlink" title="练习题 3.27"></a>练习题 3.27</h2><p>先把 <code>fact_for</code> 转换成 while 循环，再进行 guarded-do 变化，写出 <code>fact_for</code> 的 goto 代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_for_gd_goto</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    loop:</span><br><span class="line">        result *= i;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= n)</span><br><span class="line">            <span class="keyword">goto</span> loop;</span><br><span class="line">    done:</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-28函数-fun-b-有如下整体结构："><a href="#练习题-3-28函数-fun-b-有如下整体结构：" class="headerlink" title="练习题 3.28函数 fun_b 有如下整体结构："></a>练习题 3.28函数 <code>fun_b</code> 有如下整体结构：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fun_b</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( ... ; ... ; ... ) &#123;</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GCC 编译器产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># long fun_b(unsigned long x)</span><br><span class="line"># x in %rdi</span><br><span class="line"></span><br><span class="line">fun_b:</span><br><span class="line">    movl   $64, %edx        # %edx 寄存器中存入 64</span><br><span class="line">    movl   $0, %eax         # 对应 long val = 0</span><br><span class="line"></span><br><span class="line">  .L10:</span><br><span class="line">    movq   %rdi, %rcx       # long temp = x</span><br><span class="line">    andl   $1, %ecx         # temp = temp ^ 0x1  x 的最低位</span><br><span class="line">    addq   %rax, %rax       # val = val * 2</span><br><span class="line">    orq    %rcx, %rax       # val = val | temp 最低位如果是 1，就是真</span><br><span class="line">    shrq   %rdi             # 逻辑右移 1 位</span><br><span class="line">    subq   $1, %rdx         # 装入寄存器，减去 1</span><br><span class="line">    jne    .L10             # %rdx 不是 0 的情况下继续循环</span><br><span class="line">    rep; ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>逆向工程这段代码的操作，然后完成下面的工作：</p>
<p>A. 根据汇编代码版本填写 C 代码中缺失的部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fun_b</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">64</span> ; i!=<span class="number">0</span> ; i-- ) &#123;</span><br><span class="line">        val = (val &lt;&lt; <span class="number">1</span>) | (x &amp; <span class="number">0x1</span>);</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>B. 解释循环前为什么没有初识测试也没有初始跳转到循环内部的测试部分。</p>
<p>这段代码使用 guarded-do 变换生成的，但是编译器发现因为 i 初始化成了 64，所以一定会满足测试 <code>i != 0</code> ，因此初始的测试是没必要的。</p>
<p>C. 用自然语言描述这个函数是计算什么的。</p>
<p>这段代码把 x 中的位反过来，创造一个镜像。实现的方法是：将 x 的位从左往右移，然后再填入这些位，就像是把 val 从右往左移。</p>
<h2 id="练习题-3-29"><a href="#练习题-3-29" class="headerlink" title="练习题 3.29"></a>练习题 3.29</h2><p>在 C 语言中执行 continue 语句会导致程序跳到当前循环迭代的结尾。当处理 continue 语句时，将 for 循环翻译成 while 循环的描述规则需要一些改进。例如，当考虑下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Example of for loop containing a continue statement */</span></span><br><span class="line"><span class="comment">/* Sum even numbers between 0 and 9 */</span></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. 如果我们简单地直接应用将 for 循环翻译到 while 循环的规则，会得到什么呢？产生的代码会有什么错误呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Naive translation of for loop into while loop */</span></span><br><span class="line"><span class="comment">/* WARNING: This is buggy code */</span></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="comment">/* This will cause an infinite loop */</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为 continue 语句会阻止索引变量 i 被修改，所以这段代码是无限循环。</p>
<p>B. 如何用 goto 语句来替代 continue 语句，保证 while 循环的行为同 for 循环的行为完全一样？</p>
<p>通用的解决方法是用 goto 语句替代 continue 语句，它会跳过循环体中余下的部分，直接跳到 update 部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Correct translation of for loop into while loop */</span></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">goto</span> update;</span><br><span class="line">    sum += i;</span><br><span class="line">    update:</span><br><span class="line">        i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-30下面的-C-函数省略了-switch-语句的主体。在-C-代码中，情况标号是不连续的，而有些情况有多个标号。"><a href="#练习题-3-30下面的-C-函数省略了-switch-语句的主体。在-C-代码中，情况标号是不连续的，而有些情况有多个标号。" class="headerlink" title="练习题 3.30下面的 C 函数省略了 switch 语句的主体。在 C 代码中，情况标号是不连续的，而有些情况有多个标号。"></a>练习题 3.30下面的 C 函数省略了 switch 语句的主体。在 C 代码中，情况标号是不连续的，而有些情况有多个标号。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch2</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        .</span><br><span class="line">        .  <span class="comment">// Body of switch statement omitted</span></span><br><span class="line">        .</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在编译该函数时，GCC 为程序的初始部分生成了以下汇编代码，变量 x 在寄存器 <code>%rdi</code> 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># void switch2(long x, long *dest)</span><br><span class="line"># x in %rdi</span><br><span class="line">switch2:</span><br><span class="line">    addq    $1, %rdi    # x = x + 1 ，由于将索引控制在 0 开始，所以 x 的最小值是 -1      </span><br><span class="line">    cmpq    $8, %rdi    # 比较 x - 8，其实就是 x + 1 - 8 &gt; 0 ，则原始的 x 最大标号是 7       </span><br><span class="line">    ja      .L2         # 超过 8 就跳转到 L2，L2 相当于 default   </span><br><span class="line">    jmp     *.L4(, %rdi, 8)    # 没有超过 8 就进入跳转表</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为跳转表生成以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.L4</span><br><span class="line">    quad:   .L9    # -1</span><br><span class="line">    quad:   .L5    # 0</span><br><span class="line">    quad:   .L6    # 1</span><br><span class="line">    quad:   .L7    # 2</span><br><span class="line">    quad:   .L2    # default</span><br><span class="line">    quad:   .L7    # 4</span><br><span class="line">    quad:   .L8    # 5</span><br><span class="line">    quad:   .L2    # default </span><br><span class="line">    quad:   .L5    # 7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. switch 语句内情况标号的值分别是多少？</p>
<p>-1、0、1、2、4、5 和 7</p>
<p>B. C 代码中哪些情况有多个标号？</p>
<p><code>.L5</code> 的情况为 0 和 7，<code>.L7</code> 的情况标号为 2 和 4。</p>
<h2 id="练习题-3-31"><a href="#练习题-3-31" class="headerlink" title="练习题 3.31"></a>练习题 3.31</h2><p>对于一个通用结构的 C 函数 switcher:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switcher</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b, <span class="type">long</span> c, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">    <span class="keyword">case</span> ____:     <span class="comment">/* Case A */</span></span><br><span class="line">        c = ____;</span><br><span class="line">        <span class="comment">/* Fall through */</span></span><br><span class="line">    <span class="keyword">case</span> ____:     <span class="comment">/* Case B */</span></span><br><span class="line">        val = ____;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ____:     <span class="comment">/* Case C */</span></span><br><span class="line">    <span class="keyword">case</span> ____:     <span class="comment">/* Case D */</span></span><br><span class="line">        val = ____;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ____:     <span class="comment">/* Case E */</span></span><br><span class="line">        val = ____;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = ____;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 产生如下所示的汇编代码和跳转表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221108153523592.png" alt="image-20221108153523592"></p>
<p>填写 C 代码中缺失的部分。除了情况标号 C 和 D 的顺序之外，将不同情况填入这个模板的方式是唯一的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switcher</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b, <span class="type">long</span> c, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:     <span class="comment">/* Case A */</span></span><br><span class="line">        c = b ^ <span class="number">15</span>;</span><br><span class="line">        <span class="comment">/* Fall through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:     <span class="comment">/* Case B */</span></span><br><span class="line">        val = c + <span class="number">112</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> :     <span class="comment">/* Case C */</span></span><br><span class="line">    <span class="keyword">case</span> :     <span class="comment">/* Case D */</span></span><br><span class="line">        val =  (c + b) &lt;&lt; <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> :     <span class="comment">/* Case E */</span></span><br><span class="line">        val = a;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = b;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-32"><a href="#练习题-3-32" class="headerlink" title="练习题 3.32"></a>练习题 3.32</h2><p>下面列出的是两个函数 first 和 last 的反汇编代码，以及 main 函数调用 first 的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Disassembly of last(long u, long v)</span><br><span class="line"># u in %rdi, v in %rsi</span><br><span class="line">0000000000400540 &lt;last&gt;:</span><br><span class="line">  400540:  48 89 f8          mov   %rdi, %rax     # L1: u</span><br><span class="line">  400543:  48 0f af c6       imul  %rsi, %rax     # L2: u*v</span><br><span class="line">  400547:  c3                req                  # L3: Return</span><br><span class="line">  </span><br><span class="line"># Disassembly of first(long x)</span><br><span class="line"># x in %rdi</span><br><span class="line">0000000000400548 &lt;first&gt;:</span><br><span class="line">   400548: 48 8d 77 01       lea   0x1(%rdi), %rsi  # F1: x+1</span><br><span class="line">   40054c: 48 83 ef 01       sub   $0x1, %rdi       # F2: x-1</span><br><span class="line">   400500: e8 eb ff ff ff    callq 400540 &lt;last&gt;    # F3: Call last(x-1, x+1)</span><br><span class="line">   400555: f3 c3             repz  retq             # F4: Return</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   400560: e8 e3 ff ff ff    callq 400548 &lt;first&gt;   # M1: Call first(10)</span><br><span class="line">   400565: 48 89 c2          mov   %rax, %rdx       # M2: Resume</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从 main 调用 first(10) 开始，到程序返回 main 时为止，填写下表记录指令执行的过程。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">指令</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">状态值</th>
<th style="text-align:center">(指令执行前)</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标号</td>
<td style="text-align:center">PC</td>
<td style="text-align:center">指令</td>
<td style="text-align:center">%rdi</td>
<td style="text-align:center">%rsi</td>
<td style="text-align:center">%rax</td>
<td style="text-align:center">%rsp</td>
<td style="text-align:center"><em>%rsp</em></td>
<td style="text-align:center">描述</td>
</tr>
<tr>
<td style="text-align:center">M1</td>
<td style="text-align:center">0x400560</td>
<td style="text-align:center">callq</td>
<td style="text-align:center">10</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0x7fffffffe820</td>
<td style="text-align:center">-</td>
<td style="text-align:center">调用 first(10)</td>
</tr>
<tr>
<td style="text-align:center">F1</td>
<td style="text-align:center">0x400548</td>
<td style="text-align:center">leq</td>
<td style="text-align:center">10</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0x7fffffffe818</td>
<td style="text-align:center">0x400565</td>
<td style="text-align:center">first 的入口</td>
</tr>
<tr>
<td style="text-align:center">F2</td>
<td style="text-align:center">0x40054c</td>
<td style="text-align:center">sub</td>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0x7fffffffe818</td>
<td style="text-align:center">0x400565</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">F3</td>
<td style="text-align:center">0x400550</td>
<td style="text-align:center">callq</td>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0x7fffffffe810</td>
<td style="text-align:center">0x400565</td>
<td style="text-align:center">调用 last(9, 11)</td>
</tr>
<tr>
<td style="text-align:center">L1</td>
<td style="text-align:center">0x400540</td>
<td style="text-align:center">mov</td>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0x7fffffffe810</td>
<td style="text-align:center">0x400555</td>
<td style="text-align:center">last 的入口</td>
</tr>
<tr>
<td style="text-align:center">L2</td>
<td style="text-align:center">0x400543</td>
<td style="text-align:center">imul</td>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">9</td>
<td style="text-align:center">0x7fffffffe810</td>
<td style="text-align:center">0x400555</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">L3</td>
<td style="text-align:center">0x400547</td>
<td style="text-align:center">retq</td>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">99</td>
<td style="text-align:center">0x7fffffffe810</td>
<td style="text-align:center">0x400555</td>
<td style="text-align:center">从 last 返回 99</td>
</tr>
<tr>
<td style="text-align:center">F4</td>
<td style="text-align:center">0x400555</td>
<td style="text-align:center">repz repq</td>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">99</td>
<td style="text-align:center">0x7fffffffe818</td>
<td style="text-align:center">0x400565</td>
<td style="text-align:center">从 first 返回 99</td>
</tr>
<tr>
<td style="text-align:center">M2</td>
<td style="text-align:center">0x400565</td>
<td style="text-align:center">mov</td>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">99</td>
<td style="text-align:center">0x7fffffffe820</td>
<td style="text-align:center">-</td>
<td style="text-align:center">继续执行 main</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-33"><a href="#练习题-3-33" class="headerlink" title="练习题 3.33"></a>练习题 3.33</h2><p>C 函数 <code>procprob</code> 有 4 个参数 u、a、v 和 b，每个参数要么是一个有符号数，要么是一个指向有符号数的指针，这里的数大小不同。该函数的函数体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*u += a;</span><br><span class="line">*v += b;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">sizeof</span>(a) + <span class="keyword">sizeof</span>(b);</span><br></pre></td></tr></table></figure>
<p>编译得到如下 x86-64 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">procprob:</span><br><span class="line">  movslq  %edi, %rdi</span><br><span class="line">  addq    %rdi, (%rdx)</span><br><span class="line">  addb    %sil, (%rcx)</span><br><span class="line">  movl    $6, %eax</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>确定 4 个参数的合法顺序和类型。</p>
<p>因为代码的 return 里返回的是 6，所以可以知道 a 和 b 两个数一个是 4 位长，一个是 2 位长。</p>
<p>假如 a 是 4 位长度， 则一开始扩展 %edi 符号实际上操作的是 a， 那么之后把 a 加到 (%rdx) 上边，说明 %rdx 中是 u。对应的，%sil 中是 b，%rcx 中是 v。</p>
<p>a 通过 %edi 作为第一个参数传递，把它从 4 个字节转换成 8 个字节，再加到 %rdx 指向的 8 个字节上。这就意味着 a 必定是 int 类型，u 一定是 long <em> 类型。还可以看到 b 的低位字节被加到了 %rcx 指向的字节。这就意味着 v 一定是 char </em> 。</p>
<p>假如 b 是 4 位长度,，则一开始扩展 %edi 符号实际上操作的是 b ，那么之后把 b 加到 (%rdx) 上边，说明 %rdx 中是 v。对应的，%sil 中是 a，%rcx 中是 u 。</p>
<p>所以两种情况是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">procprob</span><span class="params">(<span class="type">int</span> a, <span class="type">short</span> b, <span class="type">long</span> *u, <span class="type">char</span> *v)</span>`</span><br><span class="line"><span class="type">int</span> <span class="title function_">procprob</span><span class="params">(<span class="type">int</span> b, <span class="type">short</span> a, <span class="type">long</span> *v, <span class="type">char</span> *u)</span></span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-34"><a href="#练习题-3-34" class="headerlink" title="练习题 3.34"></a>练习题 3.34</h2><p>一个函数 P 生成名为 a0 ~ a7 的局部变量，然后调用函数 Q ，没有参数。GCC 为 P 的第一部分产生如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># long P(long x)</span><br><span class="line"># x in %rdi</span><br><span class="line">P:</span><br><span class="line">    pushq   %r15</span><br><span class="line">    pushq   %r14</span><br><span class="line">    pushq   %r13</span><br><span class="line">    pushq   %r12</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    pushq   %rbx    </span><br><span class="line"></span><br><span class="line">    subq    $24, %rsp      </span><br><span class="line"></span><br><span class="line">    movq    %rdi, %rbx     </span><br><span class="line">    leaq    1(%rdi), %r15  </span><br><span class="line">    leaq    2(%rdi), %r14  </span><br><span class="line">    leaq    3(%rdi), %r13  </span><br><span class="line">    leaq    4(%rdi), %r12  </span><br><span class="line">    leaq    5(%rdi), %rbp  </span><br><span class="line"></span><br><span class="line">    leaq    6(%rdi), %rax  </span><br><span class="line">    mov     %rax, (%rsp)   </span><br><span class="line">    leaq    7(%rdi), %rdx  </span><br><span class="line">    movq    %rdx, 8(%rsp)  </span><br><span class="line">    movl    $0, %eax       </span><br><span class="line">    call    Q              </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. 确定哪些局部值存储在被调用者保存寄存器中。</p>
<p>局部值 a0 ~ a5 分别保存被调用者保存寄存器 %rbx、%r15、%r14、%13、%12 和 %rbp。</p>
<p>B. 确定哪些局部变量存储在栈上。</p>
<p>局部值 a6 和 a7 存放在栈中相对于栈指针偏移量为 0 和 8 的地方。</p>
<p>C. 解释为什么不能把所有的局部值都存储在被调用者保存寄存器中。</p>
<p>存储完 6 个局部变量后，程序用完了所有的被调用者保存寄存器，所以剩下的两个值保存在栈上。</p>
<h2 id="练习题-3-35-一个具有通用结构的-C-函数如下："><a href="#练习题-3-35-一个具有通用结构的-C-函数如下：" class="headerlink" title="练习题 3.35 一个具有通用结构的 C 函数如下："></a>练习题 3.35 一个具有通用结构的 C 函数如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rfun</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(______)&#123;</span><br><span class="line">        <span class="keyword">return</span> ______;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nx = ______;</span><br><span class="line">    <span class="type">long</span> rv = rfun(nx);</span><br><span class="line">    <span class="keyword">return</span> ______;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GCC 产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># long rfun(unsigned long x)</span><br><span class="line"># x in %rdi</span><br><span class="line"></span><br><span class="line">rfun:</span><br><span class="line">    pushq   %rbx           </span><br><span class="line">    movq    %rdi, %rbx     </span><br><span class="line">    movl    %0, %eax       </span><br><span class="line">    testq   %rdi, %rdi     </span><br><span class="line">    je      .L2            </span><br><span class="line">    shrq    $2, %rdi       </span><br><span class="line">    callq   rfun           </span><br><span class="line">    addq    %rbx, %rax     </span><br><span class="line"></span><br><span class="line">  .L2</span><br><span class="line">    popq    %rbx           </span><br><span class="line">    ret                    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. rfun 存储在被调用者保存器 %rbx 中的值是什么？</p>
<p>寄存器 %rbx 保存参数 x 的值</p>
<p>B. 填写上述 C 代码中缺失的表达式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rfun</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nx = x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">	<span class="type">long</span> rv = rfun(nx);</span><br><span class="line">    <span class="keyword">return</span> x + rv ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-36"><a href="#练习题-3-36" class="headerlink" title="练习题 3.36"></a>练习题 3.36</h2><p>考虑下面的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> S[<span class="number">7</span>];</span><br><span class="line"><span class="type">short</span> *T[<span class="number">3</span>];</span><br><span class="line"><span class="type">short</span> **U[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span>   V[<span class="number">8</span>];</span><br><span class="line"><span class="type">double</span> *W[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>填写下表，描述每个数组的元素大小、整个数组的大小以及元素 i 的地址：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数组</th>
<th style="text-align:center">元素大小</th>
<th style="text-align:center">整个数组的大小</th>
<th style="text-align:center">起始地址</th>
<th style="text-align:center">元素 i</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">2</td>
<td style="text-align:center">14</td>
<td style="text-align:center">$x_S$</td>
<td style="text-align:center">$x_S+2i$</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">8</td>
<td style="text-align:center">24</td>
<td style="text-align:center">$x_T$</td>
<td style="text-align:center">$x_T+8i$</td>
</tr>
<tr>
<td style="text-align:center">U</td>
<td style="text-align:center">8</td>
<td style="text-align:center">48</td>
<td style="text-align:center">$x_U$</td>
<td style="text-align:center">$x_U+8i$</td>
</tr>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32</td>
<td style="text-align:center">$x_V$</td>
<td style="text-align:center">$x_V+4i$</td>
</tr>
<tr>
<td style="text-align:center">W</td>
<td style="text-align:center">8</td>
<td style="text-align:center">32</td>
<td style="text-align:center">$x_W$</td>
<td style="text-align:center">$x_W+8i$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-37"><a href="#练习题-3-37" class="headerlink" title="练习题 3.37"></a>练习题 3.37</h2><p>假设短整形数组 S 的地址 $x_S$ 和整数索引 i 分别存放在寄存器 <code>%rdx</code> 和 <code>%rcx</code> 中。对下面每个表达式，给出它的类型、值的表达式和汇编代码实现。如果结果是指针的话，要保存在寄存器 <code>%rax</code> 中，如果数据类型为 short，就保存在寄存器元素 <code>%ax</code> 中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">值</th>
<th style="text-align:center">汇编代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>S + 1</code></td>
<td style="text-align:center">short*</td>
<td style="text-align:center">$x_S+2$</td>
<td style="text-align:center"><code>leaq 2(%rdx), %rax</code></td>
</tr>
<tr>
<td style="text-align:center"><code>S[3]</code></td>
<td style="text-align:center">short</td>
<td style="text-align:center">$M[x_S+6]$</td>
<td style="text-align:center"><code>movw 6(%rdx), %ax</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;S[i]</code></td>
<td style="text-align:center">short*</td>
<td style="text-align:center">$x_S+2i$</td>
<td style="text-align:center"><code>leaq (%rdx, %rcx, 2), %rax</code></td>
</tr>
<tr>
<td style="text-align:center"><code>S[4*i+1]</code></td>
<td style="text-align:center">short</td>
<td style="text-align:center">$M[x_S+8_i+2]$</td>
<td style="text-align:center"><code>movw 2(%rdx, %rcx, 8), %ax</code></td>
</tr>
<tr>
<td style="text-align:center"><code>S + i - 5</code></td>
<td style="text-align:center">short*</td>
<td style="text-align:center">$x_S+2i−10$</td>
<td style="text-align:center"><code>leaq -10(%rdx, %rcx, 2), %rax</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-38"><a href="#练习题-3-38" class="headerlink" title="练习题 3.38"></a>练习题 3.38</h2><p>考虑下面的源码，其中 M 和 N 是用 <code>#define</code> 声明的常数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> P[M][N];</span><br><span class="line"><span class="type">long</span> Q[N][M];</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">sum_element</span><span class="params">(<span class="type">long</span> i, <span class="type">long</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> P[i][j] + Q[j][i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译这个程序中，GCC 产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># long sum_element(long i, long j)</span><br><span class="line"># i in %rdi, j in %rsi</span><br><span class="line"></span><br><span class="line">sum_element:</span><br><span class="line">    leaq   0(,%rdi, 8),  %rdx       # %rdx = 8i</span><br><span class="line">    subq   %rdi, %rdx               # %rdx - i = 7i</span><br><span class="line">    addq   %rsi, %rdx               # %rdx = 7i + j</span><br><span class="line">    leaq   (%rsi, %rsi, 4), %rax    # %rax = 5j</span><br><span class="line">    addq   %rax, %rdi               # %rdi = i + 5j</span><br><span class="line">    movq   Q(, %rdi, 8), %rax       # M[xQ + 8(5j + i)]</span><br><span class="line">    movq   P(, %rdx, 8), %rax       # M[xP + 8(7i + j)]</span><br><span class="line">    ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运用逆向工程技能，根据这段汇编代码，确定 M 和 N 的值。</p>
<p>P 有 7 列，Q 有 5 列，得到 <code>M=5</code> 和 <code>M=7</code> 。</p>
<h2 id="练习题3-39"><a href="#练习题3-39" class="headerlink" title="练习题3.39"></a>练习题3.39</h2><p>利用等式3.1来解释图3-37b的C代码中Aptr、Bptr和 Bend的初始值计算(第3~5行)是如何正确反映fix_prod_ele的汇编代码中它们的计算(第3~5行)的。</p>
<p>对于L=4，C=16和j=0，指针Aptr等于$x_A＋4×(16i＋0)=x_A+64i$。</p>
<p>对于L=4，C=16，i=0和j=k，指针 Bptr等于$x_B+4×(16×0+k)=x_B+4k$。</p>
<p>对于L=4，C=16，i=16和j=k，Bend等于$x_B+4×(16×16+k)=x_B+1024+4k$。</p>
<h2 id="练习题-3-41考虑下面的结构声明："><a href="#练习题-3-41考虑下面的结构声明：" class="headerlink" title="练习题 3.41考虑下面的结构声明："></a>练习题 3.41考虑下面的结构声明：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prob</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">    &#125; s;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">prob</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个声明说明一个结构可以嵌套在另一个结构中，就像数组可以嵌套在结构中、数组可以嵌套在数组中一样。</p>
<p>下面的过程（省略了某些表达式）对这个结构进行操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sp_init</span><span class="params">(<span class="keyword">struct</span> prob *sp)</span> &#123;</span><br><span class="line">    sp-&gt;s.x = _____;</span><br><span class="line">    sp-&gt;p   = _____;</span><br><span class="line">    sp-&gt;next= _____;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A. 下列字段的偏移量是多少（以字节为单位）？</p>
<p>p: 指针 p 是第一个元素，偏移量为 0<br>s.x: 是紧接在 p 之后的结构内第一个元素，偏移量为 8<br>s.y: x 的长度为 4，所以偏移量为 12<br>next: y 的长度为 4，所以偏移量为 16</p>
<p>B. 这个结构总共需要多少字节？<br>指针长度为 8，int为4，总共24字节。</p>
<p>C. 编译器为 <code>sp_init</code> 的主体产生的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># void sp_init(struct prob *sp)</span><br><span class="line"># sp in %rdi</span><br><span class="line">sp_init:</span><br><span class="line">movl 12(%rdi), %eax     # Get sp-&gt;s.y</span><br><span class="line">movl %eax, 8(%rdi)      # Save in sp-&gt;s.x</span><br><span class="line">leaq 8(%rdi), %rax      # Compute &amp;(sp-&gt;s.x)</span><br><span class="line">movq %rax, (%rdi)       # Store in sp-&gt;p</span><br><span class="line">movq %rdi, 16(%rdi)     # Store sp in sp-&gt;next</span><br><span class="line">ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据这些信息，填写 <code>sp_init</code> 代码中缺失的表达式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sp_init</span><span class="params">(<span class="keyword">struct</span> prob *sp)</span> &#123;</span><br><span class="line">    sp-&gt;s.x = sp-&gt;s.y ;</span><br><span class="line">    sp-&gt;p   = &amp;(sp-&gt;s.x);</span><br><span class="line">    sp-&gt;next= sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-42下面的代码给出了类型-ELE-的结构声明以及函数-fun-的原型："><a href="#练习题-3-42下面的代码给出了类型-ELE-的结构声明以及函数-fun-的原型：" class="headerlink" title="练习题 3.42下面的代码给出了类型 ELE 的结构声明以及函数 fun 的原型："></a>练习题 3.42下面的代码给出了类型 ELE 的结构声明以及函数 fun 的原型：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fun</span><span class="params">(<span class="keyword">struct</span> ELE *ptr)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当编译 fun 的代码时，GCC 会产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># long fun(struct ELE *ptr)</span><br><span class="line"># ptr in %rdi</span><br><span class="line"></span><br><span class="line">fun:</span><br><span class="line">    movl   $0, %eax          # result = 0</span><br><span class="line">    jmp    .L2               # Goto middle</span><br><span class="line">  .L3:                       # loop:</span><br><span class="line">    addq   (%rdi), %rax      # result += ptr-&gt;v</span><br><span class="line">    movq   8(%rdi), %rdi     # ptr = ptr-&gt;p</span><br><span class="line">  .L2:                       # middle:</span><br><span class="line">    testq  %rdi, %rdi        # Test ptr</span><br><span class="line">    jne    .L3               # If != NULL, goto loop</span><br><span class="line">    rep; ret                </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. 利用逆向工程技巧写出 fun 的 C 代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fun</span><span class="params">(<span class="keyword">struct</span> ELE *ptr)</span> &#123;</span><br><span class="line">	<span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr)&#123;</span><br><span class="line">        val += ptr-&gt;v;</span><br><span class="line">        ptr = ptr-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B. 描述这个结构实现的数据结构以及 fun 执行的操作。</p>
<p>每个结构都是一个单链表中的元素，字段 v 是元素的值，字段 p 是指向下一个元素的指针。函数 fun 计算列表中元素值的和。</p>
<h2 id="习题-3-43"><a href="#习题-3-43" class="headerlink" title="习题 3.43"></a>习题 3.43</h2><p>假设给你个任务，检查一下 C 编译器为结构和联合的访问产生正确的代码。你写了下面的结构声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">long</span> u;</span><br><span class="line">        <span class="type">short</span> v;</span><br><span class="line">        <span class="type">char</span> w;</span><br><span class="line">    &#125; t1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">        <span class="type">char</span> *p;</span><br><span class="line">    &#125; t2;</span><br><span class="line">&#125; u_type;</span><br></pre></td></tr></table></figure>
<p>你写了一组具有下面这种形式的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get</span><span class="params">(u_type *up, type *dest)</span> &#123;</span><br><span class="line">    *dest = expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这组函数有不一样的访问表达式 expr，而且根据 expr 的类型来设置目的数据类型 type 。然后再检查编译这些函数时产生的代码，看看它们是否与你预期的一样。</p>
<p>假设在这些函数中，up 和 dest 分别被加载到寄存器 <code>%rdi</code> 和 <code>%rsi</code> 中。填写下表中的数据类型 type，并用 1 ~ 3 条指令序列来计算表达式，并将结果存储到 dest 中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>expr</th>
<th>type</th>
<th>代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>up-&gt;t1.u</code></td>
<td>long</td>
<td><code>movq (%rdi), %rax movq %rax, (%rsi)</code></td>
</tr>
<tr>
<td><code>up-&gt;t1.v</code></td>
<td>short</td>
<td><code>movw 8(%rdi), %ax movw %ax, (%rsi)</code></td>
</tr>
<tr>
<td><code>&amp;up-&gt;t1.w</code></td>
<td>char*</td>
<td><code>addq $10, %rdi movq %rdi, (%rsi)</code></td>
</tr>
<tr>
<td><code>up-&gt;t2.a</code></td>
<td>int*</td>
<td><code>movq %rdi, (%rsi)</code></td>
</tr>
<tr>
<td><code>up-&gt;t2.a[up-&gt;t1.u]</code></td>
<td>int</td>
<td><code>movq (%rdi), %rax movl (%rdi, %rax, 4), %eax movl %eax, (%rsi)</code></td>
</tr>
<tr>
<td><code>*up-&gt;t2.p</code></td>
<td>char</td>
<td><code>movq 8(%rdi), %rax movb (%rax), %al movb %al, (%rsi)</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-44-对下面每个结构声明，确定每个字段的偏移量，结构总的大小，以及在-x86-64-下它的对齐要求："><a href="#练习题-3-44-对下面每个结构声明，确定每个字段的偏移量，结构总的大小，以及在-x86-64-下它的对齐要求：" class="headerlink" title="练习题 3.44 对下面每个结构声明，确定每个字段的偏移量，结构总的大小，以及在 x86-64 下它的对齐要求："></a>练习题 3.44 对下面每个结构声明，确定每个字段的偏移量，结构总的大小，以及在 x86-64 下它的对齐要求：</h2><p>A. <code>struct P1 &#123;int i; char c; int j; char d&#125;;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>i</th>
<th>c</th>
<th>j</th>
<th>d</th>
<th>总共</th>
<th>对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>8</td>
<td>12</td>
<td>16</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<p>B. <code>struct P2 &#123;int i; char c; char d; long j&#125;;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>i</th>
<th>c</th>
<th>d</th>
<th>j</th>
<th>总共</th>
<th>对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>5</td>
<td>8</td>
<td>16</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p>​    C. <code>struct P3 &#123;short w[3]; char c[3]&#125;;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>w</th>
<th>c</th>
<th>总共</th>
<th>对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>6</td>
<td>10</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>D. <code>struct P4 &#123;short w[5]; char *c[3]&#125;;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>w</th>
<th>c</th>
<th>总共</th>
<th>对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>16</td>
<td>40</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p>E. <code>struct P5 &#123;struct P3 a[2]; struct P2 t&#125;;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th>t</th>
<th>总共</th>
<th>对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>24</td>
<td>40</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-45"><a href="#练习题-3-45" class="headerlink" title="练习题 3.45"></a>练习题 3.45</h2><p>对于下列结构声明回答后续问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>  *a;    </span><br><span class="line">    <span class="type">short</span>  b;    </span><br><span class="line">    <span class="type">double</span> c;   </span><br><span class="line">    <span class="type">char</span>   d;     </span><br><span class="line">    <span class="type">float</span>  e;    </span><br><span class="line">    <span class="type">char</span>   f;     </span><br><span class="line">    <span class="type">long</span>   g;     </span><br><span class="line">    <span class="type">int</span>    h;      </span><br><span class="line">&#125; rec;</span><br></pre></td></tr></table></figure>
<p>A. 这个结构中所以的字段的字节偏移量是多少？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
<th>g</th>
<th>h</th>
</tr>
</thead>
<tbody>
<tr>
<td>大小</td>
<td>8</td>
<td>2</td>
<td>8</td>
<td>1</td>
<td>4</td>
<td>1</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>偏移量</td>
<td>0</td>
<td>8</td>
<td>16</td>
<td>24</td>
<td>28</td>
<td>32</td>
<td>40</td>
<td>48</td>
</tr>
</tbody>
</table>
</div>
<p>B. 这个结构总的大小是多少？</p>
<p>总共 56 个字节长。</p>
<p>C. 重新排列这个结构中的字段，以最小化浪费的空间，然后再给出重排过的结构的字节偏移量和总的大小。</p>
<p>当所有的数据元素的长度都是 2 的幂时，一种行之有效的策略是按照大小的降序排列结构的元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>   *a;</span><br><span class="line">    <span class="type">double</span>  c; </span><br><span class="line">    <span class="type">long</span>    g;</span><br><span class="line">    <span class="type">float</span>   e;</span><br><span class="line">    <span class="type">int</span>     h;</span><br><span class="line">    <span class="type">short</span>   b;</span><br><span class="line">    <span class="type">char</span>    d;</span><br><span class="line">    <span class="type">char</span>    f;</span><br><span class="line">&#125; rec;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>得到的偏离量如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>a</th>
<th>c</th>
<th>g</th>
<th>e</th>
<th>h</th>
<th>b</th>
<th>d</th>
<th>f</th>
</tr>
</thead>
<tbody>
<tr>
<td>大小</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>4</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>偏移量</td>
<td>0</td>
<td>8</td>
<td>16</td>
<td>24</td>
<td>28</td>
<td>32</td>
<td>34</td>
<td>35</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>这个结构要填充 4 个字节以满足 8 字节对齐的要求，所以总共是 40 个字节。</p>
</blockquote>
<h2 id="练习题-3-47"><a href="#练习题-3-47" class="headerlink" title="练习题 3.47"></a>练习题 3.47</h2><p>在运行 Linux 版本 2.6.16 的机器上运行栈检查代码 10 000 次，我们获得地址的范围从最小的 <code>0xffffb754</code> 到最大的 <code>0xffffd754</code> 。</p>
<p>A. 地址的大概范围是多大？</p>
<p><code>0xffffd754 - 0xffffd754 = 0x00002000</code> 大约 $2^{13}$ 个地址的范围。</p>
<p>B. 如果我们尝试一个有 128 字节 nop sled 的缓冲区溢出，要想穷尽所有的起始地址，需要尝试多少次？</p>
<p>$2^7$ 为 128，$2^{13}÷2^7=2^6$ ，需要 64 次尝试。</p>
<h2 id="练习题3-49"><a href="#练习题3-49" class="headerlink" title="练习题3.49"></a>练习题3.49</h2><p>在这道题中，我们要探究图3-43b第5～11行代码背后的逻辑，它分配了变长大小的数组p。正如代码的注释表明的，$s_1$表示执行第4行的 subq指令之后栈指针的地址。这条指令为局部变量i分配空间。$s_2$表示执行第4行的subq 指令之后栈指针的值。这条指令为局部数组p 分配存储。最后，p表示第10～11行的指令赋给寄存器%r8和%rcx的值。这两个寄存器都用来引用数组p。</p>
<p>图3-44的右边画出了$s_1$、$s_2$和p指示的位置。图中还画出了$s_2$和p的值之间可能有一个偏移量为$e_2$字节的位置，该空间是未被使用的。数组p的结尾和s指示的位置之间还可能有一个偏移量为$e_1$字节的地方。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221110194157270.png" alt="image-20221110194157270"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/3-43b" alt="3-43b"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221110194231170.png" alt="image-20221110194231170"></p>
<p><strong>A.用数学语言解释第5～7行中计算s2的逻辑。提示:想想—16的位级表示以及它在第6行andq指令中的作用。</strong></p>
<p>第5行的leaq指令计算值8n＋22，然后第6行的andq指令把它向下舍入到最接近的16的倍数。当n是奇数时，结果值会是8n+8，当n是偶数时，结果值会是8n+16，这个值减去$s_1$就得到$s_2$。</p>
<p><strong>解释：</strong></p>
<p>第5行汇编得到8n+22。</p>
<p>第6行8n+22与立即数-16进行与运算。按照最高位为符号位来说，-16的二进制为<code>1 0000</code>，因为符号拓展值不变，所以-16的8字节表示为<code>.... 1111 0000</code>，省略号全为1。所以第6行是要将8n+22与<code>.... 1111 0000</code>进行与运算，这会导致8n+22的低4位如果谁有1都会被舍弃掉，原文描述为：“把它向下舍入到最接近的16的倍数”，因为是舍弃低4位所以是“向下舍入”。按照本人描述为：舍弃掉权值为8,4,2,1的二进制位，只留下权值大于等于8的二进制位。</p>
<p>所以，与$-16进行与运算后，结果将会是16的倍数。倍数可能是0,1…</p>
<p>当n为偶数时，将8n+22拆分为8n和22。既然n为偶数，则8n为16的倍数，那么<code>8n and $-16 = 8n</code>。<code>22 and $-16 = 16</code>。将两个结果加起来就是<code>8n + 16</code>。<br>当n为奇数时，将8n+22拆分为8(n-1)和30。既然n-1为偶数，则8(n-1)为16的倍数，那么<code>8(n-1) and $-16 = 8(n-1)</code>。<code>30 and $-16 = 16</code>。将两个结果加起来就是8n + 8.</p>
<p>还有就是这个22，其实可以替换为16-23中一个数都可以，把这个数称为m，那么要求m或者m+8在和与<code>$-16</code>进行与运算后，结果必须为16，从这个要求就可以得出这个范围。</p>
<p><strong>B.用数学语言解释第8～10行中计算p的逻辑。提示:可以参考2.3.7节中有关除以2的幂的讨论。</strong></p>
<p>该序列中的三条指令将s2舍入到最近的8的倍数。它们利用了2.3.7节中实现除以⒉的幂用到的偏移和移位的组合。</p>
<p><strong>解释：</strong></p>
<p>在第8行，将%rsp加上7即$2^3-1$，假设%rsp栈指针为x，在第9行右移3位，这里将产生$⌈x/2^3⌉$即$⌈x/8⌉$。<br>第10行乘以8，相当于左移3位。可以想象，当%rsp刚好是8的倍数时，执行完8-10行，不变，因为向上取整时为本身。当%rsp不是8的倍数时，执行完8-10行，为%rsp+8，因为向上取整时加1了。</p>
<p>换个角度，7的二进制为111，当%rsp的低三位是000时，加上111不会使得第4位加1；当%rsp的低三位不是000而是其他情况时，加上111肯定使得第4位加1。然后第9,10行的操作是先右移3位，再左移3位，这就相当于把低3位的二进制值清0。</p>
<p>总结一下：要么%rsp不变，要么%rsp向上舍入到最接近8的倍数。</p>
<p><strong>C.对于下面n和$s_1$的值，跟踪代码的执行，确定$s_2$、$p$、$e_1$和$e_2$的结果值。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>n</th>
<th>$s_1$</th>
<th>$s_2$</th>
<th>$p$</th>
<th>$e_1$</th>
<th>$e_2$</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>2065</td>
<td>2017</td>
<td>2024</td>
<td>1</td>
<td>7</td>
</tr>
<tr>
<td>6</td>
<td>2064</td>
<td>2000</td>
<td>2000</td>
<td>16</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>解释：</strong></p>
<p>在第7行汇编分配栈空间时，是将$e_1$和$e_2$和数组的空间一起考虑的了。</p>
<p>当第10行汇编执行，才会确定了$e_1$和$e_2$的大小。因为只有这个时候才知道了数组空间的开始地址和结束地址。注意这个图里面，$e_1$和$e_2$不一定都是8个字节。</p>
<p>当$s_1$为刚好为8的倍数时,$e_1$和$e_2$就没什么用了，起码不需要它俩来8K对齐了，因为本来就是8K对齐的。</p>
<p>当$s_1$不是8的倍数时，$e_1$和$e_2$可以用来保证数组每个元素8K对齐。</p>
<p><strong>D.这段代码为$s_2$和p的值提供了什么样的对齐属性?</strong></p>
<p>可以看到$s_2$的计算方式会保留$s_1$的偏移量为最接近的16的倍数。还可以看到p会以8的倍数对齐，正是对8字节元素数组建议使用的。</p>
<h2 id="练习题-3-50"><a href="#练习题-3-50" class="headerlink" title="练习题 3.50"></a>练习题 3.50</h2><p>对于下面的 C 代码，表达式 <code>val1</code> ~ <code>val4</code> 分别对应程序值 i、f、d 和 l：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">fcvt2</span><span class="params">(<span class="type">int</span> *ip, <span class="type">float</span> *fp, <span class="type">double</span> *dp, <span class="type">long</span> l)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = *ip;</span><br><span class="line">    <span class="type">float</span> f = *fp;</span><br><span class="line">    <span class="type">double</span> d = *dp;</span><br><span class="line">    *ip = (<span class="type">int</span>)     val1;</span><br><span class="line">    *fp = (<span class="type">float</span>)   val2;</span><br><span class="line">    *dp = (<span class="type">double</span>)  val3;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>) val4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据该函数如下的 x86-64 代码，确定这个映射关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># double fcvt2(int *ip, float *fp, double *dp, long l)</span><br><span class="line"># ip in %rdi, fp in %rsi, dp in %rdx, l in %rcx</span><br><span class="line"># Result returned in %xmm0</span><br><span class="line"></span><br><span class="line">fcvt2:</span><br><span class="line">    movl        (%rdi), %eax        # 把 ip 的值放入 %eax</span><br><span class="line">    vmovss      (%rsi), %xmm0       # 传送单精度数, 把 fp 放入 %xmm0</span><br><span class="line">    vcvttsd2si  (%rdx), %r8d        # 双精度转 32 位整数，dp 放入 %r8d</span><br><span class="line">    movl        %r8d, (%rdi)        # 转换后写入 ip 对应的内存位置</span><br><span class="line">    vcvtsi2ss   %eax, %xmm1, %xmm1  # 32 位整数转单精度浮点数</span><br><span class="line">    vmovss      %xmm1, (%rsi)       # 转换后写入 fp 对应的地址</span><br><span class="line">    vcvtsi2sdq  %rcx, %xmm1, %xmm1  # 64 位整数转为双精度浮点</span><br><span class="line">    vmovsd      %xmm1, (%rdx)       # 转换后写入到 dp 对应的地址</span><br><span class="line">    vunpcklps   %xmm0, %xmm0, %xmm0 # 单精度转换为双精度</span><br><span class="line">    vcvtps2pd   %xmm0, %xmm0        </span><br><span class="line">    ret                             </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>取出位于 dp 的值，转换成 int，再存储到 ip。因此推断出 <code>val1</code> 是 d。</li>
<li>取出位于 ip 的值，转换成 float，再存储到 fp。因此推断出 <code>val2</code> 是 i。</li>
<li>l 的值转换成 double，并存储在 dp。因此推断出 <code>val3</code> 是 l。</li>
<li>fp 的值被转换成双精度，值通过寄存器 <code>%xmm0</code> 返回。因此推断出 <code>val4</code> 是 f。</li>
</ul>
<h2 id="练习题-3-51"><a href="#练习题-3-51" class="headerlink" title="练习题 3.51"></a>练习题 3.51</h2><p>下面的 C 函数将类型为 <code>src_t</code> 的参数转换为类型为 <code>dst_t</code> 的返回值，这里两种参数类型都用 <code>typedef</code> 定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dest_t</span> <span class="title function_">cvt</span><span class="params">(<span class="type">src_t</span> x)</span>&#123;</span><br><span class="line">    <span class="type">dest_t</span> y = (<span class="type">dest_t</span>) x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 x86-64 上执行这段代码，假设参数 x 在 <code>%xmm0</code> 中，或者在寄存器 <code>%rdi</code> 的某个适当的命名中（即 <code>%rdi</code> 或 <code>%edi</code>）。用一条或两条指令来完成类型转换，并把结果值复制到寄存器 <code>%rax</code> 的某个适当命令部分中（整数结果），或 <code>%xmm0</code> 中（浮点结果）。给出这条或这些指令，包括源和目的寄存器。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Tx</th>
<th>Ty</th>
<th>指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>long</td>
<td>double</td>
<td><code>vcvtsi2sdq %rdi, %xmm0</code></td>
</tr>
<tr>
<td>double</td>
<td>int</td>
<td><code>vcvvttsd2si %xmm0, %eax</code></td>
</tr>
<tr>
<td>double</td>
<td>float</td>
<td><code>vunpcklpd %xmm0, %xmm0, %xmm0 vcvtpd2ps %xmm0, %xmm0</code></td>
</tr>
<tr>
<td>long</td>
<td>float</td>
<td><code>vcvtsi2ssq %rdi, %xmm0, %xmm0</code></td>
</tr>
<tr>
<td>float</td>
<td>long</td>
<td><code>vcvttss2siq %xmm0, %rax</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-52"><a href="#练习题-3-52" class="headerlink" title="练习题 3.52"></a>练习题 3.52</h2><p>对于下面每个函数声明，确定参数的寄存器分配：</p>
<p>A. <code>double g1(double a, long b, float c, int d);</code></p>
<p>a 在 <code>%xmm0</code> ，b 在 <code>%rdi</code> 中，c 在 <code>%xmm1</code> 中，d 在 <code>%esi</code> 中。</p>
<p>B. <code>double g2(int a, double *b, float *c, long d);</code></p>
<p>a 在 <code>%edi</code> 中，b 在 <code>%rsi</code> 中，c 在 <code>%rdx</code> 中，d 在 <code>%rcx</code> 中。</p>
<p>C. <code>double g3(double *a, double b, int c, float d);</code></p>
<p>a 在 <code>%rdi</code> 中，b 在 <code>%xmm0</code> 中，c 在 <code>%esi</code> 中，d 在 <code>%xmm1</code> 中。</p>
<p>D. <code>double g4(float a, int *b, float c, double d);</code></p>
<p>a 在 <code>%xmm0</code> 中，b 在 <code>%rdi</code> 中，c 在 <code>%xmm1</code> 中，d 在 <code>%xmm2</code> 中。</p>
<h2 id="练习题-3-53"><a href="#练习题-3-53" class="headerlink" title="练习题 3.53"></a>练习题 3.53</h2><p>对于下面的 C 函数，4 个参数的类型由 <code>typedef</code> 定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">funct1</span><span class="params">(<span class="type">art1_t</span> p, <span class="type">arg2_t</span> q, <span class="type">arg3_t</span> r, <span class="type">arg4_t</span> s)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p/(q+r) - s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时，GCC 产生如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Assembly</span><br><span class="line"># double funct1(art1_t p, arg2_t q, arg3_t r, arg4_t s)</span><br><span class="line"># Refer to arguments as i1(%rdi), i2(%esi), f1(%xmm0), and f2(%xmm1)</span><br><span class="line"></span><br><span class="line">funct1:</span><br><span class="line">    vcvtsi2ssq      %rsi, %xmm2, %xmm2      # Get i2 and convert from long to float</span><br><span class="line">    vaddss          %xmm0, %xmm2, %xmm0     # Add f1 (type float)</span><br><span class="line">    vcvtsi2ss       %edi, %xmm2, %xmm2      # Get i1 and convert from int to float</span><br><span class="line">    vdivss          %xmm0, %xmm2, %xmm0     # Compute i1 / (i2 + f1)</span><br><span class="line">    vunpcklps       %xmm0, %xmm0, %xmm0</span><br><span class="line">    vcvtps2pd       %xmm0, %xmm0            # Convert to double</span><br><span class="line">    vsubsd          %xmm1, %xmm0, %xmm0     # Compute i1 / (i2 + f1) - f2(double)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>确定 4 个参数类型的可能组合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">funct1a</span><span class="params">(<span class="type">int</span> p, <span class="type">float</span> q, <span class="type">long</span> r, <span class="type">double</span> s)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">funct1b</span><span class="params">(<span class="type">int</span> p, <span class="type">long</span> q, <span class="type">float</span> r, <span class="type">double</span> s)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-54-函数-func2-具有如下原型："><a href="#练习题-3-54-函数-func2-具有如下原型：" class="headerlink" title="练习题 3.54 函数 func2 具有如下原型："></a>练习题 3.54 函数 <code>func2</code> 具有如下原型：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">funct2</span><span class="params">(<span class="type">double</span> w, <span class="type">int</span> x, <span class="type">float</span> y, <span class="type">long</span> z)</span>;</span><br></pre></td></tr></table></figure>
<p>GCC 为该函数产生如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Assembly</span><br><span class="line"># double funct2(double w, int x, float y,long z)</span><br><span class="line"># w in %xmm0, x in %edi, y in %xmm1, z in %rsi</span><br><span class="line"></span><br><span class="line">funct2:</span><br><span class="line">    vcvtsi2ss       %edi, %xmm2, %xmm2      # Convert x to float</span><br><span class="line">    vmulss          %xmm1, %xmm2, %xmm1     # Multiply by y</span><br><span class="line">    vunpcklps       %xmm1, %xmm1, %xmm1</span><br><span class="line">    vcvtps2pd       %xmm1, %xmm2            # Convert x*y to double</span><br><span class="line">    vcvtsi2sdq      %rsi, %xmm1, %xmm1      # Convert z to double</span><br><span class="line">    vdivsd          %xmm1, %xmm0, %xmm0     # Compute w/z</span><br><span class="line">    vsudsd          %xmm0, %xmm2, %xmm0     # Subtract from x*y</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>写出 <code>funct2</code> 的 C 语言版本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">funct2</span><span class="params">(<span class="type">double</span> w, <span class="type">int</span> x, <span class="type">float</span> y,<span class="type">long</span> z)</span>&#123;</span><br><span class="line">    <span class="type">float</span> temp = (<span class="type">float</span>) x;</span><br><span class="line">    y = y * temp;</span><br><span class="line">    <span class="type">double</span> temp2 = (<span class="type">double</span>) y;</span><br><span class="line">    <span class="type">double</span> temp3 = (<span class="type">double</span>) z;</span><br><span class="line">    w = w / temp3;</span><br><span class="line">    <span class="keyword">return</span> y - w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">funct2</span><span class="params">(<span class="type">double</span> w, <span class="type">int</span> x, <span class="type">float</span> y,<span class="type">long</span> z)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y * x - w / z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC2%E7%AB%A0/" rel="tag"><i class="fa fa-tag"></i> 深入理解计算机系统第2章</a>
              <a href="/tags/CSAPP/" rel="tag"><i class="fa fa-tag"></i> CSAPP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC2%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/" rel="prev" title="深入理解计算机系统第2章练习题">
      <i class="fa fa-chevron-left"></i> 深入理解计算机系统第2章练习题
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/26/%E5%85%B6%E4%BB%96/%E7%94%B5%E8%84%91%E6%8E%A8%E8%8D%90%E8%BD%AF%E4%BB%B6/" rel="next" title="电脑推荐软件">
      电脑推荐软件 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">深入理解计算机系统第3章练习题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%983-1%E5%81%87%E8%AE%BE%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%80%BC%E5%AD%98%E6%94%BE%E5%9C%A8%E6%8C%87%E6%98%8E%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD"><span class="nav-number">1.1.</span> <span class="nav-text">练习题3.1假设下面的值存放在指明的内存地址和寄存器中:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%983-2%E5%AF%B9%E4%BA%8E%E4%B8%8B%E9%9D%A2%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%9A%84%E6%AF%8F%E4%B8%80%E8%A1%8C%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%8C%E7%A1%AE%E5%AE%9A%E9%80%82%E5%BD%93%E7%9A%84%E6%8C%87%E4%BB%A4%E5%90%8E%E7%BC%80%E3%80%82-%E4%BE%8B%E5%A6%82%EF%BC%8Cmov-%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%E6%88%90movb%E3%80%81movw%E3%80%81movl%E6%88%96%E8%80%85movq%E3%80%82%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">练习题3.2对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。(例如，mov 可以被重写成movb、movw、movl或者movq。）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%983-3%E5%BD%93%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8%E6%B1%87%E7%BC%96%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E6%AF%8F%E4%B8%80%E8%A1%8C%E9%83%BD%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E3%80%82%E8%A7%A3%E9%87%8A%E6%AF%8F%E4%B8%80%E8%A1%8C%E9%83%BD%E6%98%AF%E5%93%AA%E9%87%8C%E5%87%BA%E4%BA%86%E9%94%99%E3%80%82"><span class="nav-number">1.3.</span> <span class="nav-text">练习题3.3当我们调用汇编器的时候，下面代码的每一行都会产生一个错误消息。解释每一行都是哪里出了错。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%983-4%E5%81%87%E8%AE%BE%E5%8F%98%E9%87%8Fsp%E5%92%8Cdp%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.</span> <span class="nav-text">练习题3.4假设变量sp和dp被声明为类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%983-5%E5%B7%B2%E7%9F%A5%E4%BF%A1%E6%81%AF%E5%A6%82%E4%B8%8B%E3%80%82%E5%B0%86%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%9E%8B%E4%B8%BA"><span class="nav-number">1.5.</span> <span class="nav-text">练习题3.5已知信息如下。将一个原型为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%983-6-%E5%81%87%E8%AE%BE%E5%AF%84%E5%AD%98%E5%99%A8-rax-%E7%9A%84%E5%80%BC%E4%B8%BA-x%EF%BC%8C-rcx-%E7%9A%84%E5%80%BC%E4%B8%BA-y%E3%80%82%E5%A1%AB%E5%86%99%E4%B8%8B%E8%A1%A8%EF%BC%8C%E6%8C%87%E6%98%8E%E4%B8%8B%E9%9D%A2%E6%AF%8F%E6%9D%A1%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%8C%87%E4%BB%A4%E5%AD%98%E5%82%A8%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8-rdx-%E4%B8%AD%E7%9A%84%E5%80%BC%EF%BC%9A"><span class="nav-number">1.6.</span> <span class="nav-text">练习题3.6 假设寄存器 %rax 的值为 x，%rcx 的值为 y。填写下表，指明下面每条汇编代码指令存储在寄存器 %rdx 中的值：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%983-7%E8%80%83%E8%99%91%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%88%91%E4%BB%AC%E7%9C%81%E7%95%A5%E4%BA%86%E8%A2%AB%E8%AE%A1%E7%AE%97%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A"><span class="nav-number">1.7.</span> <span class="nav-text">练习题3.7考虑下面的代码，我们省略了被计算的表达式：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-8-%E5%81%87%E8%AE%BE%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%80%BC%E5%AD%98%E6%94%BE%E6%8C%87%E5%AE%9A%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%EF%BC%9A"><span class="nav-number">1.8.</span> <span class="nav-text">练习题 3.8 假设下面的值存放指定的内存地址和寄存器中：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-9%E8%AE%BE%E6%88%91%E4%BB%AC%E6%83%B3%E7%94%9F%E6%88%90%E4%BB%A5%E4%B8%8B-C-%E5%87%BD%E6%95%B0%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.9.</span> <span class="nav-text">练习题 3.9设我们想生成以下 C 函数的汇编代码：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-10-%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%87%BD%E6%95%B0%E6%98%AF%E5%9B%BE3-11a%E4%B8%AD%E5%87%BD%E6%95%B0%E4%B8%80%E4%B8%AA%E5%8F%98%E7%A7%8D%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%89%E4%BA%9B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E7%A9%BA%E6%A0%BC%E6%9B%BF%E4%BB%A3"><span class="nav-number">1.10.</span> <span class="nav-text">练习题 3.10 下面的函数是图3-11a中函数一个变种，其中有些表达式用空格替代:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-11%E5%B8%B8%E5%B8%B8%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%A7%81%E4%BB%A5%E4%B8%8B%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E8%A1%8C%EF%BC%9A"><span class="nav-number">1.11.</span> <span class="nav-text">练习题 3.11常常可以看见以下形式的汇编代码行：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-12-%E8%80%83%E8%99%91%E5%A6%82%E4%B8%8B%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AE%83%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%97%A0%E7%AC%A6%E5%8F%B7-64-%E4%BD%8D%E6%95%B0%E7%9A%84%E5%95%86%E5%92%8C%E4%BD%99%E6%95%B0%EF%BC%9A"><span class="nav-number">1.12.</span> <span class="nav-text">练习题 3.12 考虑如下函数，它计算两个无符号 64 位数的商和余数：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-13-%E8%99%91%E4%B8%8B%E5%88%97%E7%9A%84-C-%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.13.</span> <span class="nav-text">练习题 3.13 虑下列的 C 语言代码：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-14-%E8%80%83%E8%99%91%E4%B8%8B%E9%9D%A2%E7%9A%84-C-%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.14.</span> <span class="nav-text">练习题 3.14 考虑下面的 C 语言代码：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-15%E5%9C%A8%E4%B8%8B%E9%9D%A2%E8%BF%99%E4%BA%9B%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BB%A3%E7%A0%81%E8%8A%82%E9%80%89%E4%B8%AD%EF%BC%8C%E6%9C%89%E4%BA%9B%E4%BF%A1%E6%81%AF%E8%A2%AB-X-%E4%BB%A3%E6%9B%BF%E4%BA%86%E3%80%82%E5%9B%9E%E7%AD%94%E4%B8%8B%E5%88%97%E5%85%B3%E4%BA%8E%E8%BF%99%E4%BA%9B%E6%8C%87%E4%BB%A4%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82"><span class="nav-number">1.15.</span> <span class="nav-text">练习题 3.15在下面这些反汇编二进制代码节选中，有些信息被 X 代替了。回答下列关于这些指令的问题。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-16%E5%B7%B2%E7%9F%A5%E4%B8%8B%E5%88%97-C-%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.16.</span> <span class="nav-text">练习题 3.16已知下列 C 代码：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-17%E5%B0%86-if-%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E6%88%90-goto-%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%A1%8C%E7%9A%84%E8%A7%84%E5%88%99%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">1.17.</span> <span class="nav-text">练习题 3.17将 if 语句翻译成 goto 代码的另一种可行的规则如下：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-18%E4%BB%8E%E5%A6%82%E4%B8%8B%E5%BD%A2%E5%BC%8F%E7%9A%84-C-%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E5%BC%80%E5%A7%8B%EF%BC%9A"><span class="nav-number">1.18.</span> <span class="nav-text">练习题 3.18从如下形式的 C 语言代码开始：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-20-%E4%B8%8B%E9%9D%A2%E7%9A%84-C-%E5%87%BD%E6%95%B0%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%AF%B9-OP-%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E6%98%AF%E4%B8%8D%E5%AE%8C%E6%95%B4%E7%9A%84%EF%BC%9A%E4%B8%8B%E9%9D%A2%E7%9A%84-C-%E5%87%BD%E6%95%B0%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%AF%B9-OP-%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E6%98%AF%E4%B8%8D%E5%AE%8C%E6%95%B4%E7%9A%84%EF%BC%9A%E4%B8%8B%E9%9D%A2%E7%9A%84-C-%E5%87%BD%E6%95%B0%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%AF%B9-OP-%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E6%98%AF%E4%B8%8D%E5%AE%8C%E6%95%B4%E7%9A%84%EF%BC%9A"><span class="nav-number">1.19.</span> <span class="nav-text">练习题 3.20 下面的 C 函数中，我们对 OP 操作的定义是不完整的：下面的 C 函数中，我们对 OP 操作的定义是不完整的：下面的 C 函数中，我们对 OP 操作的定义是不完整的：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-21-C-%E4%BB%A3%E7%A0%81%E5%BC%80%E5%A7%8B%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">1.20.</span> <span class="nav-text">练习题 3.21 C 代码开始的形式如下：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-22"><span class="nav-number">1.21.</span> <span class="nav-text">练习题 3.22</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-23-%E5%B7%B2%E7%9F%A5-C-%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">1.22.</span> <span class="nav-text">练习题 3.23 已知 C 代码如下：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-24%E5%AF%B9%E4%BA%8E%E5%A6%82%E4%B8%8B-C-%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.23.</span> <span class="nav-text">练习题 3.24对于如下 C 代码：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-25%E5%AF%B9%E4%BA%8E%E5%A6%82%E4%B8%8B-C-%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.24.</span> <span class="nav-text">练习题 3.25对于如下 C 代码：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-26-%E5%87%BD%E6%95%B0-fun-a-%E6%9C%89%E5%A6%82%E4%B8%8B%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="nav-number">1.25.</span> <span class="nav-text">练习题 3.26 函数 fun_a 有如下整体结构：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-27"><span class="nav-number">1.26.</span> <span class="nav-text">练习题 3.27</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-28%E5%87%BD%E6%95%B0-fun-b-%E6%9C%89%E5%A6%82%E4%B8%8B%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="nav-number">1.27.</span> <span class="nav-text">练习题 3.28函数 fun_b 有如下整体结构：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-29"><span class="nav-number">1.28.</span> <span class="nav-text">练习题 3.29</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-30%E4%B8%8B%E9%9D%A2%E7%9A%84-C-%E5%87%BD%E6%95%B0%E7%9C%81%E7%95%A5%E4%BA%86-switch-%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%B8%BB%E4%BD%93%E3%80%82%E5%9C%A8-C-%E4%BB%A3%E7%A0%81%E4%B8%AD%EF%BC%8C%E6%83%85%E5%86%B5%E6%A0%87%E5%8F%B7%E6%98%AF%E4%B8%8D%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%8C%E8%80%8C%E6%9C%89%E4%BA%9B%E6%83%85%E5%86%B5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%A0%87%E5%8F%B7%E3%80%82"><span class="nav-number">1.29.</span> <span class="nav-text">练习题 3.30下面的 C 函数省略了 switch 语句的主体。在 C 代码中，情况标号是不连续的，而有些情况有多个标号。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-31"><span class="nav-number">1.30.</span> <span class="nav-text">练习题 3.31</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-32"><span class="nav-number">1.31.</span> <span class="nav-text">练习题 3.32</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-33"><span class="nav-number">1.32.</span> <span class="nav-text">练习题 3.33</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-34"><span class="nav-number">1.33.</span> <span class="nav-text">练习题 3.34</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-35-%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E9%80%9A%E7%94%A8%E7%BB%93%E6%9E%84%E7%9A%84-C-%E5%87%BD%E6%95%B0%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">1.34.</span> <span class="nav-text">练习题 3.35 一个具有通用结构的 C 函数如下：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-36"><span class="nav-number">1.35.</span> <span class="nav-text">练习题 3.36</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-37"><span class="nav-number">1.36.</span> <span class="nav-text">练习题 3.37</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-38"><span class="nav-number">1.37.</span> <span class="nav-text">练习题 3.38</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%983-39"><span class="nav-number">1.38.</span> <span class="nav-text">练习题3.39</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-41%E8%80%83%E8%99%91%E4%B8%8B%E9%9D%A2%E7%9A%84%E7%BB%93%E6%9E%84%E5%A3%B0%E6%98%8E%EF%BC%9A"><span class="nav-number">1.39.</span> <span class="nav-text">练习题 3.41考虑下面的结构声明：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-42%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%99%E5%87%BA%E4%BA%86%E7%B1%BB%E5%9E%8B-ELE-%E7%9A%84%E7%BB%93%E6%9E%84%E5%A3%B0%E6%98%8E%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0-fun-%E7%9A%84%E5%8E%9F%E5%9E%8B%EF%BC%9A"><span class="nav-number">1.40.</span> <span class="nav-text">练习题 3.42下面的代码给出了类型 ELE 的结构声明以及函数 fun 的原型：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98-3-43"><span class="nav-number">1.41.</span> <span class="nav-text">习题 3.43</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-44-%E5%AF%B9%E4%B8%8B%E9%9D%A2%E6%AF%8F%E4%B8%AA%E7%BB%93%E6%9E%84%E5%A3%B0%E6%98%8E%EF%BC%8C%E7%A1%AE%E5%AE%9A%E6%AF%8F%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%8C%E7%BB%93%E6%9E%84%E6%80%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%9C%A8-x86-64-%E4%B8%8B%E5%AE%83%E7%9A%84%E5%AF%B9%E9%BD%90%E8%A6%81%E6%B1%82%EF%BC%9A"><span class="nav-number">1.42.</span> <span class="nav-text">练习题 3.44 对下面每个结构声明，确定每个字段的偏移量，结构总的大小，以及在 x86-64 下它的对齐要求：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-45"><span class="nav-number">1.43.</span> <span class="nav-text">练习题 3.45</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-47"><span class="nav-number">1.44.</span> <span class="nav-text">练习题 3.47</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%983-49"><span class="nav-number">1.45.</span> <span class="nav-text">练习题3.49</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-50"><span class="nav-number">1.46.</span> <span class="nav-text">练习题 3.50</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-51"><span class="nav-number">1.47.</span> <span class="nav-text">练习题 3.51</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-52"><span class="nav-number">1.48.</span> <span class="nav-text">练习题 3.52</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-53"><span class="nav-number">1.49.</span> <span class="nav-text">练习题 3.53</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-3-54-%E5%87%BD%E6%95%B0-func2-%E5%85%B7%E6%9C%89%E5%A6%82%E4%B8%8B%E5%8E%9F%E5%9E%8B%EF%BC%9A"><span class="nav-number">1.50.</span> <span class="nav-text">练习题 3.54 函数 func2 具有如下原型：</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bugCat"
      src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/avatar/zhouning.png">
  <p class="site-author-name" itemprop="name">bugCat</p>
  <div class="site-description" itemprop="description">啥都不会</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bugcat9" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bugcat9" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1767508581@qq.com" title="E-Mail → mailto:1767508581@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bugCat</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">493k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:28</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '5181a7c6b299b2f49124',
      clientSecret: '840df9eaf797888f8029b5a03aca0f28fe042bcf',
      repo        : 'bugcat9.github.io',
      owner       : 'bugcat9',
      admin       : ['bugcat9'],
      id          : '96b449f86ae7b763744dae0d3c4f6e40',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
  

  <script async src="/js/cursor/fireworks.js"></script>




  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>

</body>
</html>
