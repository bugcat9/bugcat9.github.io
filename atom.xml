<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bugCat&#39;s Blog</title>
  
  <subtitle>毛的感情的程序猿</subtitle>
  <link href="https://bugcat.top/atom.xml" rel="self"/>
  
  <link href="https://bugcat.top/"/>
  <updated>2024-10-20T13:34:26.724Z</updated>
  <id>https://bugcat.top/</id>
  
  <author>
    <name>bugCat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>push_back和emplace_back</title>
    <link href="https://bugcat.top/2024/10/20/C++/push-back%E5%92%8Cemplace-back/"/>
    <id>https://bugcat.top/2024/10/20/C++/push-back%E5%92%8Cemplace-back/</id>
    <published>2024-10-20T19:29:25.000Z</published>
    <updated>2024-10-20T13:34:26.724Z</updated>
    
    <content type="html"><![CDATA[<p>modern C++中提到使用考虑使用置入代替插入，个人理解就是使用考虑使用<code>emplace_back</code>代替<code>push_back</code>操作，那么这两者之间究竟有什么区别，想探究一下<br><span id="more"></span><br>首先这两个函数的定义是不一样的</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p><code>push_back</code>是有两个函数的（重载），一个接受左值一个接受右值，并且接受右值后进行了<code>move</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_CONSTEXPR20 <span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> _Ty&amp; _Val)</span> </span>&#123; <span class="comment">// insert element at end, provide strong guarantee</span></span><br><span class="line">    _Emplace_one_at_back(_Val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">_CONSTEXPR20 <span class="type">void</span> <span class="title">push_back</span><span class="params">(_Ty&amp;&amp; _Val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert by moving into element at end, provide strong guarantee</span></span><br><span class="line">    _Emplace_one_at_back(_STD <span class="built_in">move</span>(_Val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>emplace_back</code>是只有一个函数，是一个模板函数，参数是一个通用引用并且是变长参数，然后进行了完美转发<code>forward</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Valty&gt;</span><br><span class="line">    <span class="function">_CONSTEXPR20 <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">emplace_back</span><span class="params">(_Valty&amp;&amp;... _Val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// insert by perfectly forwarding into element at end, provide strong guarantee</span></span><br><span class="line">       <span class="comment">// 完美转发直接将参数传入内部</span></span><br><span class="line">        _Ty&amp; _Result = _Emplace_one_at_back(_STD forward&lt;_Valty&gt;(_Val)...);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _HAS_CXX17</span></span><br><span class="line">        <span class="keyword">return</span> _Result;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv</span></span></span><br><span class="line">        (<span class="type">void</span>) _Result;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _HAS_CXX17</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此外，<code>push_back</code>和<code>emplace_back</code>都使用了_Emplace_one_at_back进行插入</p><h2 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h2><h3 id="性能上"><a href="#性能上" class="headerlink" title="性能上"></a>性能上</h3><p>先说结论：</p><p><strong>理论上来说，<code>emplace_back</code>比<code>push_back</code>效率更高。emplace_back能够在<code>vector</code>内部构建元素，从而减少拷贝或者移动操作</strong></p><p>这句话怎么理解呢，举个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs;        <span class="comment">//std::string的容器</span></span><br><span class="line">vs.<span class="built_in">push_back</span>(<span class="string">&quot;xyzzy&quot;</span>);              <span class="comment">//添加字符串字面量</span></span><br></pre></td></tr></table></figure><p>通过上面的源码我们可以看到<code>push_back</code>接受的参数是一个<code>T</code>的元素，但是这里传入的是字面量，所以在这里会通过字面量创建出一个临时变量（隐式转换），等价于下面的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(<span class="string">&quot;xyzzy&quot;</span>)); <span class="comment">//创建临时std::string，把它传给push_back</span></span><br></pre></td></tr></table></figure><p>综上vs的<code>push_back</code>总共有三个操作</p><ol><li>一个<code>std::string</code>的临时对象从字面量“<code>xyzzy</code>”被创建。这个对象没有名字，我们可以称为<code>temp</code>。<code>temp</code>的构造是第一次<code>std::string</code>构造。因为是临时变量，所以<code>temp</code>是右值。</li><li><code>temp</code>被传递给<code>push_back</code>的右值重载函数，绑定到右值引用形参<code>_Val</code>。在<code>std::vector</code>的内存中一个<code>_Val</code>的副本被创建。这次构造——也是第二次构造——在<code>std::vector</code>内部真正创建一个对象。</li><li>在<code>push_back</code>返回之后，<code>temp</code>立刻被销毁，调用了一次<code>std::string</code>的析构函数。</li></ol><p>当我们使用<code>emplace_back</code>时，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="string">&quot;xyzzy&quot;</span>);           <span class="comment">//直接用“xyzzy”在vs内构造std::string</span></span><br></pre></td></tr></table></figure><p><code>emplace_back</code>使用完美转发将”xyzzy”传入了vector内部（就是前面<code>_Ty&amp; _Result = _Emplace_one_at_back(_STD forward&lt;_Valty&gt;(_Val)...);</code>），直接在内部的数组的末尾<strong>构建</strong>元素插入，减少了临时变量的产生，提高了效率。</p><h3 id="接受参数上"><a href="#接受参数上" class="headerlink" title="接受参数上"></a>接受参数上</h3><p><code>emplace_back</code>使用完美转发，因此只要你没有遇到完美转发的限制（完美转发也会失败，在这里不多讲解），就可以传递任何实参以及组合到<code>emplace_back</code>。</p><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>);           <span class="comment">//插入由50个“x”组成的一个std::string</span></span><br><span class="line">vs.<span class="built_in">push_back</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>);<span class="comment">// error</span></span><br><span class="line">vs.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>))  <span class="comment">// fine</span></span><br></pre></td></tr></table></figure><p>再比如下面这种情况，临时变量都不给你转化，只能用emplace_back传入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> a)</span> :m_a(a) &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;A&gt; aVec;</span><br><span class="line">aVec.<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">// error  </span></span><br><span class="line">aVec.<span class="built_in">emplace_back</span>(<span class="number">1</span>);<span class="comment">// fine</span></span><br></pre></td></tr></table></figure><p>所以写起来<code>emplace_back</code>肯定是更加舒服的，少写好多字母（理论上减少出错）。</p><h2 id="代码实验"><a href="#代码实验" class="headerlink" title="代码实验"></a>代码实验</h2><h3 id="实验一（emplace-back高效性）"><a href="#实验一（emplace-back高效性）" class="headerlink" title="实验一（emplace_back高效性）"></a>实验一（emplace_back高效性）</h3><p>使用push_back</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BaseClass</span>(<span class="type">const</span> std::string name) : <span class="built_in">name_</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BaseClass</span>(<span class="type">const</span> BaseClass&amp; b) :<span class="built_in">name_</span>(b.name_)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; copy constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BaseClass</span>(BaseClass&amp;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 此处只是演示，并未进行真正移动</span></span><br><span class="line">name_ = b.name_;</span><br><span class="line">b.name_ = b.name_ + <span class="string">&quot; have move&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; move constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">BaseClass</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;BaseClass&gt; bcVec;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------push_back :&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">bcVec.<span class="built_in">push_back</span>(<span class="built_in">BaseClass</span>(<span class="string">&quot;push_back_obj&quot;</span>));</span><br><span class="line">  <span class="comment">// push_back：</span></span><br><span class="line">  <span class="comment">//    (1) 调用 有参构造函数 BaseClass (const std::string name) 创建临时对象；</span></span><br><span class="line">  <span class="comment">//    (2）调用 移动构造函数 BaseClass(BaseClass&amp;&amp; b) 到vector中；</span></span><br><span class="line">  <span class="comment">//    (3) 调用     析构函数               销毁临时对象；</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------destruct:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//   (4) vector进行析构，调用析构函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果符合预期</p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/push_back_obj.png" alt=""></p><p>使用emplace_back</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;BaseClass&gt; bcVec;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------emplace_back :&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">bcVec.<span class="built_in">emplace_back</span>(<span class="string">&quot;emplace_back_obj&quot;</span>);</span><br><span class="line">    <span class="comment">// (1) 在vector中直接调用构造函数创建元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------destruct:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// (2) vector进行析构，调用析构函数 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/emplace_back_obj.png" alt=""></p><p>可以看得出来emplace_back少临时变量的<strong>构造、移动、销毁</strong>操作，效率要高一些</p><h3 id="实验二（两者都传入右值）"><a href="#实验二（两者都传入右值）" class="headerlink" title="实验二（两者都传入右值）"></a>实验二（两者都传入右值）</h3><p>如果传入右值，push_back 和 emplace_back效率相同，都会有临时变量产生的<strong>构造、移动、销毁</strong>操作。</p><p>push_back传入右值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------push_back rvalue:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">bcVec.<span class="built_in">push_back</span>(<span class="built_in">BaseClass</span>(<span class="string">&quot;push_back_rvalue&quot;</span>));</span><br><span class="line">  <span class="comment">// push_back：</span></span><br><span class="line">  <span class="comment">//    (1) 调用 有参构造函数 BaseClass (const std::string name) 创建临时对象；</span></span><br><span class="line">  <span class="comment">//    (2）调用 移动构造函数 BaseClass(BaseClass&amp;&amp; b) 到vector中；</span></span><br><span class="line">  <span class="comment">//    (3) 调用     析构函数               销毁临时对象；</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------destruct:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">//   (4) vector进行析构，调用析构函数 </span></span><br></pre></td></tr></table></figure><p>上面已经展示过了，这里就不多解释了。</p><p>emplace_back传入右值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;BaseClass&gt; bcVec;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------emplace_back rvalue:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">bcVec.<span class="built_in">emplace_back</span>(<span class="built_in">BaseClass</span>(<span class="string">&quot;emplace_back_rvalue&quot;</span>));</span><br><span class="line">  <span class="comment">//    (1) 调用 有参构造函数 BaseClass (const std::string name) 创建临时对象；</span></span><br><span class="line">  <span class="comment">//    (2）调用 移动构造函数 BaseClass(BaseClass&amp;&amp; b) 到vector中；</span></span><br><span class="line">  <span class="comment">//    (3) 调用     析构函数               销毁临时对象；</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------destruct:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">//   (4) vector进行析构，调用析构函数 </span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，可以看出效率没有提高</p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/emplace_back_rvalue.png" alt=""></p><h3 id="实验三（两者都传入左值）"><a href="#实验三（两者都传入左值）" class="headerlink" title="实验三（两者都传入左值）"></a>实验三（两者都传入左值）</h3><p>如果传入右值，push_back 和 emplace_back效率相同，两者都会调用拷贝构造函数</p><p>push_back传入左值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;BaseClass&gt; bcVec;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------push_back lvalue:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//  (1) 调用 有参构造函数 BaseClass (const std::string name) 创建obj对象；</span></span><br><span class="line"><span class="function">BaseClass <span class="title">obj</span><span class="params">(<span class="string">&quot;obj&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//  (2) 调用 拷贝构造函数；</span></span><br><span class="line">bcVec.<span class="built_in">push_back</span>(obj);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------destruct:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//  (3) obj被析构，调用BaseClass的析构函数</span></span><br><span class="line"><span class="comment">//  (4) vector被析构，其中的元素调用BaseClass的析构函数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/push_back_lvalue.png" alt=""></p><p>emplace_back传入左值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;BaseClass&gt; bcVec;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------emplace_back lvalue:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//  (1) 调用 有参构造函数 BaseClass (const std::string name) 创建obj对象；</span></span><br><span class="line"><span class="function">BaseClass <span class="title">obj</span><span class="params">(<span class="string">&quot;obj&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//  (2) 调用 拷贝构造函数；</span></span><br><span class="line">bcVec.<span class="built_in">emplace_back</span>(obj);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------destruct:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//  (3) obj被析构，调用BaseClass的析构函数</span></span><br><span class="line"><span class="comment">//  (4) vector被析构，其中的元素调用BaseClass的析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/emplace_back_lvalue.png" alt=""></p><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/183861524">C++姿势点: push_back和emplace_back</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;modern C++中提到使用考虑使用置入代替插入，个人理解就是使用考虑使用&lt;code&gt;emplace_back&lt;/code&gt;代替&lt;code&gt;push_back&lt;/code&gt;操作，那么这两者之间究竟有什么区别，想探究一下&lt;br&gt;</summary>
    
    
    
    <category term="C++" scheme="https://bugcat.top/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>forward</title>
    <link href="https://bugcat.top/2024/10/20/C++/forward/"/>
    <id>https://bugcat.top/2024/10/20/C++/forward/</id>
    <published>2024-10-20T19:25:56.000Z</published>
    <updated>2024-10-20T13:34:26.724Z</updated>
    
    <content type="html"><![CDATA[<p> C++中的<code>std::forward</code>函数是一个非常有用的工具，主要用于在泛型编程中完美转发（perfect forwarding）参数。在C++中，完美转发是指将函数模板中接收到的参数以<strong>原始形式（左值或右值）转发给另一个函数</strong>，保持参数的值类别（左值或右值）不变。<br><span id="more"></span><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                        <span class="comment">//C++14；仍然在std命名空间</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;T&gt;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设有一个函数f：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …                                   <span class="comment">//做些工作</span></span><br><span class="line">    <span class="built_in">someFunc</span>(std::forward&lt;T&gt;(fParam));  <span class="comment">//转发fParam到someFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="假设传入是左值"><a href="#假设传入是左值" class="headerlink" title="假设传入是左值"></a>假设传入是左值</h2><p>传入到<code>f</code>的实参是<code>Widget</code>的左值类型。<code>T</code>被推导为<code>Widget&amp;</code>，然后调用<code>std::forward</code>将实例化为<code>std::forward&lt;Widget&amp;&gt;</code>。<code>Widget&amp;</code>带入到上面的<code>std::forward</code>的实现中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;Widget&amp;&gt;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终forward转化为返回一个左值引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当左值实参被传入到函数模板<code>f</code>时，<code>std::forward</code>被实例化为接受和返回左值引用。内部的转换不做任何事，因为<code>param</code>的类型已经是<code>Widget&amp;</code>，所以转换没有影响。左值实参传入<code>std::forward</code>会返回左值引用。通过定义，左值引用就是左值，因此将左值传递给<code>std::forward</code>会返回左值，就像期待的那样</p><h2 id="假设传入是右值"><a href="#假设传入是右值" class="headerlink" title="假设传入是右值"></a>假设传入是右值</h2><p>传递给<code>f</code>的实参是一个<code>Widget</code>的右值。在这个例子中，<code>f</code>的类型参数<code>T</code>的推导类型就是<code>Widget</code>。<code>f</code>内部的<code>std::forward</code>调用因此为<code>std::forward&lt;Widget&gt;</code>，<code>std::forward</code>实现中把<code>T</code>换为<code>Widget</code>得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;Widget&gt;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终转化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从函数返回的右值引用可以被定义为右值</strong>，最终结果是，传递给<code>f</code>的右值参数将作为右值转发给<code>someFunc</code>，正是想要的结果。</p><p><strong>从函数返回的右值引用可以被定义为右值的理解</strong>：</p><p>如果不加forward，传入右值，fParam推导类型是Widget&amp;&amp;，最终直接传入someFunc，它是有名字（fParam）的，所以是一个左值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …                                   <span class="comment">//做些工作</span></span><br><span class="line">    <span class="built_in">someFunc</span>(fParam);  <span class="comment">//转发fParam到someFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加了forward后，forward返回一个Widget&amp;&amp;类型，返回是有个匿名变量，它是一个右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …                                   <span class="comment">//做些工作</span></span><br><span class="line">    <span class="built_in">someFunc</span>(std::forward&lt;T&gt;(fParam));  <span class="comment">//转发fParam到someFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; C++中的&lt;code&gt;std::forward&lt;/code&gt;函数是一个非常有用的工具，主要用于在泛型编程中完美转发（perfect forwarding）参数。在C++中，完美转发是指将函数模板中接收到的参数以&lt;strong&gt;原始形式（左值或右值）转发给另一个函数&lt;/strong&gt;，保持参数的值类别（左值或右值）不变。&lt;br&gt;</summary>
    
    
    
    <category term="C++" scheme="https://bugcat.top/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>move</title>
    <link href="https://bugcat.top/2024/10/20/C++/move/"/>
    <id>https://bugcat.top/2024/10/20/C++/move/</id>
    <published>2024-10-20T19:22:54.000Z</published>
    <updated>2024-10-20T13:34:26.724Z</updated>
    
    <content type="html"><![CDATA[<p><code>std::move</code>执行到右值的无条件的转换，但就自身而言，它不移动任何东西</p><p>内部的实现类似这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><ol><li><code>remove_reference&lt;T&gt;::type</code>对<code>T</code>去除引用</li><li><code>using ReturnType = typename remove_reference&lt;T&gt;::type&amp;&amp;</code>，使得<code>ReturnType</code>是一个右值引用</li><li><code>static_cast&lt;ReturnType&gt;(param)</code> 将param转化为右值引用</li></ol><p>类似使用C++14版本更简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span>          <span class="comment">//C++14，仍然在std命名空间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="type">remove_referece_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;std::move&lt;/code&gt;执行到右值的无条件的转换，但就自身而言，它不移动任何东西&lt;/p&gt;
&lt;p&gt;内部的实现类似这样：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; remove_reference&amp;lt;T&amp;gt;::&lt;span class=&quot;function&quot;&gt;type&amp;amp;&amp;amp; &lt;span class=&quot;title&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T&amp;amp;&amp;amp; param)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; ReturnType = &lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;ReturnType&amp;gt;(param);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="C++" scheme="https://bugcat.top/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="https://bugcat.top/2024/10/07/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>https://bugcat.top/2024/10/07/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2024-10-07T16:32:16.000Z</published>
    <updated>2024-10-20T13:34:26.724Z</updated>
    
    <content type="html"><![CDATA[<p>C++中已经基本不推荐使用裸指针（手动进行<code>new</code>和<code>delete</code>），基本上都是使用智能指针。所以作为C++程序员必须学会智能指针的使用：<code>auto_ptr</code>（已废弃不建议使用）、<code>unique_ptr</code>、<code>share_ptr</code>、<code>weak_ptr</code></p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/智能指针思维导图.png" alt="画板"><br><span id="more"></span></p><h2 id="auto-ptr-已废弃"><a href="#auto-ptr-已废弃" class="headerlink" title="auto_ptr(已废弃)"></a><code>auto_ptr</code>(已废弃)</h2><p><code>auto_ptr</code>是C++98标准库中提供的智能指针之一，用于管理动态分配的内存资源。它采用<strong>独占所有权</strong>的方式管理资源，即同一时间只能有一个<code>auto_ptr</code>实例拥有特定资源的所有权。当<code>auto_ptr</code>实例被销毁时，它会自动释放所管理的资源，从而避免了内存泄漏的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; sp2;</span><br><span class="line">sp2 = sp1;   <span class="comment">// 赋值后sp1为空</span></span><br></pre></td></tr></table></figure><p><code>auto_ptr</code>被废弃有一下几个问题：</p><ol><li>语义不清。当复制一个<code>auto_ptr</code>对象时（拷贝复制或operator =复制），原对象所持有的堆内存对象也会转移给复制出来的对象。这种是复制语义，但是具体实现却是转移（move），语义上就容易让人混淆，让人逻辑上很容易错误，所以后面出现了<code>unique_ptr</code>代替<code>auto_ptr</code></li><li>不适用于容器：<code>auto_ptr</code>不能很好地与STL容器一起使用，因为在容器中进行元素的复制或移动操作时会导致指针所有权的转移，可能引发错误。</li></ol><p><code>auto_ptr</code>了解一下就行，主要感觉八股文考的多一些</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p><code>unique_ptr</code>是C++11标准引入的智能指针之一，它采用<strong>独占所有权</strong>的方式，即同一时间只能有一个<code>unique_ptr</code>实例拥有特定资源的所有权。这意味着在任何时刻只有一个<code>unique_ptr</code>可以指向特定的资源，避免了多重所有权可能引发的问题。<code>unique_ptr</code>可以说是<code>auto_ptr</code>的升级版本。</p><p>前面<code>auto_ptr</code>代码使用<code>unique_ptr</code>代替：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;std::string&gt; <span class="title">uptr1</span><span class="params">(<span class="keyword">new</span> std::string(<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">std::unique_ptr&lt;std::string&gt; uptr2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 uptr1 的所有权转移给 uptr2，转移后uptr1为nullptr</span></span><br><span class="line">uptr2 = std::<span class="built_in">move</span>(uptr1);</span><br></pre></td></tr></table></figure><ol><li><code>auto_ptr</code> 的前车之鉴，<code>unique_ptr</code> 禁止复制语义，为了达到这个效果，<code>std::unique_ptr</code> 类的拷贝构造函数和赋值运算符（<code>operator =</code>）被标记为 <code>delete</code>。<code>unique_ptr</code> 只能通过移动构造或者移动赋值进行转移</li><li>自定义删除器。<code>unique_ptr</code>默认的删除器是<code>delete</code>，但是有时候我们想定义自己的删除器，这个也是可以实现的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用auto和lambda表达式定义自定义删除器</span></span><br><span class="line">    <span class="keyword">auto</span> customDeleter = [](<span class="type">int</span>* ptr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;自定义删除器被调用，释放资源：&quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义删除器</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>, <span class="title">decltype</span><span class="params">(customDeleter)</span>&gt; <span class="title">uptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>), customDeleter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动释放资源</span></span><br><span class="line">    uptr.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>unique_ptr</code>的指针大小和普通指针相等，所以一般没有特殊要求，我们可以使用<code>unique_ptr</code>最节约内存。</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p> <code>unique_ptr</code>其中的源码（visual studio C++20）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span> <span class="comment">/* = default_delete&lt;_Ty&gt; */</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span> &#123; <span class="comment">// non-copyable pointer to an object</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 指针类型</span></span><br><span class="line">    <span class="keyword">using</span> pointer      = <span class="keyword">typename</span> _Get_deleter_pointer_type&lt;_Ty, <span class="type">remove_reference_t</span>&lt;_Dx&gt;&gt;::type;</span><br><span class="line">    <span class="comment">// 元素类型</span></span><br><span class="line">    <span class="keyword">using</span> element_type = _Ty;</span><br><span class="line">    <span class="comment">// 删除器类型</span></span><br><span class="line">    <span class="keyword">using</span> deleter_type = _Dx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dx2</span> = _Dx, _Unique_ptr_enable_default_t&lt;_Dx2&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span> : _Mypair(_Zero_then_variadic_args_t&#123;&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Dx2 = _Dx, _Unique_ptr_enable_default_t&lt;_Dx2&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">unique_ptr</span>(<span class="type">nullptr_t</span>) <span class="keyword">noexcept</span> : _Mypair(_Zero_then_variadic_args_t&#123;&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    _CONSTEXPR23 unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">nullptr_t</span>) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">reset</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The Standard depicts these constructors that accept pointer as taking type_identity_t&lt;pointer&gt; to inhibit CTAD.</span></span><br><span class="line">    <span class="comment">// Since pointer is an opaque type alias in our implementation, it inhibits CTAD without extra decoration.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dx2</span> = _Dx, _Unique_ptr_enable_default_t&lt;_Dx2&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 <span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer _Ptr) <span class="keyword">noexcept</span> : _Mypair(_Zero_then_variadic_args_t&#123;&#125;, _Ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Dx2 = _Dx, <span class="type">enable_if_t</span>&lt;is_constructible_v&lt;_Dx2, <span class="type">const</span> _Dx2&amp;&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 <span class="built_in">unique_ptr</span>(pointer _Ptr, <span class="type">const</span> _Dx&amp; _Dt) <span class="keyword">noexcept</span> : _Mypair(_One_then_variadic_args_t&#123;&#125;, _Dt, _Ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Dx2                                                                            = _Dx,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;negation&lt;is_reference&lt;_Dx2&gt;&gt;, is_constructible&lt;_Dx2, _Dx2&gt;&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 <span class="built_in">unique_ptr</span>(pointer _Ptr, _Dx&amp;&amp; _Dt) <span class="keyword">noexcept</span></span><br><span class="line">        : _Mypair(_One_then_variadic_args_t&#123;&#125;, _STD <span class="built_in">move</span>(_Dt), _Ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Dx2                                                                                      = _Dx,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_reference&lt;_Dx2&gt;, is_constructible&lt;_Dx2, <span class="type">remove_reference_t</span>&lt;_Dx2&gt;&gt;&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">unique_ptr</span>(pointer, <span class="type">remove_reference_t</span>&lt;_Dx&gt;&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dx2</span> = _Dx, <span class="type">enable_if_t</span>&lt;is_move_constructible_v&lt;_Dx2&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 <span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span></span><br><span class="line">        : _Mypair(_One_then_variadic_args_t&#123;&#125;, _STD forward&lt;_Dx&gt;(_Right.<span class="built_in">get_deleter</span>()), _Right.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Ty2, <span class="keyword">class</span> _Dx2,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;</span><br><span class="line">            conjunction_v&lt;negation&lt;is_array&lt;_Ty2&gt;&gt;, is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Ty2, _Dx2&gt;::pointer, pointer&gt;,</span><br><span class="line">                <span class="type">conditional_t</span>&lt;is_reference_v&lt;_Dx&gt;, is_same&lt;_Dx2, _Dx&gt;, is_convertible&lt;_Dx2, _Dx&gt;&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 <span class="built_in">unique_ptr</span>(unique_ptr&lt;_Ty2, _Dx2&gt;&amp;&amp; _Right) <span class="keyword">noexcept</span></span><br><span class="line">        : _Mypair(_One_then_variadic_args_t&#123;&#125;, _STD forward&lt;_Dx2&gt;(_Right.<span class="built_in">get_deleter</span>()), _Right.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Ty2, <span class="keyword">class</span> _Dx2,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;negation&lt;is_array&lt;_Ty2&gt;&gt;, is_assignable&lt;_Dx&amp;, _Dx2&gt;,</span><br><span class="line">                        is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Ty2, _Dx2&gt;::pointer, pointer&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&lt;_Ty2, _Dx2&gt;&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">reset</span>(_Right.<span class="built_in">release</span>());</span><br><span class="line">        _Mypair._Get_first() = _STD forward&lt;_Dx2&gt;(_Right._Mypair._Get_first());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动赋值</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dx2</span> = _Dx, <span class="type">enable_if_t</span>&lt;is_move_assignable_v&lt;_Dx2&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != _STD <span class="built_in">addressof</span>(_Right)) &#123;</span><br><span class="line">            <span class="built_in">reset</span>(_Right.<span class="built_in">release</span>());</span><br><span class="line">            _Mypair._Get_first() = _STD forward&lt;_Dx&gt;(_Right._Mypair._Get_first());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_CONSTEXPR23 <span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr&amp; _Right)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        _Swap_adl(_Mypair._Myval2, _Right._Mypair._Myval2);</span><br><span class="line">        _Swap_adl(_Mypair._Get_first(), _Right._Mypair._Get_first());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _CONSTEXPR23 ~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Mypair._Myval2) &#123;</span><br><span class="line">            <span class="comment">// 调用 first删除器 删除 指针</span></span><br><span class="line">            _Mypair._Get_first()(_Mypair._Myval2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD _CONSTEXPR23 _Dx&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Mypair._Get_first();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD _CONSTEXPR23 <span class="type">const</span> _Dx&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Mypair._Get_first();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _NODISCARD _CONSTEXPR23 <span class="type">add_lvalue_reference_t</span>&lt;_Ty&gt; <span class="keyword">operator</span>*() <span class="function"><span class="type">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(*_STD declval&lt;pointer&gt;()))</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *_Mypair._Myval2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _NODISCARD _CONSTEXPR23 pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _Mypair._Myval2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD _CONSTEXPR23 pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Mypair._Myval2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_CONSTEXPR23 <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(_Mypair._Myval2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_CONSTEXPR23 pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _STD <span class="built_in">exchange</span>(_Mypair._Myval2, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_CONSTEXPR23 <span class="type">void</span> <span class="title">reset</span><span class="params">(pointer _Ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        pointer _Old = _STD <span class="built_in">exchange</span>(_Mypair._Myval2, _Ptr);</span><br><span class="line">        <span class="keyword">if</span> (_Old) &#123;</span><br><span class="line">            _Mypair._Get_first()(_Old);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制操作设置为delete</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;)            = <span class="keyword">delete</span>;</span><br><span class="line">    unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>, <span class="keyword">class</span>&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">unique_ptr</span>;</span><br><span class="line">    <span class="comment">// _Mypair first是删除器，second是指针</span></span><br><span class="line">    _Compressed_pair&lt;_Dx, pointer&gt; _Mypair;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>unique_ptr</code>实现粗略看比较简单，数据成员比较重要的就是<code>_Mypair</code>，里面存放者删除器和指针，在析构的时候就调用删除器删除指针。</p><h2 id="share-ptr"><a href="#share-ptr" class="headerlink" title="share_ptr"></a>share_ptr</h2><p><code>share_ptr</code>通过引用计数的方式来控制资源的释放，允许多个指针指向同一个资源（共享），每多一个<code>std::shared_ptr</code>对资源的引用，资源引用计数将增加1，每一个指向该资源的<code>std::shared_ptr</code>对象析构时，资源引用计数减1，最后一个<code>std::shared_ptr</code>对象析构时，发现资源计数为0，将释放其持有的资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化方式1</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方式2</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp2;</span><br><span class="line">sp<span class="number">2.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">123</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方式3</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp3;</span><br><span class="line">sp3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><ol><li>自定义删除器，<code>shared_ptr</code>自定义删除器比<code>unique_ptr</code> 简单一些，不会影响指针指针的类型</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用auto和lambda表达式定义自定义删除器</span></span><br><span class="line">    <span class="keyword">auto</span> customDeleter = [](<span class="type">int</span>* ptr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;自定义删除器被调用，释放资源：&quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用auto和lambda表达式实现自定义删除器的shared_ptr</span></span><br><span class="line">    <span class="keyword">auto</span> sptr = std::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>), customDeleter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用shared_ptr访问资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sptr指向的整数是: &quot;</span> &lt;&lt; *sptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当最后一个shared_ptr销毁时，自定义删除器会被调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在<code>shared_ptr</code>有两个指针，一个指针指向资源，一个指针指向控制块，所以<code>shared_ptr</code>大小其实是普通指针的两倍，并且每次<code>shared_ptr</code>操作都会对控制块进行操作（对引用技术进行操作），所以效率没有<code>unique_ptr</code>高。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/share_ptr示意.png" alt=""></p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>先看类图</p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/share_ptr类图.png" alt=""></p><ol><li><code>shared_ptr</code> 继承<code>_Ptr_base</code>，关于指针和控制块的部分都是在<code>_Ptr_base</code>中，<code>shared_ptr</code>调用<code>_Ptr_base</code>中内容进行引用计算的增加和减少</li><li><code>_Ptr_base</code>重要的数据成员：<code>_Ptr</code>、<code>_Rep</code>两个指针一个指向资源、一个指向控制块（<code>_Ref_count_base</code>）</li><li><code>_Ref_count_base</code>（控制块）是个纯虚类，里面有uses和weaks两个引用控制块</li><li><code>_Ref_count_base</code>有三个实现类<code>_Ref_count</code>、<code>_Ref_count_resource</code>、<code>_Ref_count_resource_alloc</code>，分别代表普通引用计数、带删除器的引用计数、带删除器和分配器的引用计数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> : <span class="keyword">public</span> _Ptr_base&lt;_Ty&gt; &#123; <span class="comment">// class for reference counted resource management</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> _Mybase = _Ptr_base&lt;_Ty&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">typename</span> _Mybase::element_type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _HAS_CXX17</span></span><br><span class="line">    <span class="keyword">using</span> weak_type = weak_ptr&lt;_Ty&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _HAS_CXX17</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">shared_ptr</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">shared_ptr</span><span class="params">(<span class="type">nullptr_t</span>)</span> <span class="keyword">noexcept</span> </span>&#123;&#125; <span class="comment">// construct empty shared_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;<span class="type">conditional_t</span>&lt;is_array_v&lt;_Ty&gt;, _Can_array_delete&lt;_Ux&gt;, _Can_scalar_delete&lt;_Ux&gt;&gt;,</span><br><span class="line">                        _SP_convertible&lt;_Ux, _Ty&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>(_Ux* _Px) &#123; <span class="comment">// construct shared_ptr object that owns _Px</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">constexpr</span> (is_array_v&lt;_Ty&gt;) &#123;</span><br><span class="line">            _Setpd(_Px, default_delete&lt;_Ux[]&gt;&#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _Temporary_owner&lt;_Ux&gt; _Owner(_Px);</span><br><span class="line">            <span class="comment">// 此函数和enable_share_from_this相关</span></span><br><span class="line">            _Set_ptr_rep_and_enable_shared(_Owner._Ptr, <span class="keyword">new</span> _Ref_count&lt;_Ux&gt;(_Owner._Ptr));</span><br><span class="line">            _Owner._Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_move_constructible&lt;_Dx&gt;, _Can_call_function_object&lt;_Dx&amp;, _Ux*&amp;&gt;,</span><br><span class="line">                        _SP_convertible&lt;_Ux, _Ty&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(_Ux* _Px, _Dx _Dt) &#123; <span class="comment">// construct with _Px, deleter</span></span><br><span class="line">        _Setpd(_Px, _STD <span class="built_in">move</span>(_Dt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_move_constructible&lt;_Dx&gt;, _Can_call_function_object&lt;_Dx&amp;, _Ux*&amp;&gt;,</span><br><span class="line">                        _SP_convertible&lt;_Ux, _Ty&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(_Ux* _Px, _Dx _Dt, _Alloc _Ax) &#123; <span class="comment">// construct with _Px, deleter, allocator</span></span><br><span class="line">        _Setpda(_Px, _STD <span class="built_in">move</span>(_Dt), _Ax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dx</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_move_constructible&lt;_Dx&gt;, _Can_call_function_object&lt;_Dx&amp;, <span class="type">nullptr_t</span>&amp;&gt;&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">nullptr_t</span>, _Dx _Dt) &#123; <span class="comment">// construct with nullptr, deleter</span></span><br><span class="line">        _Setpd(<span class="literal">nullptr</span>, _STD <span class="built_in">move</span>(_Dt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dx</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_move_constructible&lt;_Dx&gt;, _Can_call_function_object&lt;_Dx&amp;, <span class="type">nullptr_t</span>&amp;&gt;&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">nullptr_t</span>, _Dx _Dt, _Alloc _Ax) &#123; <span class="comment">// construct with nullptr, deleter, allocator</span></span><br><span class="line">        _Setpda(<span class="literal">nullptr</span>, _STD <span class="built_in">move</span>(_Dt), _Ax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Right, element_type* _Px) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// construct shared_ptr object that aliases _Right</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Alias_construct_from(_Right, _Px);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr&lt;_Ty2&gt;&amp;&amp; _Right, element_type* _Px) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// move construct shared_ptr object that aliases _Right</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Alias_move_construct_from(_STD <span class="built_in">move</span>(_Right), _Px);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&amp; _Other) <span class="keyword">noexcept</span> &#123; <span class="comment">// construct shared_ptr object that owns same resource as _Other</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Copy_construct_from(_Other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// construct shared_ptr object that owns same resource as _Other</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Copy_construct_from(_Other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123; <span class="comment">// construct shared_ptr object that takes resource from _Right</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Move_construct_from(_STD <span class="built_in">move</span>(_Right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr&lt;_Ty2&gt;&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123; <span class="comment">// construct shared_ptr object that takes resource from _Right</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Move_construct_from(_STD <span class="built_in">move</span>(_Right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>(<span class="type">const</span> weak_ptr&lt;_Ty2&gt;&amp; _Other) &#123; <span class="comment">// construct shared_ptr object that owns resource *_Other</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;_Construct_from_weak(_Other)) &#123;</span><br><span class="line">            _Throw_bad_weak_ptr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;_SP_pointer_compatible&lt;_Ux, _Ty&gt;,</span><br><span class="line">                        is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Ux, _Dx&gt;::pointer, element_type*&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="comment">// 从unique_ptr进行构造</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>(unique_ptr&lt;_Ux, _Dx&gt;&amp;&amp; _Other) &#123;</span><br><span class="line">        <span class="keyword">using</span> _Fancy_t   = <span class="keyword">typename</span> unique_ptr&lt;_Ux, _Dx&gt;::pointer;</span><br><span class="line">        <span class="keyword">using</span> _Raw_t     = <span class="keyword">typename</span> unique_ptr&lt;_Ux, _Dx&gt;::element_type*;</span><br><span class="line">        <span class="keyword">using</span> _Deleter_t = <span class="type">conditional_t</span>&lt;is_reference_v&lt;_Dx&gt;, <span class="keyword">decltype</span>(_STD <span class="built_in">ref</span>(_Other.<span class="built_in">get_deleter</span>())), _Dx&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> _Fancy_t _Fancy = _Other.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_Fancy) &#123;</span><br><span class="line">            <span class="type">const</span> _Raw_t _Raw = _Fancy;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> _Rx =</span><br><span class="line">                <span class="keyword">new</span> _Ref_count_resource&lt;_Fancy_t, _Deleter_t&gt;(_Fancy, _STD forward&lt;_Dx&gt;(_Other.<span class="built_in">get_deleter</span>()));</span><br><span class="line">            _Set_ptr_rep_and_enable_shared(_Raw, _Rx);</span><br><span class="line">            _Other.<span class="built_in">release</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构的时候调用_Decref减少引用</span></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() <span class="keyword">noexcept</span> &#123; <span class="comment">// release resource</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Decref();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">shared_ptr</span>(_Right).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">shared_ptr</span>(_Right).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123; <span class="comment">// take resource from _Right</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>(_STD <span class="built_in">move</span>(_Right)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;_Ty2&gt;&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123; <span class="comment">// take resource from _Right</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>(_STD <span class="built_in">move</span>(_Right)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;_SP_pointer_compatible&lt;_Ux, _Ty&gt;,</span><br><span class="line">                        is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Ux, _Dx&gt;::pointer, element_type*&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&lt;_Ux, _Dx&gt;&amp;&amp; _Right) &#123; <span class="comment">// move from unique_ptr</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>(_STD <span class="built_in">move</span>(_Right)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(shared_ptr&amp; _Other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Swap(_Other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// release resource and convert to empty shared_ptr object</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>().<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;<span class="type">conditional_t</span>&lt;is_array_v&lt;_Ty&gt;, _Can_array_delete&lt;_Ux&gt;, _Can_scalar_delete&lt;_Ux&gt;&gt;,</span><br><span class="line">                        _SP_convertible&lt;_Ux, _Ty&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">reset</span>(_Ux* _Px) &#123; <span class="comment">// release, take ownership of _Px</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>(_Px).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_move_constructible&lt;_Dx&gt;, _Can_call_function_object&lt;_Dx&amp;, _Ux*&amp;&gt;,</span><br><span class="line">                        _SP_convertible&lt;_Ux, _Ty&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">reset</span>(_Ux* _Px, _Dx _Dt) &#123; <span class="comment">// release, take ownership of _Px, with deleter _Dt</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>(_Px, _Dt).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_move_constructible&lt;_Dx&gt;, _Can_call_function_object&lt;_Dx&amp;, _Ux*&amp;&gt;,</span><br><span class="line">                        _SP_convertible&lt;_Ux, _Ty&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">reset</span>(_Ux* _Px, _Dx _Dt, _Alloc _Ax) &#123; <span class="comment">// release, take ownership of _Px, with deleter _Dt, allocator _Ax</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>(_Px, _Dt, _Ax).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> _Mybase::get;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span> = _Ty, <span class="type">enable_if_t</span>&lt;!disjunction_v&lt;is_array&lt;_Ty2&gt;, is_void&lt;_Ty2&gt;&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _NODISCARD _Ty2&amp; <span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span> = _Ty, <span class="type">enable_if_t</span>&lt;!is_array_v&lt;_Ty2&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _NODISCARD _Ty2* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span> = _Ty, <span class="keyword">class</span> _Elem = element_type, <span class="type">enable_if_t</span>&lt;is_array_v&lt;_Ty2&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _NODISCARD _Elem&amp; <span class="keyword">operator</span>[](<span class="type">ptrdiff_t</span> _Idx) <span class="type">const</span> <span class="keyword">noexcept</span> <span class="comment">/* strengthened */</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>()[_Idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>() != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_UxptrOrNullptr</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Setpd(<span class="type">const</span> _UxptrOrNullptr _Px, _Dx _Dt) &#123; <span class="comment">// take ownership of _Px, deleter _Dt</span></span><br><span class="line">        _Temporary_owner_del&lt;_UxptrOrNullptr, _Dx&gt; _Owner(_Px, _Dt);</span><br><span class="line">        _Set_ptr_rep_and_enable_shared(</span><br><span class="line">            _Owner._Ptr, <span class="keyword">new</span> _Ref_count_resource&lt;_UxptrOrNullptr, _Dx&gt;(_Owner._Ptr, _STD <span class="built_in">move</span>(_Dt)));</span><br><span class="line">        _Owner._Call_deleter = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_UxptrOrNullptr</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Setpda(<span class="type">const</span> _UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax) &#123; <span class="comment">// take ownership of _Px, deleter _Dt, allocator _Ax</span></span><br><span class="line">        <span class="keyword">using</span> _Alref_alloc = _Rebind_alloc_t&lt;_Alloc, _Ref_count_resource_alloc&lt;_UxptrOrNullptr, _Dx, _Alloc&gt;&gt;;</span><br><span class="line"></span><br><span class="line">        _Temporary_owner_del&lt;_UxptrOrNullptr, _Dx&gt; _Owner(_Px, _Dt);</span><br><span class="line">        _Alref_alloc _Alref(_Ax);</span><br><span class="line">        _Alloc_construct_ptr&lt;_Alref_alloc&gt; _Constructor(_Alref);</span><br><span class="line">        _Constructor._Allocate();</span><br><span class="line">        _Construct_in_place(*_Constructor._Ptr, _Owner._Ptr, _STD <span class="built_in">move</span>(_Dt), _Ax);</span><br><span class="line">        _Set_ptr_rep_and_enable_shared(_Owner._Ptr, _Unfancy(_Constructor._Ptr));</span><br><span class="line">        _Constructor._Ptr    = <span class="literal">nullptr</span>;</span><br><span class="line">        _Owner._Call_deleter = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Set_ptr_rep_and_enable_shared(_Ux* <span class="type">const</span> _Px, _Ref_count_base* <span class="type">const</span> _Rx) <span class="keyword">noexcept</span> &#123; <span class="comment">// take ownership of _Px</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Ptr = _Px;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Rep = _Rx;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(conjunction_v&lt;negation&lt;is_array&lt;_Ty&gt;&gt;, negation&lt;is_volatile&lt;_Ux&gt;&gt;, _Can_enable_shared&lt;_Ux&gt;&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (_Px &amp;&amp; _Px-&gt;_Wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">                _Px-&gt;_Wptr = shared_ptr&lt;<span class="type">remove_cv_t</span>&lt;_Ux&gt;&gt;(*<span class="keyword">this</span>, <span class="keyword">const_cast</span>&lt;<span class="type">remove_cv_t</span>&lt;_Ux&gt;*&gt;(_Px));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Set_ptr_rep_and_enable_shared(<span class="type">nullptr_t</span>, _Ref_count_base* <span class="type">const</span> _Rx) <span class="keyword">noexcept</span> &#123; <span class="comment">// take ownership of nullptr</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Rep = _Rx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Ptr_base</span> &#123; <span class="comment">// base class for shared_ptr and weak_ptr</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> element_type = <span class="type">remove_extent_t</span>&lt;_Ty&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Rep ? _Rep-&gt;_Use_count() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="function">_NODISCARD <span class="type">bool</span> <span class="title">owner_before</span><span class="params">(<span class="type">const</span> _Ptr_base&lt;_Ty2&gt;&amp; _Right)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// compare addresses of manager objects</span></span><br><span class="line">        <span class="keyword">return</span> _Rep &lt; _Right._Rep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Ptr_base(<span class="type">const</span> _Ptr_base&amp;)            = <span class="keyword">delete</span>;</span><br><span class="line">    _Ptr_base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> _Ptr_base&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">_NODISCARD element_type* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> _Ptr_base() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    ~_Ptr_base() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Move_construct_from(_Ptr_base&lt;_Ty2&gt;&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement shared_ptr&#x27;s (converting) move ctor and weak_ptr&#x27;s move ctor</span></span><br><span class="line">        _Ptr = _Right._Ptr;</span><br><span class="line">        _Rep = _Right._Rep;</span><br><span class="line"></span><br><span class="line">        _Right._Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        _Right._Rep = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Copy_construct_from(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement shared_ptr&#x27;s (converting) copy ctor</span></span><br><span class="line">        _Other._Incref();</span><br><span class="line"></span><br><span class="line">        _Ptr = _Other._Ptr;</span><br><span class="line">        _Rep = _Other._Rep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Alias_construct_from(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Other, element_type* _Px) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement shared_ptr&#x27;s aliasing ctor</span></span><br><span class="line">        _Other._Incref();</span><br><span class="line"></span><br><span class="line">        _Ptr = _Px;</span><br><span class="line">        _Rep = _Other._Rep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Alias_move_construct_from(shared_ptr&lt;_Ty2&gt;&amp;&amp; _Other, element_type* _Px) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement shared_ptr&#x27;s aliasing move ctor</span></span><br><span class="line">        _Ptr = _Px;</span><br><span class="line">        _Rep = _Other._Rep;</span><br><span class="line"></span><br><span class="line">        _Other._Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        _Other._Rep = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty0</span>&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">weak_ptr</span>; <span class="comment">// specifically, weak_ptr::lock()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">bool</span> _Construct_from_weak(<span class="type">const</span> weak_ptr&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement shared_ptr&#x27;s ctor from weak_ptr, and weak_ptr::lock()</span></span><br><span class="line">        <span class="keyword">if</span> (_Other._Rep &amp;&amp; _Other._Rep-&gt;_Incref_nz()) &#123;</span><br><span class="line">            _Ptr = _Other._Ptr;</span><br><span class="line">            _Rep = _Other._Rep;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// User增加引用计数</span></span><br><span class="line">    <span class="type">void</span> _Incref() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Rep) &#123;</span><br><span class="line">            _Rep-&gt;_Incref();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// User减少引用计数</span></span><br><span class="line">    <span class="type">void</span> _Decref() <span class="keyword">noexcept</span> &#123; <span class="comment">// decrement reference count</span></span><br><span class="line">        <span class="keyword">if</span> (_Rep) &#123;</span><br><span class="line">            _Rep-&gt;_Decref();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Swap(_Ptr_base&amp; _Right) <span class="keyword">noexcept</span> &#123; <span class="comment">// swap pointers</span></span><br><span class="line">        <span class="function">_STD <span class="title">swap</span><span class="params">(_Ptr, _Right._Ptr)</span></span>;</span><br><span class="line">        <span class="function">_STD <span class="title">swap</span><span class="params">(_Rep, _Right._Rep)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Weakly_construct_from(<span class="type">const</span> _Ptr_base&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123; <span class="comment">// implement weak_ptr&#x27;s ctors</span></span><br><span class="line">        <span class="keyword">if</span> (_Other._Rep) &#123;</span><br><span class="line">            _Ptr = _Other._Ptr;</span><br><span class="line">            _Rep = _Other._Rep;</span><br><span class="line">            _Rep-&gt;_Incwref();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _STL_INTERNAL_CHECK(!_Ptr &amp;&amp; !_Rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Weakly_convert_lvalue_avoiding_expired_conversions(<span class="type">const</span> _Ptr_base&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement weak_ptr&#x27;s copy converting ctor</span></span><br><span class="line">        <span class="keyword">if</span> (_Other._Rep) &#123;</span><br><span class="line">            _Rep = _Other._Rep; <span class="comment">// always share ownership</span></span><br><span class="line">            _Rep-&gt;_Incwref();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_Rep-&gt;_Incref_nz()) &#123;</span><br><span class="line">                _Ptr = _Other._Ptr; <span class="comment">// keep resource alive during conversion, handling virtual inheritance</span></span><br><span class="line">                _Rep-&gt;_Decref();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _STL_INTERNAL_CHECK(!_Ptr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _STL_INTERNAL_CHECK(!_Ptr &amp;&amp; !_Rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Weakly_convert_rvalue_avoiding_expired_conversions(_Ptr_base&lt;_Ty2&gt;&amp;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement weak_ptr&#x27;s move converting ctor</span></span><br><span class="line">        _Rep        = _Other._Rep; <span class="comment">// always transfer ownership</span></span><br><span class="line">        _Other._Rep = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_Rep &amp;&amp; _Rep-&gt;_Incref_nz()) &#123;</span><br><span class="line">            _Ptr = _Other._Ptr; <span class="comment">// keep resource alive during conversion, handling virtual inheritance</span></span><br><span class="line">            _Rep-&gt;_Decref();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _STL_INTERNAL_CHECK(!_Ptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _Other._Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// weaks增加引用计数</span></span><br><span class="line">    <span class="type">void</span> _Incwref() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Rep) &#123;</span><br><span class="line">            _Rep-&gt;_Incwref();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// weaks减少引用计数</span></span><br><span class="line">    <span class="type">void</span> _Decwref() <span class="keyword">noexcept</span> &#123; <span class="comment">// decrement weak reference count</span></span><br><span class="line">        <span class="keyword">if</span> (_Rep) &#123;</span><br><span class="line">            _Rep-&gt;_Decwref();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 智能指针关联的原始指针</span></span><br><span class="line">    element_type* _Ptr&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="comment">// 管理智能指针的 控制块</span></span><br><span class="line">    _Ref_count_base* _Rep&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__declspec</span>(novtable) _Ref_count_base &#123; <span class="comment">// common code for reference counting</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_CEE_PURE</span></span><br><span class="line">    <span class="comment">// permanent workaround to avoid mentioning _purecall in msvcurt.lib, ptrustu.lib, or other support libs</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _Destroy() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="function">_STD <span class="title">terminate</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _Delete_this() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="function">_STD <span class="title">terminate</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// ^^^ _M_CEE_PURE / !_M_CEE_PURE vvv</span></span></span><br><span class="line">   <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _Destroy() <span class="keyword">noexcept</span>     = <span class="number">0</span>; <span class="comment">// destroy managed resource</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _Delete_this() <span class="keyword">noexcept</span> = <span class="number">0</span>; <span class="comment">// destroy self</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _M_CEE_PURE</span></span></span><br><span class="line">    <span class="comment">// 强指针的引用计数（原子）</span></span><br><span class="line">    _Atomic_counter_t _Uses  = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 弱指针的引用计数（原子）</span></span><br><span class="line">    _Atomic_counter_t _Weaks = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">constexpr</span> _Ref_count_base() <span class="keyword">noexcept</span> = <span class="keyword">default</span>; <span class="comment">// non-atomic initializations</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 不允许复制</span></span><br><span class="line">    _Ref_count_base(<span class="type">const</span> _Ref_count_base&amp;)            = <span class="keyword">delete</span>;</span><br><span class="line">    _Ref_count_base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> _Ref_count_base&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~_Ref_count_base() <span class="keyword">noexcept</span> &#123;&#125; <span class="comment">// TRANSITION, should be non-virtual</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> _Incref_nz() <span class="keyword">noexcept</span> &#123; <span class="comment">// increment use count if not zero, return true if successful</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; _Volatile_uses = <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">volatile</span> <span class="type">long</span>&amp;&gt;(_Uses);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_CEE_PURE</span></span><br><span class="line">        <span class="type">long</span> _Count = *_Atomic_address_as&lt;<span class="type">const</span> <span class="type">long</span>&gt;(&amp;_Volatile_uses);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="type">long</span> _Count = __iso_volatile_load32(<span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">volatile</span> <span class="type">int</span>*&gt;(&amp;_Volatile_uses));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">while</span> (_Count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">long</span> _Old_value = _INTRIN_RELAXED(_InterlockedCompareExchange)(&amp;_Volatile_uses, _Count + <span class="number">1</span>, _Count);</span><br><span class="line">            <span class="keyword">if</span> (_Old_value == _Count) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _Count = _Old_value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Incref() <span class="keyword">noexcept</span> &#123; <span class="comment">// increment use count</span></span><br><span class="line">        _MT_INCR(_Uses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Incwref() <span class="keyword">noexcept</span> &#123; <span class="comment">// increment weak reference count</span></span><br><span class="line">        _MT_INCR(_Weaks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Decref() <span class="keyword">noexcept</span> &#123; <span class="comment">// decrement use count</span></span><br><span class="line">        <span class="keyword">if</span> (_MT_DECR(_Uses) == <span class="number">0</span>) &#123;</span><br><span class="line">            _Destroy();</span><br><span class="line">            _Decwref();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Decwref() <span class="keyword">noexcept</span> &#123; <span class="comment">// decrement weak reference count</span></span><br><span class="line">        <span class="keyword">if</span> (_MT_DECR(_Weaks) == <span class="number">0</span>) &#123;</span><br><span class="line">            _Delete_this();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> _Use_count() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(_Uses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span>* _Get_deleter(<span class="type">const</span> type_info&amp;) <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带删除器的引用计数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Ref_count</span> : <span class="keyword">public</span> _Ref_count_base &#123; <span class="comment">// handle reference counting for pointer without deleter</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> _Ref_count(_Ty* _Px) : _Ref_count_base(), _Ptr(_Px) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> _Destroy() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123; <span class="comment">// destroy managed resource</span></span><br><span class="line">        <span class="keyword">delete</span> _Ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Delete_this() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123; <span class="comment">// destroy self</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Ty* _Ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 带删除器的引用计数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Resource</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Ref_count_resource</span> : <span class="keyword">public</span> _Ref_count_base &#123; <span class="comment">// handle reference counting for object with deleter</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _Ref_count_resource(_Resource _Px, _Dx _Dt)</span><br><span class="line">        : _Ref_count_base(), _Mypair(_One_then_variadic_args_t&#123;&#125;, _STD <span class="built_in">move</span>(_Dt), _Px) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __EDG__ <span class="comment">// TRANSITION, VSO-1292293</span></span></span><br><span class="line">    ~_Ref_count_resource() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123;&#125; <span class="comment">// TRANSITION, should be non-virtual</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// ^^^ workaround / no workaround vvv</span></span></span><br><span class="line">    ~_Ref_count_resource() <span class="keyword">noexcept</span> <span class="keyword">override</span> = <span class="keyword">default</span>; <span class="comment">// TRANSITION, should be non-virtual</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ^^^ no workaround ^^^</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* _Get_deleter(<span class="type">const</span> type_info&amp; _Typeid) <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _HAS_STATIC_RTTI</span></span><br><span class="line">        <span class="keyword">if</span> (_Typeid == <span class="built_in">typeid</span>(_Dx)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;_Dx*&gt;(_STD <span class="built_in">addressof</span>(_Mypair._Get_first()));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// _HAS_STATIC_RTTI</span></span></span><br><span class="line">        (<span class="type">void</span>) _Typeid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _HAS_STATIC_RTTI</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> _Destroy() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123; <span class="comment">// destroy managed resource</span></span><br><span class="line">        _Mypair._Get_first()(_Mypair._Myval2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Delete_this() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123; <span class="comment">// destroy self</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Compressed_pair&lt;_Dx, _Resource&gt; _Mypair;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带删除器和分配器 的 引用计数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Resource</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Ref_count_resource_alloc</span> : <span class="keyword">public</span> _Ref_count_base &#123;</span><br><span class="line">    <span class="comment">// handle reference counting for object with deleter and allocator</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _Ref_count_resource_alloc(_Resource _Px, _Dx _Dt, <span class="type">const</span> _Alloc&amp; _Ax)</span><br><span class="line">        : _Ref_count_base(),</span><br><span class="line">          _Mypair(_One_then_variadic_args_t&#123;&#125;, _STD <span class="built_in">move</span>(_Dt), _One_then_variadic_args_t&#123;&#125;, _Ax, _Px) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __EDG__ <span class="comment">// TRANSITION, VSO-1292293</span></span></span><br><span class="line">    ~_Ref_count_resource_alloc() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123;&#125; <span class="comment">// TRANSITION, should be non-virtual</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// ^^^ workaround / no workaround vvv</span></span></span><br><span class="line">    ~_Ref_count_resource_alloc() <span class="keyword">noexcept</span> <span class="keyword">override</span> = <span class="keyword">default</span>; <span class="comment">// TRANSITION, should be non-virtual</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ^^^ no workaround ^^^</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* _Get_deleter(<span class="type">const</span> type_info&amp; _Typeid) <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _HAS_STATIC_RTTI</span></span><br><span class="line">        <span class="keyword">if</span> (_Typeid == <span class="built_in">typeid</span>(_Dx)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;_Dx*&gt;(_STD <span class="built_in">addressof</span>(_Mypair._Get_first()));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// _HAS_STATIC_RTTI</span></span></span><br><span class="line">        (<span class="type">void</span>) _Typeid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _HAS_STATIC_RTTI</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> _Myalty = _Rebind_alloc_t&lt;_Alloc, _Ref_count_resource_alloc&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Destroy() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123; <span class="comment">// destroy managed resource</span></span><br><span class="line">        _Mypair._Get_first()(_Mypair._Myval<span class="number">2.</span>_Myval2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Delete_this() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123; <span class="comment">// destroy self</span></span><br><span class="line">        _Myalty _Al = _Mypair._Myval<span class="number">2.</span>_Get_first();</span><br><span class="line">        <span class="keyword">this</span>-&gt;~_Ref_count_resource_alloc();</span><br><span class="line">        _Deallocate_plain(_Al, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Compressed_pair&lt;_Dx, _Compressed_pair&lt;_Myalty, _Resource&gt;&gt; _Mypair;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><code>std::weak_ptr</code> 是 C++ 标准库中的智能指针，用于解决 <code>std::shared_ptr</code> 的循环引用（circular reference）问题。<code>std::weak_ptr</code> 是一种弱引用，不会增加引用计数，也不会拥有被管理的对象。它通常用于解决由 <code>std::shared_ptr</code> 形成的循环引用导致的内存泄漏问题，简单来说<code>weak_ptr</code>就是用来配合<code>share_ptr</code>一起进行使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::weak_ptr&lt;Person&gt; partner;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; n) : <span class="built_in">name</span>(n) &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is created\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Person&gt; alice = std::<span class="built_in">make_shared</span>&lt;Person&gt;(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    std::shared_ptr&lt;Person&gt; bob = std::<span class="built_in">make_shared</span>&lt;Person&gt;(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    alice-&gt;partner = bob;</span><br><span class="line">    bob-&gt;partner = alice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 weak_ptr 创建 shared_ptr，避免循环引用</span></span><br><span class="line">    std::shared_ptr&lt;Person&gt; alicePartner = alice-&gt;partner.<span class="built_in">lock</span>();</span><br><span class="line">    std::shared_ptr&lt;Person&gt; bobPartner = bob-&gt;partner.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alicePartner &amp;&amp; bobPartner) &#123;</span><br><span class="line">        std::cout &lt;&lt; alice-&gt;name &lt;&lt; <span class="string">&quot;&#x27;s partner is: &quot;</span> &lt;&lt; alicePartner-&gt;name &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; bob-&gt;name &lt;&lt; <span class="string">&quot;&#x27;s partner is: &quot;</span> &lt;&lt; bobPartner-&gt;name &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;One of the partners is no longer available\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过前面<code>share_ptr</code>源码的理解，我们也能猜测<code>weak_ptr</code>是通过控制块中<code>weaks</code>进行控制的，从源码角度来说<code>weak_ptr</code>代码里面应该是对<code>weaks</code>进行控制，当有一个新的<code>weak_ptr</code>指向<code>share_ptr</code>式，<code>weaks</code>数量进行增加，</p><p>所以内存释放来说：</p><ul><li>当<code>Uses</code> 为0时，<code>share_ptr</code>指向资源会进行释放</li><li>当<code>weaks</code>为0时，控制块内存才最终进行了释放</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">weak_ptr</span> : <span class="keyword">public</span> _Ptr_base&lt;_Ty&gt; &#123; <span class="comment">// class for pointer to reference counted resource</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _M_CEE_PURE</span></span><br><span class="line">    <span class="comment">// When a constructor is converting from weak_ptr&lt;_Ty2&gt; to weak_ptr&lt;_Ty&gt;, the below type trait intentionally asks</span></span><br><span class="line">    <span class="comment">// whether it would be possible to static_cast from _Ty* to const _Ty2*; see N4901 [expr.static.cast]/11.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Primary template, the value is used when the substitution fails.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="keyword">class</span> = <span class="type">const</span> _Ty2*&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> _Must_avoid_expired_conversions_from = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Template specialization, the value is used when the substitution succeeds.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span></span><br><span class="line">        _Must_avoid_expired_conversions_from&lt;_Ty2, <span class="keyword">decltype</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> _Ty2*&gt;(<span class="built_in">static_cast</span>&lt;_Ty*&gt;(<span class="literal">nullptr</span>)))&gt; =</span><br><span class="line">            <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _M_CEE_PURE</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">weak_ptr</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">weak_ptr</span>(<span class="type">const</span> weak_ptr&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Weakly_construct_from(_Other); <span class="comment">// same type, no conversion</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">weak_ptr</span>(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Weakly_construct_from(_Other); <span class="comment">// shared_ptr keeps resource alive during conversion</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">weak_ptr</span>(<span class="type">const</span> weak_ptr&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_CEE_PURE</span></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">bool</span> _Avoid_expired_conversions = <span class="literal">true</span>; <span class="comment">// slow, but always safe; avoids error LNK1179</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// _M_CEE_PURE</span></span></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">bool</span> _Avoid_expired_conversions = _Must_avoid_expired_conversions_from&lt;_Ty2&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _M_CEE_PURE</span></span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_Avoid_expired_conversions)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_Weakly_convert_lvalue_avoiding_expired_conversions(_Other);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_Weakly_construct_from(_Other);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">weak_ptr</span>(weak_ptr&amp;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Move_construct_from(_STD <span class="built_in">move</span>(_Other));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">weak_ptr</span>(weak_ptr&lt;_Ty2&gt;&amp;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_CEE_PURE</span></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">bool</span> _Avoid_expired_conversions = <span class="literal">true</span>; <span class="comment">// slow, but always safe; avoids error LNK1179</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// _M_CEE_PURE</span></span></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">bool</span> _Avoid_expired_conversions = _Must_avoid_expired_conversions_from&lt;_Ty2&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _M_CEE_PURE</span></span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_Avoid_expired_conversions)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_Weakly_convert_rvalue_avoiding_expired_conversions(_STD <span class="built_in">move</span>(_Other));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_Move_construct_from(_STD <span class="built_in">move</span>(_Other));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减少weaks引用计数</span></span><br><span class="line">    ~<span class="built_in">weak_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Decwref();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> weak_ptr&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">weak_ptr</span>(_Right).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> weak_ptr&lt;_Ty2&gt;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">weak_ptr</span>(_Right).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span>=(weak_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">weak_ptr</span>(_STD <span class="built_in">move</span>(_Right)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span>=(weak_ptr&lt;_Ty2&gt;&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">weak_ptr</span>(_STD <span class="built_in">move</span>(_Right)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">weak_ptr</span>(_Right).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// release resource, convert to null weak_ptr object</span></span><br><span class="line">        weak_ptr&#123;&#125;.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(weak_ptr&amp; _Other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Swap(_Other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">bool</span> <span class="title">expired</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">use_count</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD shared_ptr&lt;_Ty&gt; <span class="title">lock</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// convert to shared_ptr</span></span><br><span class="line">        shared_ptr&lt;_Ty&gt; _Ret;</span><br><span class="line">        (<span class="type">void</span>) _Ret._Construct_from_weak(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> _Ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="make-unique和make-shared"><a href="#make-unique和make-shared" class="headerlink" title="make_unique和make_shared"></a><code>make_unique</code>和<code>make_shared</code></h2><p>现代C++建议多使用<code>make_unique</code>和<code>make_shared</code>，原因主要是两点</p><ul><li><strong>性能优势</strong>：<code>std::make_shared</code>可以在单个内存分配中<strong>同时分配控制块和对象内存</strong>，而直接使用<code>std::shared_ptr</code>则需要分别进行两次内存分配。这样可以提高内存访问的效率并减少内存碎片。（仅仅针对<code>make_shared</code>）</li><li><strong>异常安全性</strong>：<code>std::make_shared</code>可以确保在内存分配失败时不会泄漏内存，因为它是原子操作，要么成功创建<code>std::shared_ptr</code>，要么不创建，不会出现中间状态。</li></ul><p>第二点异常安全性的解释：</p><p>假设我们有个函数按照某种优先级处理<code>Widget</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw, <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure><br>现在假设我们有一个函数来计算相关的优先级，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">computePriority</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>并且我们在调用<code>processWidget</code>时使用了<code>new</code>而不是<code>std::make_shared</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget),  <span class="comment">//潜在的资源泄漏！</span></span><br><span class="line">              <span class="built_in">computePriority</span>());</span><br></pre></td></tr></table></figure><br>在运行时，一个函数的实参必须先被计算，这个函数再被调用，所以在调用<code>processWidget</code>之前，必须执行以下操作，<code>processWidget</code>才开始执行：</p><ul><li>表达式<code>new Widget</code>必须计算，例如，一个<code>Widget</code>对象必须在堆上被创建</li><li>负责管理<code>new</code>出来指针的<code>std::shared_ptr&lt;Widget&gt;</code>构造函数必须被执行</li><li><code>computePriority</code>必须运行</li></ul><p>编译器不需要按照执行顺序生成代码。<code>new Widget</code>必须在<code>std::shared_ptr</code>的构造函数被调用前执行，因为<code>new</code>出来的结果作为构造函数的实参，但<code>computePriority</code>可能在这之前，之后，或者之间执行。也就是说，编译器可能按照这个执行顺序生成代码：</p><ol><li>执行<code>new Widget</code></li><li>执行<code>computePriority</code></li><li>运行<code>std::shared_ptr</code>构造函数<br>如果按照这样生成代码，并且在运行时<code>computePriority</code>产生了异常，那么第一步动态分配的<code>Widget</code>就会泄漏。因为它永远都不会被第三步的<code>std::shared_ptr</code>所管理了。<br>使用<code>std::make_shared</code>可以防止这种问题。调用代码看起来像是这样：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">make_shared</span>&lt;Widget&gt;(),   <span class="comment">//没有潜在的资源泄漏</span></span><br><span class="line">    <span class="built_in">computePriority</span>());</span><br></pre></td></tr></table></figure>在运行时，<code>std::make_shared</code>和<code>computePriority</code>其中一个会先被调用。如果是<code>std::make_shared</code>先被调用，在<code>computePriority</code>调用前，动态分配<code>Widget</code>的原始指针会安全的保存在作为返回值的<code>std::shared_ptr</code>中。如果<code>computePriority</code>产生一个异常，那么<code>std::shared_ptr</code>析构函数将确保管理的<code>Widget</code>被销毁。如果首先调用<code>computePriority</code>并产生一个异常，那么<code>std::make_shared</code>将不会被调用，因此也就不需要担心动态分配<code>Widget</code>（会泄漏）。<br>当然除了使用<code>std::make_shared&lt;Widget&gt;()</code>，还有其他解法比如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(spw, <span class="built_in">computePriority</span>());  <span class="comment">// 正确，但是没优化，见下</span></span><br></pre></td></tr></table></figure>但是能够一行代码解释清楚最好还是使用一行代码，所以还是建议使用<code>make_shared</code></li></ol><h3 id="make-shared不适用场景"><a href="#make-shared不适用场景" class="headerlink" title="make_shared不适用场景"></a>make_shared不适用场景</h3><ol><li>需要自定义删除器。make函数不能自定义删除器</li><li>需要精确精确的分配、释放对象大小的内存（重载了<code>operator new</code>和<code>operator delete</code>）的类，因为make_shared，因为make_shared使用std::allocate_shared进行内存分配，<code>std::allocate_shared</code>需要的内存总大小不等于动态分配的对象大小，还需要再加上控制块大小</li><li>对于大对象来说，<code>std::weak_ptr</code>s比对应的<code>std::shared_ptr</code>s活得更久的情况也不建议使用make_shared。因为make_shared申请的内存是包括资源和内存块的内容，只有最后一个<code>std::shared_ptr</code>和最后一个指向它的<code>std::weak_ptr</code>已被销毁，整块内存才会释放。而普通的方式创建的<code>shared_ptr</code>，最后一个<code>shared_ptr</code>被销毁就将对象的内存销毁了，控制块的还保留</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReallyBigType</span> &#123; … &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pBigObj =                          <span class="comment">//通过std::make_shared</span></span><br><span class="line">    std::<span class="built_in">make_shared</span>&lt;ReallyBigType&gt;();  <span class="comment">//创建一个大对象</span></span><br><span class="line">                    </span><br><span class="line">…           <span class="comment">//创建std::shared_ptrs和std::weak_ptrs</span></span><br><span class="line">            <span class="comment">//指向这个对象，使用它们</span></span><br><span class="line"></span><br><span class="line">…           <span class="comment">//最后一个std::shared_ptr在这销毁，</span></span><br><span class="line">            <span class="comment">//但std::weak_ptrs还在</span></span><br><span class="line"></span><br><span class="line">…           <span class="comment">//在这个阶段，原来分配给大对象的内存还分配着</span></span><br><span class="line"></span><br><span class="line">…           <span class="comment">//最后一个std::weak_ptr在这里销毁；</span></span><br><span class="line">            <span class="comment">//控制块和对象的内存被释放</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReallyBigType</span> &#123; … &#125;;              <span class="comment">//和之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;ReallyBigType&gt; <span class="title">pBigObj</span><span class="params">(<span class="keyword">new</span> ReallyBigType)</span></span>;</span><br><span class="line">                                        <span class="comment">//通过new创建大对象</span></span><br><span class="line"></span><br><span class="line">…           <span class="comment">//像之前一样，创建std::shared_ptrs和std::weak_ptrs</span></span><br><span class="line">            <span class="comment">//指向这个对象，使用它们</span></span><br><span class="line">            </span><br><span class="line">…           <span class="comment">//最后一个std::shared_ptr在这销毁,</span></span><br><span class="line">            <span class="comment">//但std::weak_ptrs还在；</span></span><br><span class="line">            <span class="comment">//对象的内存被释放</span></span><br><span class="line"></span><br><span class="line">…           <span class="comment">//在这阶段，只有控制块的内存仍然保持分配</span></span><br><span class="line"></span><br><span class="line">…           <span class="comment">//最后一个std::weak_ptr在这里销毁；</span></span><br><span class="line">            <span class="comment">//控制块内存被释放</span></span><br></pre></td></tr></table></figure><h2 id="enable-share-from-this"><a href="#enable-share-from-this" class="headerlink" title="enable_share_from_this"></a>enable_share_from_this</h2><p>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个<strong>std::shared_ptr</strong>对象给外部使用，这个时候我们就需要enable_shared_from_this。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">getShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, this is MyClass!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个std::shared_ptr指向MyClass对象</span></span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用getShared()函数获取指向当前对象的std::shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr2 = ptr-&gt;<span class="built_in">getShared</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用ptr2调用对象的成员函数</span></span><br><span class="line">    ptr2-&gt;<span class="built_in">printMessage</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码分析：</p><p><code>enable_shared_from_this</code>中有一个<code>_Wptr</code>，将<code>_Wptr</code>和<code>this</code>对应的<code>share_ptr</code>进行关联，从而后续通过<code>shared_from_this</code>从此<code>_Wptr</code>得到<code>share_ptr</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">enable_shared_from_this</span> &#123; <span class="comment">// provide member functions that create shared_ptr to this</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在_Can_enable_shared中使用</span></span><br><span class="line">    <span class="keyword">using</span> _Esft_type = enable_shared_from_this;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD shared_ptr&lt;_Ty&gt; <span class="title">shared_from_this</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Ty&gt;(_Wptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD shared_ptr&lt;<span class="type">const</span> _Ty&gt; <span class="title">shared_from_this</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> _Ty&gt;(_Wptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD weak_ptr&lt;_Ty&gt; <span class="title">weak_from_this</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Wptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD weak_ptr&lt;<span class="type">const</span> _Ty&gt; <span class="title">weak_from_this</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Wptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">enable_shared_from_this</span><span class="params">()</span> <span class="keyword">noexcept</span> : _Wptr() &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">enable_shared_from_this</span>(<span class="type">const</span> enable_shared_from_this&amp;) <span class="keyword">noexcept</span> : _Wptr() &#123;</span><br><span class="line">        <span class="comment">// construct (must value-initialize _Wptr)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enable_shared_from_this&amp; <span class="keyword">operator</span>=(<span class="type">const</span> enable_shared_from_this&amp;) <span class="keyword">noexcept</span> &#123; <span class="comment">// assign (must not change _Wptr)</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">enable_shared_from_this</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yty</span>&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">shared_ptr</span>;</span><br><span class="line">    <span class="comment">// 弱指针</span></span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Ty&gt; _Wptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么这个是什么时候将<code>_Wptr</code>和<code>share_ptr</code> 关联的呢？是通过<code>_Set_ptr_rep_and_enable_shared</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Ux* _Px)</span> </span>&#123; <span class="comment">// construct shared_ptr object that owns _Px</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_array_v&lt;_Ty&gt;)</span> </span>&#123;</span><br><span class="line">            _Setpd(_Px, default_delete&lt;_Ux[]&gt;&#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _Temporary_owner&lt;_Ux&gt; _Owner(_Px);</span><br><span class="line">            <span class="comment">// 此函数和enable_share_from_this相关</span></span><br><span class="line">            _Set_ptr_rep_and_enable_shared(_Owner._Ptr, <span class="keyword">new</span> _Ref_count&lt;_Ux&gt;(_Owner._Ptr));</span><br><span class="line">            _Owner._Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>_Set_ptr_rep_and_enable_shared</code>函数中会进行判断，如果是<code>_Can_enable_shared</code>就会关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _Set_ptr_rep_and_enable_shared(_Ux* <span class="type">const</span> _Px, _Ref_count_base* <span class="type">const</span> _Rx) <span class="keyword">noexcept</span> &#123; <span class="comment">// take ownership of _Px</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Ptr = _Px;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Rep = _Rx;</span><br><span class="line">    <span class="comment">//在这个函数中</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(conjunction_v&lt;negation&lt;is_array&lt;_Ty&gt;&gt;, negation&lt;is_volatile&lt;_Ux&gt;&gt;, _Can_enable_shared&lt;_Ux&gt;&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (_Px &amp;&amp; _Px-&gt;_Wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">                <span class="comment">//将_Wptr和shared_ptr关联</span></span><br><span class="line">                _Px-&gt;_Wptr = shared_ptr&lt;<span class="type">remove_cv_t</span>&lt;_Ux&gt;&gt;(*<span class="keyword">this</span>, <span class="keyword">const_cast</span>&lt;<span class="type">remove_cv_t</span>&lt;_Ux&gt;*&gt;(_Px));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>_Can_enable_shared</code>的实现使用了<code>SFINAE</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yty</span>, <span class="keyword">class</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> _Can_enable_shared : false_type &#123;&#125;; <span class="comment">// detect unambiguous and accessible inheritance from enable_shared_from_this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yty</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Can_enable_shared</span>&lt;_Yty, <span class="type">void_t</span>&lt;<span class="keyword">typename</span> _Yty::_Esft_type&gt;&gt;</span><br><span class="line">    : is_convertible&lt;<span class="type">remove_cv_t</span>&lt;_Yty&gt;*, <span class="keyword">typename</span> _Yty::_Esft_type*&gt;::type &#123;</span><br><span class="line">    <span class="comment">// is_convertible is necessary to verify unambiguous inheritance</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>先说结论<strong>智能指针</strong>线程不安全。</p><p><code>share_ptr</code>有两部分指向资源的指针 和指向控制块的指针，其中控制块部分中<strong>引用计数</strong>是原子的操作可以说它是安全的，其他部分都没有保障，比如指针的指向。</p><p>所以智能指针是线程不安全的</p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/share_ptr示意.png" alt=""></p><p>想要对智能指针安全操作可以参考muduo代码：</p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/智能指针多线程1.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/智能指针多线程2.png" alt=""></p><h2 id="智能指针自己的实现"><a href="#智能指针自己的实现" class="headerlink" title="智能指针自己的实现"></a>智能指针自己的实现</h2><h3 id="unique-ptr实现"><a href="#unique-ptr实现" class="headerlink" title="unique_ptr实现"></a>unique_ptr实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KSmartPointUni</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">KSmartPointUni</span>();</span><br><span class="line"><span class="built_in">KSmartPointUni</span>(T* ptr);</span><br><span class="line">~<span class="built_in">KSmartPointUni</span>();</span><br><span class="line"><span class="built_in">KSmartPointUni</span>(KSmartPointUni&amp;&amp; ptr);</span><br><span class="line">KSmartPointUni&amp; <span class="keyword">operator</span>=(KSmartPointUni&amp;&amp; ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">KSmartPointUni</span>(<span class="type">const</span> KSmartPointUni&amp; ptr) = <span class="keyword">delete</span>; <span class="comment">// 不允许拷贝</span></span><br><span class="line">KSmartPointUni&amp; <span class="keyword">operator</span>=(<span class="type">const</span> KSmartPointUni&amp; ptr) = <span class="keyword">delete</span>;</span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="type">const</span>; <span class="comment">// 返回*m_ptr对象</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>; <span class="comment">// 返回m_ptr对象</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> KSmartPointUni&lt;T&gt;::<span class="built_in">KSmartPointUni</span>() :<span class="built_in">m_ptr</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> KSmartPointUni&lt;T&gt;::<span class="built_in">KSmartPointUni</span>(T* ptr) : <span class="built_in">m_ptr</span>(ptr)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> KSmartPointUni&lt;T&gt;::~<span class="built_in">KSmartPointUni</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> KSmartPointUni&lt;T&gt;::<span class="built_in">KSmartPointUni</span>(KSmartPointUni&lt;T&gt;&amp;&amp; ptr)</span><br><span class="line">&#123;</span><br><span class="line">m_ptr = ptr.m_ptr;</span><br><span class="line">ptr.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> KSmartPointUni&lt;T&gt;&amp; KSmartPointUni&lt;T&gt;::<span class="keyword">operator</span>=(KSmartPointUni&amp;&amp; ptr)</span><br><span class="line">&#123;</span><br><span class="line">m_ptr = ptr.m_ptr;</span><br><span class="line">ptr.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> T&amp; KSmartPointUni&lt;T&gt;::<span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> T* KSmartPointUni&lt;T&gt;::<span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="share-ptr的实现"><a href="#share-ptr的实现" class="headerlink" title="share_ptr的实现"></a>share_ptr的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySharedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MySharedPtr</span>(T* ptr = <span class="literal">nullptr</span>); <span class="comment">//构造</span></span><br><span class="line">~<span class="built_in">MySharedPtr</span>(); <span class="comment">// 析构</span></span><br><span class="line"><span class="built_in">MySharedPtr</span>(<span class="type">const</span> MySharedPtr&lt;T&gt;&amp; sp);</span><br><span class="line">MySharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MySharedPtr&lt;T&gt;&amp; sp);</span><br><span class="line">T&amp; <span class="keyword">operator</span>*(); <span class="comment">// 返回*m_ptr对象</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;(); <span class="comment">// 返回m_ptr对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">useCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 采取引用计数</span></span><br><span class="line">T* m_ptr;</span><br><span class="line">    <span class="comment">// 控制块</span></span><br><span class="line"><span class="type">int</span>* m_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> MySharedPtr&lt;T&gt;::<span class="built_in">MySharedPtr</span>(T* ptr) :<span class="built_in">m_ptr</span>(ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">m_count = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m_count = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> MySharedPtr&lt;T&gt;::~<span class="built_in">MySharedPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line">(*m_count)--;</span><br><span class="line"><span class="keyword">if</span> ((*m_count) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line">m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m_count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_count;</span><br><span class="line">m_count = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> MySharedPtr&lt;T&gt;::<span class="built_in">MySharedPtr</span>(<span class="type">const</span> MySharedPtr&lt;T&gt;&amp; sp)</span><br><span class="line">&#123;</span><br><span class="line">m_ptr = sp.m_ptr;</span><br><span class="line">m_count = sp.m_count;</span><br><span class="line">(*m_count)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> MySharedPtr&lt;T&gt;&amp; MySharedPtr&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> MySharedPtr&lt;T&gt;&amp; sp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;sp) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">(*m_count)--;</span><br><span class="line"><span class="keyword">if</span> ((*m_count) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line">m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m_count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_count;</span><br><span class="line">m_count = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m_ptr = sp.m_ptr;</span><br><span class="line">m_count = sp.m_count;</span><br><span class="line">(*m_count)++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> T&amp; MySharedPtr&lt;T&gt;::<span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> T* MySharedPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> MySharedPtr&lt;T&gt;::<span class="built_in">useCount</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *m_count;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> T* MySharedPtr&lt;T&gt;::<span class="built_in">get</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中已经基本不推荐使用裸指针（手动进行&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;），基本上都是使用智能指针。所以作为C++程序员必须学会智能指针的使用：&lt;code&gt;auto_ptr&lt;/code&gt;（已废弃不建议使用）、&lt;code&gt;unique_ptr&lt;/code&gt;、&lt;code&gt;share_ptr&lt;/code&gt;、&lt;code&gt;weak_ptr&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/智能指针思维导图.png&quot; alt=&quot;画板&quot;&gt;&lt;br&gt;</summary>
    
    
    
    <category term="C++" scheme="https://bugcat.top/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>优先使用enum class</title>
    <link href="https://bugcat.top/2024/10/03/C++/%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8enum%20class/"/>
    <id>https://bugcat.top/2024/10/03/C++/%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8enum%20class/</id>
    <published>2024-10-03T21:06:40.000Z</published>
    <updated>2024-10-20T13:34:26.724Z</updated>
    
    <content type="html"><![CDATA[<p>C++中存在<code>enum</code>和<code>enum class</code>两种，现代C++更加建议使用<code>enum class</code>这种。理由主要有三点：</p><ol><li><p><code>enum class</code>作用域更小，可以减少命名空间污染。<code>enum</code>定义后，其中的枚举类作用域是整个<code>enum</code>所在空间，可能对其他部分产生影响。比如</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; black, white, red &#125;;   <span class="comment">//black, white, red在</span></span><br><span class="line">                                    <span class="comment">//Color所在的作用域</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;                 <span class="comment">//错误! white早已在这个作用</span></span><br><span class="line">                                    <span class="comment">//域中声明</span></span><br></pre></td></tr></table></figure></li><li><p><code>enum</code>会发隐式转换，但是<code>enum class</code>不会发生</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; black, white, red &#125;;       <span class="comment">//未限域enum</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::<span class="type">size_t</span>&gt;                <span class="comment">//func返回x的质因子</span></span><br><span class="line">  <span class="built_in">primeFactors</span>(std::<span class="type">size_t</span> x);</span><br><span class="line"></span><br><span class="line">Color c = red;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>) &#123;                         <span class="comment">// Color与double比较 (!)</span></span><br><span class="line">    <span class="keyword">auto</span> factors =                      <span class="comment">// 计算一个Color的质因子(!)</span></span><br><span class="line">      <span class="built_in">primeFactors</span>(c);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; black, white, red &#125;; <span class="comment">//Color现在是限域enum</span></span><br><span class="line"></span><br><span class="line">Color c = Color::red;                   <span class="comment">//和之前一样，只是</span></span><br><span class="line">...                                     <span class="comment">//多了一个域修饰符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>) &#123;                         <span class="comment">//错误！不能比较</span></span><br><span class="line">                                        <span class="comment">//Color和double</span></span><br><span class="line">    <span class="keyword">auto</span> factors =                      <span class="comment">//错误！不能向参数为std::size_t</span></span><br><span class="line">      <span class="built_in">primeFactors</span>(c);                  <span class="comment">//的函数传递Color参数</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>enum class</code><font style="color:rgb(0, 0, 0);">可以被前置声明。前置声明某些情况下可以减少编译依赖。</font></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>;         <span class="comment">//错误！</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>;   <span class="comment">//没问题</span></span><br></pre></td></tr></table></figure><h2 id="enum-class使用"><a href="#enum-class使用" class="headerlink" title="enum class使用"></a><code>enum class</code>使用</h2><ol><li>第一项进行赋值。建议对枚举第一项赋值0，这样可以帮助明确各个枚举项值。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    black=<span class="number">0</span>,</span><br><span class="line">    white,</span><br><span class="line">    red</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>整加count。这个是方便类似<code>vector&lt;int&gt; a(1,Color::count)</code>情况</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    black=<span class="number">0</span>,</span><br><span class="line">    white,</span><br><span class="line">    red,</span><br><span class="line">    count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中存在&lt;code&gt;enum&lt;/code&gt;和&lt;code&gt;enum class&lt;/code&gt;两种，现代C++更加建议使用&lt;code&gt;enum class&lt;/code&gt;这种。理由主要有三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;enum class&lt;/code&gt;作用域更小，可以减少命名空间污染。&lt;code&gt;enum&lt;/code&gt;定义后，其中的枚举类作用域是整个&lt;code&gt;enum&lt;/code&gt;所在空间，可能对其他部分产生影响。比如&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://bugcat.top/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++类中的特殊成员函数</title>
    <link href="https://bugcat.top/2024/09/20/C++/C++%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <id>https://bugcat.top/2024/09/20/C++/C++%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</id>
    <published>2024-09-20T23:21:39.000Z</published>
    <updated>2024-10-20T13:34:26.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-类中的特殊成员函数"><a href="#C-类中的特殊成员函数" class="headerlink" title="C++类中的特殊成员函数"></a>C++类中的特殊成员函数</h1><p>C++类中存在一些特殊的成员函数，编译器通常会自动为我们生成这些函数。然而，在某些情况下，编译器可能不会自动创建这些函数，因此我们需要了解这些函数的生成规则，并做好记录。</p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/C++类中的特殊成员函数.jpeg" alt="画板"><br><span id="more"></span></p><ol><li>默认构造函数。仅当类<strong>不存在用户声明的构造函数时</strong>才自动生成。也就是啥构造函数都没定义，编译器才会自动生成。</li><li>析构函数。编译器总是会被自动生成，除非你自定义了它。</li><li>拷贝构造函数。<ol><li>拷贝构造和拷贝赋值之间是独立的互不干扰，自定义了拷贝赋值运算符，编译器还是会帮我们生成拷贝构造函数（理论上定义了一个拷贝操作，另外一个也应该定义的，目前好像不定义编译还是会生成，但是会生成警告）。定义了一个拷贝操作，另外一个也应该定义的，目前好像不定义编译还是会生成，但是会生成警告）。定义的，目前好像不定义编译还是会生成，但是会生成警告）。不定义编译还是会生成，但是会生成警告）。</li><li>拷贝和移动之间是互斥的，自定义了<strong>移动操作（移动构造函数或移动赋值运算符）</strong>，编译器就不会为你生成拷贝构造函数和拷贝赋值运算符（编译器通过给拷贝操作加上delete来保证）。</li><li>析构函数<strong>不会影响</strong>拷贝操作，自定义了析构函数，编译器还是会为我们生成拷贝构造函数。（理论上按照big_three理论，自定义了析构函数，拷贝操作应该也自定义了，毕竟需要自己进行资源释放，那资源的拷贝也应该需要特殊处理，好像编译器会生成警告）</li></ol></li><li>拷贝赋值运算符。<ol><li>拷贝构造和拷贝赋值之间是独立的互不干扰，自定义了拷贝构造函数，编译器还是会帮我们生成拷贝赋值运算符（理论上定义了一个拷贝操作，另外一个也应该定义的，目前好像不定义编译还是会生成，但是会生成警告）。定义了一个拷贝操作，另外一个也应该定义的，目前好像不定义编译还是会生成，但是会生成警告）。定义的，目前好像不定义编译还是会生成，但是会生成警告）。</li><li>拷贝和移动之间是互斥的，自定义了<strong>移动操作（移动构造函数或移动赋值运算符）</strong>，编译器就不会为我们生成拷贝构造函数和拷贝赋值运算符（编译器通过给拷贝操作加上delete来保证）。</li><li>析构函数<strong>不会影响</strong>拷贝操作，自定义了析构函数，编译器还是会为我们生成拷贝赋值运算符。</li></ol></li><li>移动构造函数。<ol><li>移动操作之间不是独立的，自定义了移动赋值运算符，编译器就不会为我们自动生成移动构造函数。理由：如果你给类声明了，比如，一个移动构造函数，就表明对于移动操作应怎样实现，与编译器应生成的默认逐成员移动有些区别。如果逐成员移动构造有些问题，那么逐成员移动赋值同样也可能有问题。所以声明移动构造函数阻止移动赋值运算符的生成，声明移动赋值运算符同样阻止编译器生成移动构造函数。</li><li>移动和拷贝动作互斥，自定义了任何拷贝操作（拷贝构造活拷贝赋值运算符），编译器就不会为我们生成移动构造或者移动赋值。理由：如果声明拷贝操作（构造或者赋值）就暗示着平常拷贝对象的方法（逐成员拷贝）不适用于该类，编译器会明白如果逐成员拷贝对拷贝操作来说不合适，逐成员移动也可能对移动操作来说不合适。</li><li>析构函数<strong>会影响</strong>移动操作，自定义了析构函数，编译器还是会为我们生成移动构造函数。</li></ol></li><li>移动赋值运算符。<ol><li>移动操作之间不是独立的，自定义了移动构造，编译器就不会为我们自动生成移动赋值运算符。理由同上</li><li>移动和拷贝动作互斥，自定义了任何拷贝操作（拷贝构造活拷贝赋值运算符），编译器就不会为我们生成移动构造或者移动赋值。理由同上</li><li>析构函数<strong>会影响</strong>移动操作，自定义了析构函数，编译器还是会为我们生成移动构造函数。</li></ol></li></ol><p>注意没有“成员函数模版阻止编译器生成特殊成员函数”的规则。这意味着如果Widget是这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">//从任何东西构造Widget</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> T&amp; rhs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">//从任何东西赋值给Widget</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> T&amp; rhs);</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>编译器仍会生成移动和拷贝操作（假设正常生成它们的条件满足），即使可以模板实例化产出拷贝构造和拷贝赋值运算符的函数签名</p><p>除此之外，现代C++还有一个三/五法则，也是对这方面的总结，感兴趣可以去了解一下。<br>参考：</p><p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-170</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C-类中的特殊成员函数&quot;&gt;&lt;a href=&quot;#C-类中的特殊成员函数&quot; class=&quot;headerlink&quot; title=&quot;C++类中的特殊成员函数&quot;&gt;&lt;/a&gt;C++类中的特殊成员函数&lt;/h1&gt;&lt;p&gt;C++类中存在一些特殊的成员函数，编译器通常会自动为我们生成这些函数。然而，在某些情况下，编译器可能不会自动创建这些函数，因此我们需要了解这些函数的生成规则，并做好记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/C++类中的特殊成员函数.jpeg&quot; alt=&quot;画板&quot;&gt;&lt;br&gt;</summary>
    
    
    
    <category term="C++" scheme="https://bugcat.top/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>decltype类型推导</title>
    <link href="https://bugcat.top/2024/09/01/C++/decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
    <id>https://bugcat.top/2024/09/01/C++/decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</id>
    <published>2024-09-01T22:18:21.000Z</published>
    <updated>2024-10-20T13:34:26.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="decltype类型推导"><a href="#decltype类型推导" class="headerlink" title="decltype类型推导"></a>decltype类型推导</h1><p><code>decltype</code>可以推导出变量或者表达式的类型，比如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; y = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用decltype获取变量的类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(x) a = <span class="number">10</span>; <span class="comment">// a的类型为int</span></span><br><span class="line">    <span class="keyword">decltype</span>(y) b = x; <span class="comment">// b的类型为const int&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用decltype获取表达式的类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(x + a) c = x + a; <span class="comment">// c的类型为int</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><span id="more"></span><br>平时自己使用<code>decltype</code>最多的时候是和lambda进行配合，推导lambda的类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用lambda表达式定义比较器，按元素的绝对值从小到大排序</span></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">abs</span>(a) &lt; std::<span class="built_in">abs</span>(b);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在std::set中使用自定义的比较器</span></span><br><span class="line">    <span class="function">std::set&lt;<span class="type">int</span>, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">mySet</span><span class="params">(cmp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一些元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">-5</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">-2</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排序后的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><p>学习之后发现<code>decltype</code>主要作用是和<code>auto</code>一起对<strong>函数模板返回值类型</strong>进行推导<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数模板，返回两个参数的和（C++14）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"> <span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">add</span><span class="params">(T a, U b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="auto和decltype的区别"><a href="#auto和decltype的区别" class="headerlink" title="auto和decltype的区别"></a>auto和decltype的区别</h3><p>这里只说auto和decltype推导函数模板返回值类型的区别</p><ul><li>auto推导返回值类型，走的是模板类型推导的一套规则，推导过程中引用性会被忽略</li><li>decltype推导可以保留引用特性</li></ul><p>（书中例子）比如：现在需要一个函数，一个形参为容器，一个形参为索引值，这个函数支持使用方括号的方式（也就是使用“<code>[]</code>”）访问容器中指定索引值的数据，然后在返回索引操作的结果前执行认证用户操作。<br>使用auto<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//C++14版本，</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];                                <span class="comment">//从c[i]中推导返回类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用auto进行推导的话，编译器使用的是模板类型推导的规则，容器<code>[]</code>返回类型为<code>T&amp;</code>，<code>T&amp;</code>进行推导时引用性被忽略，最终返回值类型被推导为<code>T</code>。<br>这样的话，下面这种类型代码就编译不过，有点和容器<code>[]</code>使用相悖<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">…</span><br><span class="line"><span class="built_in">authAndAccess</span>(d, <span class="number">5</span>) = <span class="number">10</span>;               <span class="comment">//认证用户，返回d[5]，</span></span><br><span class="line">                                        <span class="comment">//然后把10赋值给它</span></span><br><span class="line">                                        <span class="comment">//无法通过编译器！</span></span><br></pre></td></tr></table></figure><br>但是如果使用decltype进行推导，可以保留初始化表达式的所有属性，所以返回值类型被推导为<code>T&amp;</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//C++14版本，</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>当然目前authAndAccess 还不是最完美的，因为authAndAccess目前没有办法接受右值，下面的调用方式明显就不能使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::deque&lt;std::string&gt; <span class="title">makeStringDeque</span><span class="params">()</span></span>;      <span class="comment">//工厂函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从makeStringDeque中获得第五个元素的拷贝并返回</span></span><br><span class="line"><span class="keyword">auto</span> s = <span class="built_in">authAndAccess</span>(<span class="built_in">makeStringDeque</span>(), <span class="number">5</span>);</span><br></pre></td></tr></table></figure><br>所以最完美的authAndAccess编写方式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//最终的C++14版本</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><p>decltype会将表达式推导为引用，所以对于表达式<code>(x)</code>，就会出现下面的奇葩情形<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) <span class="comment">//int 类型</span></span><br><span class="line"><span class="keyword">decltype</span>((x))<span class="comment">//int&amp;类型</span></span><br></pre></td></tr></table></figure><br>从而出现这种情况<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">return</span> x;                            <span class="comment">//decltype(x）是int，所以f1返回int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (x);                          <span class="comment">//decltype((x))是int&amp;，所以f2返回int&amp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这种情况需要注意</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;decltype类型推导&quot;&gt;&lt;a href=&quot;#decltype类型推导&quot; class=&quot;headerlink&quot; title=&quot;decltype类型推导&quot;&gt;&lt;/a&gt;decltype类型推导&lt;/h1&gt;&lt;p&gt;&lt;code&gt;decltype&lt;/code&gt;可以推导出变量或者表达式的类型，比如&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;amp; y = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 使用decltype获取变量的类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;decltype&lt;/span&gt;(x) a = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// a的类型为int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;decltype&lt;/span&gt;(y) b = x; &lt;span class=&quot;comment&quot;&gt;// b的类型为const int&amp;amp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 使用decltype获取表达式的类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;decltype&lt;/span&gt;(x + a) c = x + a; &lt;span class=&quot;comment&quot;&gt;// c的类型为int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;a: &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;b: &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;c: &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;</summary>
    
    
    
    <category term="C++" scheme="https://bugcat.top/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>auto类型推导</title>
    <link href="https://bugcat.top/2024/08/26/C++/auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
    <id>https://bugcat.top/2024/08/26/C++/auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</id>
    <published>2024-08-26T23:09:44.000Z</published>
    <updated>2024-10-20T13:34:26.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="auto类型推导"><a href="#auto类型推导" class="headerlink" title="auto类型推导"></a>auto类型推导</h1><h2 id="推导规则"><a href="#推导规则" class="headerlink" title="推导规则"></a>推导规则</h2><p>auto类型推导和模板类型大致相同，分为三种类型<br><span id="more"></span></p><ul><li><p>类型说明符是一个指针或引用但不是通用引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                </span><br><span class="line"><span class="keyword">auto</span> &amp; rx=x;             <span class="comment">//rx是非通用引用，rx推导为int &amp;</span></span><br></pre></td></tr></table></figure></li><li><p>情景二：类型说明符一个通用引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x;  <span class="comment">//x是int左值，</span></span><br><span class="line">                    <span class="comment">//所以uref1类型为int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = <span class="number">27</span>;<span class="comment">//27是int右值，</span></span><br><span class="line">                    <span class="comment">//所以uref3类型为int&amp;&amp;</span></span><br></pre></td></tr></table></figure></li><li><p>情景三：类型说明符既不是指针也不是引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = <span class="number">27</span>;    <span class="comment">//y 推导为int </span></span><br></pre></td></tr></table></figure><p>vs2022代码运行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp; rx = x;             <span class="comment">//rx是非通用引用，rx推导为int &amp;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;rx = &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(rx)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x;         <span class="comment">//x是int左值，所以uref1类型为int&amp;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;uref1 = &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(uref1)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = <span class="number">27</span>;    <span class="comment">//27是int右值，所以uref3类型为int&amp;&amp;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;uref2 = &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(uref2)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">27</span>;            <span class="comment">//y 推导为int </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;y = &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(y)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/auto类型推导.png" alt="1723387016585.png"><br>这部分内容可以去查看 <a href="https://bugcat.top/2024/08/10/C++/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/">模板类型推导的总结</a></p><h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p><code>auto</code>和 模板推导不同的地方的地方是： auto类型推导假定花括号表示<code>std::initializer_list</code>，而模板类型推导不会这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;;         <span class="comment">//x的类型是std::initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;            <span class="comment">//带有与x的声明等价的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;                <span class="comment">//形参声明的模板</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;);               <span class="comment">//错误！不能推导出T</span></span><br></pre></td></tr></table></figure><p>此外，C++14还允许auto 推导函数返回值，lambda函数也允许在形参声明中使用<code>auto</code>，不过虽然用了auto关键字，但是底层还是<strong>模板类型推导</strong>的那一套规则在工作，所以也不能推导出 “花括号表示<code>std::initializer_list</code>”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createInitList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;         <span class="comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> resetV = </span><br><span class="line">    [&amp;v](<span class="type">const</span> <span class="keyword">auto</span>&amp; newValue)&#123; v = newValue; &#125;;        <span class="comment">//C++14</span></span><br><span class="line"><span class="built_in">resetV</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);            <span class="comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;auto类型推导&quot;&gt;&lt;a href=&quot;#auto类型推导&quot; class=&quot;headerlink&quot; title=&quot;auto类型推导&quot;&gt;&lt;/a&gt;auto类型推导&lt;/h1&gt;&lt;h2 id=&quot;推导规则&quot;&gt;&lt;a href=&quot;#推导规则&quot; class=&quot;headerlink&quot; title=&quot;推导规则&quot;&gt;&lt;/a&gt;推导规则&lt;/h2&gt;&lt;p&gt;auto类型推导和模板类型大致相同，分为三种类型&lt;br&gt;</summary>
    
    
    
    <category term="C++" scheme="https://bugcat.top/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>模板类型推导</title>
    <link href="https://bugcat.top/2024/08/10/C++/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
    <id>https://bugcat.top/2024/08/10/C++/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</id>
    <published>2024-08-10T22:02:57.000Z</published>
    <updated>2024-10-20T13:34:26.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板类型推导"><a href="#模板类型推导" class="headerlink" title="模板类型推导"></a>模板类型推导</h1><p>写了这么久C++都没思考过模板推导的相关内容，这次学习Effective Modern C++记录一下<br>已知模板函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(expr);                        <span class="comment">//使用表达式调用f</span></span><br></pre></td></tr></table></figure><br>在编译期间，编译器使用<code>expr</code>进行两个类型推导：一个是针对<code>T</code>的，另一个是针对<code>ParamType</code>的。这两个类型通常是不同的，因为<code>ParamType</code>包含一些修饰，比如<code>const</code>和引用修饰符<br>如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;         <span class="comment">//ParamType是const T&amp;</span></span><br></pre></td></tr></table></figure><br>所以根据<code>ParamType</code>的类型存在三种情况：<br><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导分类.jpeg" alt=""><br><span id="more"></span></p><h2 id="ParamType是指针或者引用（非通用引用）"><a href="#ParamType是指针或者引用（非通用引用）" class="headerlink" title="ParamType是指针或者引用（非通用引用）"></a>ParamType是指针或者引用（非通用引用）</h2><p>规则：</p><ol><li><strong>如果</strong><code>expr</code><strong>的类型是一个引用，忽略引用部分</strong></li><li><p>然后<code>expr</code>的类型与<code>ParamType</code>进行模式匹配来决定<code>T</code></p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;               <span class="comment">//param是一个引用</span></span><br><span class="line"><span class="built_in">f</span>(expr);  </span><br></pre></td></tr></table></figure><p>在这里<code>ParamType</code>是<code>T&amp;</code>也就是引用类型，并且param一定是个引用，但是得看是const &amp;还是非const &amp;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">27</span>;                       <span class="comment">//x是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx=x;                 <span class="comment">//cx是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx=x;                <span class="comment">//rx是指向作为const int的x的引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br></pre></td></tr></table></figure></li><li><p><code>int x 和 f(x)</code>推导出T是int，param的类型是int&amp;。这个很好理解，因为本来就是T&amp;，生成的模板函数肯定也是带引用的，int就推出int</p></li><li><code>const int cx 和 f(x)</code>推导出T是const int，param的类型是int&amp;。这个也好理解和合理，因为用户向f传入const对象时就是想对象保持不可改变性，编译器自然也要满足这种需求，所以也带const</li><li><code>const int&amp; rx 和 f(x)</code>推导出T是const int，param的类型是const int&amp;。这个符合第一点要求，引用部分被忽略，忽略后结果和2相同</li></ol><p>测试：<br>在vs2022上写代码使用boost库里面的type_id_with_cvr进行测试<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示T</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T =     &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示param类型</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;param = &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                       <span class="comment">//x是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;                 <span class="comment">//cx是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;                <span class="comment">//rx是指向作为const int的x的引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导运行结果1.png" alt="1723219601030.png"><br>此外，如果ParamType是<code>const T&amp;</code>时，情况会有一些不同，但是情况和上面类似，不细讲<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;         <span class="comment">//param现在是reference-to-const</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                     <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;               <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;              <span class="comment">//如之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T是int，param的类型是const int&amp;</span></span><br></pre></td></tr></table></figure></p><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>引用是另类的指针，理解上面引用后，指针也好理解，只要注意const会保持就行<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;               <span class="comment">//param现在是指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                     <span class="comment">//同之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *px = &amp;x;             <span class="comment">//px是指向作为const int的x的指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&amp;x);                          <span class="comment">//T是int，param的类型是int*</span></span><br><span class="line"><span class="built_in">f</span>(px);                          <span class="comment">//T是const int，param的类型是const int*</span></span><br></pre></td></tr></table></figure><br>vs2022 上运行结果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示T</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T =     &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示param类型</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;param = &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                       <span class="comment">//x是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;                 <span class="comment">//cx是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;                <span class="comment">//rx是指向作为const int的x的引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导运行结果2.png" alt="1723220710506.png"></p><h2 id="ParamType是通用引用"><a href="#ParamType是通用引用" class="headerlink" title="ParamType是通用引用"></a>ParamType是通用引用</h2><p>通用引用是universal Reference翻译过来的，也有叫万能引用的，形式上和右值引用一样（&amp;&amp;），第一次接触这玩意还是实习的时候师兄跟我讲的，后面就回去了解了一下。这里默认大伙已经了解左值右值哈。<br>规则：</p><ol><li>如果<code>expr</code>是左值，<code>T</code>和<code>ParamType</code>都会被推导为左值引用。需要注意的是<strong>右值引用</strong>也是左值（T唯一一种被推导为引用的情况）</li><li><p>如果<code>expr</code>是右值，就有点类似上面的内容（右值版推导）</p><ol><li>如果<code>expr</code>的类型是一个引用，忽略引用部分</li><li>然后<code>expr</code>的类型与<code>ParamType</code>进行模式匹配来决定<code>T</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;              <span class="comment">//param现在是一个通用引用类型</span></span><br><span class="line"><span class="built_in">f</span>(expr)</span><br></pre></td></tr></table></figure>这里ParamType是T&amp;&amp; ，param最终一定是个引用，但是得看是左值引用&amp; 还是右值&amp;&amp;<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">27</span>;                       <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx=x;                 <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; rx=cx;              <span class="comment">//如之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//x是左值，所以T是int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//cx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//rx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(x));                <span class="comment">// 右值引用也是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);                          <span class="comment">//27是右值，所以T是int，</span></span><br><span class="line">                                <span class="comment">//param类型就是int&amp;&amp;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p><code>int x 和 f(x)</code>推导出T是int &amp;，param的类型是int&amp;。模板函数应该是这样void f(int&amp; &amp;&amp; param)，，然后通过引用折叠变成void(int&amp; param)  </p></li><li><code>const int cx 和 f(x)</code>推导出T是const int&amp;，param的类型是int&amp;。同上,不过加了const。</li><li><code>const int&amp; rx 和 f(x)</code>推导出T是const int&amp;，param的类型是const int&amp;。同上</li><li><code>27 和 f(27)</code>推导出T是int，param的类型是int&amp;&amp;。模板函数是这样void(int&amp;&amp; param)，使得f可以接受右值进行传入</li></ol><p>说实话这个通用引用还挺奇妙，最终f可以接受所有值进行传入。<br>代码和运行结果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示T</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T =     &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示param类型</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;param = &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                       <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;                 <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = cx;              <span class="comment">//如之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//x是左值，所以T是int&amp;，</span></span><br><span class="line">                                        <span class="comment">//param类型也是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//cx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                    <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//rx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                    <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(x));                <span class="comment">// 右值引用也是左值，所以T是const int&amp;，</span></span><br><span class="line">                                    <span class="comment">//param类型也是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);                          <span class="comment">//27是右值，所以T是int，</span></span><br><span class="line">                                    <span class="comment">//param类型就是int&amp;&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导运行结果3.png" alt="1723258751479.png"></p><h2 id="ParamType既不是指针也不是引用"><a href="#ParamType既不是指针也不是引用" class="headerlink" title="ParamType既不是指针也不是引用"></a>ParamType既不是指针也不是引用</h2><p>大白话值传递<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;                <span class="comment">//以传值的方式处理param</span></span><br><span class="line"><span class="built_in">f</span>(expr)</span><br></pre></td></tr></table></figure><br>规则：</p><ol><li>和之前一样，如果<code>expr</code>的类型是一个引用，忽略这个引用部分</li><li>如果忽略<code>expr</code>的引用性（reference-ness）之后，<code>expr</code>是一个<code>const</code>，那就再忽略<code>const</code>。如果它是<code>volatile</code>，也忽略<code>volatile</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                       <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;                 <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = cx;              <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* px = &amp;x;             <span class="comment">//px是指向作为const int的x的指针</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> px1 = &amp;x;             </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> px2 = &amp;x;      </span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(&amp;x);                          <span class="comment">//T和param的类型都是int*</span></span><br><span class="line"><span class="built_in">f</span>(px);                          <span class="comment">//T和param的类型都是cosnt int*</span></span><br><span class="line"><span class="built_in">f</span>(px1);                         <span class="comment">//T和param的类型都是 int*</span></span><br><span class="line"><span class="built_in">f</span>(px2);                         <span class="comment">//T和param的类型都是cosnt int*</span></span><br></pre></td></tr></table></figure>指针可能有些不一样，const <em>指针传进去，推导出来还是const </em>，但是 *const传进去const特性会被忽略，也就是说指针是可以更改指向的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示T</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T =     &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示param类型</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;param = &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                       <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;                 <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = cx;              <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* px = &amp;x;             <span class="comment">//px是指向作为const int的x的指针</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> px1 = &amp;x;             </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> px2 = &amp;x;      </span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(&amp;x);                          <span class="comment">//T和param的类型都是int*</span></span><br><span class="line"><span class="built_in">f</span>(px);                          <span class="comment">//T和param的类型都是cosnt int*</span></span><br><span class="line"><span class="built_in">f</span>(px1);                         <span class="comment">//T和param的类型都是 int*</span></span><br><span class="line"><span class="built_in">f</span>(px2);                         <span class="comment">//T和param的类型都是cosnt int*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导运行结果4.png" alt="1723264877921.png"><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>存在一些特列，记录一下<h3 id="数组实参"><a href="#数组实参" class="headerlink" title="数组实参"></a>数组实参</h3>一般来说，数组传参时是退化为指针，推导的时候也应该影响不大<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;                <span class="comment">//以传值的方式处理param</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>;     <span class="comment">//name的类型是const char[13]</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptrToName = name;          <span class="comment">//数组退化为指针</span></span><br><span class="line"><span class="built_in">f</span>(name);<span class="comment">//name是一个数组，但是T被推导为const char*</span></span><br><span class="line"><span class="built_in">f</span>(ptrToName);</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导运行结果5.png" alt="1723267302280.png"><br>但是在ParamType作为引用时，就可以有指向数组的引用了，并且可以获得数组的大小<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;                       <span class="comment">//传引用形参的模板</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>;     <span class="comment">//name的类型是const char[13]</span></span><br><span class="line"><span class="built_in">f</span>(name);                        <span class="comment">//name是一个数组，但是T被推导为const char (&amp;)[13]</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示T</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T =     &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示param类型</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;param = &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>;     <span class="comment">//name的类型是const char[13]</span></span><br><span class="line"><span class="built_in">f</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导运行结果6.png" alt="1723297363366.png"><br>应用：<br>编译器就可以获得数组大小，不过sizeof好像也可以<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在编译期间返回一个数组大小的常量值（//数组形参没有名字，</span></span><br><span class="line"><span class="comment">//因为我们只关心数组的大小）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;                     <span class="comment">//关于</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> <span class="keyword">noexcept</span>      <span class="comment">//constexpr</span></span></span><br><span class="line"><span class="function"></span>&#123;                                                       <span class="comment">//和noexcept</span></span><br><span class="line">    <span class="keyword">return</span> N;                                           <span class="comment">//的信息</span></span><br><span class="line">&#125;                                                       <span class="comment">//请看下面</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> keyVals[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">35</span> &#125;;             <span class="comment">//keyVals有七个元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mappedVals[<span class="built_in">arraySize</span>(keyVals)];                     <span class="comment">//mappedVals也有七个</span></span><br></pre></td></tr></table></figure><h3 id="函数实参"><a href="#函数实参" class="headerlink" title="函数实参"></a>函数实参</h3>函数和数组类似，都会退化为指针<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;         <span class="comment">//someFunc是一个函数，</span></span><br><span class="line">                                    <span class="comment">//类型是void(int, double)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;                   <span class="comment">//传值给f1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T &amp; param)</span></span>;                 <span class="comment">//传引用给f2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(someFunc);                       <span class="comment">//param被推导为指向函数的指针，</span></span><br><span class="line">                                    <span class="comment">//类型是void(*)(int, double)</span></span><br><span class="line"><span class="built_in">f2</span>(someFunc);                       <span class="comment">//param被推导为指向函数的引用，</span></span><br><span class="line">                                    <span class="comment">//类型是void(&amp;)(int, double)</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;模板类型推导&quot;&gt;&lt;a href=&quot;#模板类型推导&quot; class=&quot;headerlink&quot; title=&quot;模板类型推导&quot;&gt;&lt;/a&gt;模板类型推导&lt;/h1&gt;&lt;p&gt;写了这么久C++都没思考过模板推导的相关内容，这次学习Effective Modern C++记录一下&lt;br&gt;已知模板函数：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ParamType param)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;f&lt;/span&gt;(expr);                        &lt;span class=&quot;comment&quot;&gt;//使用表达式调用f&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;在编译期间，编译器使用&lt;code&gt;expr&lt;/code&gt;进行两个类型推导：一个是针对&lt;code&gt;T&lt;/code&gt;的，另一个是针对&lt;code&gt;ParamType&lt;/code&gt;的。这两个类型通常是不同的，因为&lt;code&gt;ParamType&lt;/code&gt;包含一些修饰，比如&lt;code&gt;const&lt;/code&gt;和引用修饰符&lt;br&gt;如：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; T&amp;amp; param)&lt;/span&gt;&lt;/span&gt;;         &lt;span class=&quot;comment&quot;&gt;//ParamType是const T&amp;amp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;所以根据&lt;code&gt;ParamType&lt;/code&gt;的类型存在三种情况：&lt;br&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导分类.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;</summary>
    
    
    
    <category term="C++" scheme="https://bugcat.top/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="https://bugcat.top/2023/09/03/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/9.%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://bugcat.top/2023/09/03/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/9.%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2023-09-03T14:00:27.000Z</published>
    <updated>2024-10-20T13:34:26.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><span id="more"></span><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/算法学习/01背包.png" alt="01背包"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;              <span class="comment">// 物品总数</span></span><br><span class="line"><span class="type">int</span> m;              <span class="comment">// 背包容量</span></span><br><span class="line"><span class="type">int</span> W[n<span class="number">+1</span>];           <span class="comment">// 重量 </span></span><br><span class="line"><span class="type">int</span> V[n<span class="number">+1</span>];           <span class="comment">// 价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------二维形式---------------</span></span><br><span class="line"><span class="type">int</span> f[n<span class="number">+1</span>][m<span class="number">+1</span>];    <span class="comment">// f[i][j]表示在考虑前i个物品后，背包容量为j条件下的最大价值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; W[i]) </span><br><span class="line">        <span class="comment">//  当前重量装不进，价值等于前i-1个物品</span></span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];      </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">// 能装，需判断  </span></span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i<span class="number">-1</span>][j-W[i]] + V[i]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[n][m];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------一维形式---------------</span></span><br><span class="line"><span class="type">int</span> f[m<span class="number">+1</span>];   <span class="comment">// f[j]表示背包容量为j条件下的最大价值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = M; j &gt;= W[i]; --j)</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - W[i]] + V[i]);           <span class="comment">// 注意是倒序，否则出现写后读错误</span></span><br><span class="line">cout &lt;&lt; f[m];           <span class="comment">// 注意是m不是n</span></span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/questionTerminal/708f0442863a46279cce582c4f508658">牛客01背包</a></p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><script type="math/tex; mode=display">f(i,j)=max{f(i−1,j),f(i−1,j−vi)+wi,f(i−1,j−2vi)+2wi,⋯,f(i−1,j−kvi)+kwi}</script><script type="math/tex; mode=display">f(i,j−vi)=max{f(i−1,j−vi),f(i−1,j−2vi)+wi,f(i−1,j−3vi)+2wi,⋯,f(i−1,j−kvi)+(k−1)wi}</script><script type="math/tex; mode=display">f(i,j−vi)+wi=max{f(i−1,j−vi)+w,f(i−1,j−2vi)+2wi,f(i−1,j−3vi)+3wi,⋯,f(i−1,j−kvi)+kwi}</script><p>所以</p><script type="math/tex; mode=display">f(i,j)=max{f(i−1,j),f(i,j−vi)+wi}</script><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/算法学习/完全背包.png" alt="完全背包"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;              <span class="comment">// 物品总数</span></span><br><span class="line"><span class="type">int</span> m;              <span class="comment">// 背包容量</span></span><br><span class="line"><span class="type">int</span> W[n<span class="number">+1</span>];           <span class="comment">// 重量 </span></span><br><span class="line"><span class="type">int</span> V[m<span class="number">+1</span>];           <span class="comment">// 价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------二维形式---------------</span></span><br><span class="line"><span class="comment">// 未优化</span></span><br><span class="line"><span class="type">int</span> f[n<span class="number">+1</span>][m<span class="number">+1</span>];    <span class="comment">// f[i][j]表示在考虑前i个物品后，背包容量为j条件下的最大价值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * W[i] &lt;= j; k++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * W[i]] + k * V[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 已优化</span></span><br><span class="line"><span class="type">int</span> f[n<span class="number">+1</span>][m<span class="number">+1</span>];    <span class="comment">// f[i][j]表示在考虑前i个物品后，背包容量为j条件下的最大价值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        <span class="keyword">if</span>(j &lt; W[i]) f[i][j] = f[i<span class="number">-1</span>][j];   <span class="comment">//  当前重量装不进，价值等于前i-1个物品   </span></span><br><span class="line">        <span class="keyword">else</span> f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i][j-W[i]] + V[i]); <span class="comment">// 能装，需判断  </span></span><br><span class="line">cout &lt;&lt; f[n][m];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------一维形式---------------</span></span><br><span class="line"><span class="type">int</span> f[m<span class="number">+1</span>];   <span class="comment">// f[j]表示背包容量为j条件下的最大价值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = W[i]; j &lt;= m; ++j)</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - W[i]] + V[i]);           <span class="comment">// 注意是倒序，否则出现写后读错误</span></span><br><span class="line">cout &lt;&lt; f[m<span class="number">+1</span>];           <span class="comment">// 注意是m不是n</span></span><br></pre></td></tr></table></figure><br><a href="https://www.acwing.com/problem/content/description/3/">完全背包题目</a></p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>多重背包可以转化为01背包然后使用二进制优化进行优化。<br>朴素做法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;              <span class="comment">// 物品总数</span></span><br><span class="line"><span class="type">int</span> m;              <span class="comment">// 背包容量</span></span><br><span class="line"><span class="type">int</span> W[n<span class="number">+1</span>];           <span class="comment">// 重量 </span></span><br><span class="line"><span class="type">int</span> V[n<span class="number">+1</span>];           <span class="comment">// 价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------未优化（完全背包模板）----------------------</span></span><br><span class="line"><span class="type">int</span> f[n<span class="number">+1</span>][m+!];    <span class="comment">// f[i][j]表示在考虑前i个物品后，背包容量为j条件下的最大价值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= S[i] &amp;&amp; k * W[i] &lt;= j; k++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * W[i]] + k * V[i]);</span><br></pre></td></tr></table></figure><br>二进制优化原理<br>我们用$A_{i,j}$ 代表第 $i$ 种物品拆分出的第 $j$ 个物品。</p><p>在朴素的做法中，$\forall j\le k<em>i，A</em>{i,j}$ 均表示相同物品。那么我们效率低的原因主要在于我们进行了大量重复性的工作。举例来说，我们考虑了「同时选 $A<em>{i,1},A</em>{i,2}$」与「同时选 $A<em>{i,2},A</em>{i,3}$」这两个完全等效的情况。这样的重复性工作我们进行了许多次。那么优化拆分方式就成为了解决问题的突破口。<br>具体地说就是令 $A_{i,j}\left(j\in\left[0,\lfloor \log_2(k_i+1)\rfloor-1\right]\right)$ 分别表示由 $2^{j}$ 个单个物品「捆绑」而成的大物品。特殊地，若 $k_i+1$ 不是 2 的整数次幂，则需要在最后添加一个由 $k_i-2^{\lfloor \log_2(k_i+1)\rfloor-1}$ 个单个物品「捆绑」而成的大物品用于补足。<br>举几个例子：<br>6=1+2+3<br>8=1+2+4+1<br>18=1+2+4+8+3<br>31=1+2+4+8+16<br>显然，通过上述拆分方式，可以表示任意 $\le k_i$ 个物品的等效选择方式。将每种物品按照上述方式拆分后，使用 0-1 背包的方法解决即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读入物品个数时顺便打包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 输入 价值、体积、数量</span></span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;      <span class="comment">// 当前包裹大小</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt;= s)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt ++ ;            <span class="comment">// 实际物品种数</span></span><br><span class="line">        W[cnt] = a * k;</span><br><span class="line">        V[cnt] = b * k;</span><br><span class="line">        s -= k;</span><br><span class="line">        k *= <span class="number">2</span>;             <span class="comment">// 倍增包裹大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不足的单独放一个，即C</span></span><br><span class="line">        cnt ++ ;</span><br><span class="line">        W[cnt] = a * s;</span><br><span class="line">        V[cnt] = b * s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">n = cnt;        <span class="comment">// 更新物品种数</span></span><br><span class="line"><span class="comment">// 转换成01背包问题</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= W[i]; j -- )</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - W[i]] + V[i]);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[m] &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><p>起始就是对每个组进行01背包<br>$f(i,j)=max{f(i−1,j),f(i−1,j−v(i,k))+w(i,k)}$<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;              <span class="comment">// 物品总数</span></span><br><span class="line"><span class="type">int</span> m;              <span class="comment">// 背包容量</span></span><br><span class="line"><span class="type">int</span> W[n<span class="number">+1</span>][s<span class="number">+1</span>];         <span class="comment">// 重量 </span></span><br><span class="line"><span class="type">int</span> V[n<span class="number">+1</span>][s<span class="number">+1</span>];         <span class="comment">// 价值</span></span><br><span class="line"><span class="type">int</span> S[n<span class="number">+1</span>];           <span class="comment">// 各组物品种数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读入数据</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"> &#123;</span><br><span class="line">     cin &gt;&gt; S[i];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= S[i]; j ++ )</span><br><span class="line">         cin &gt;&gt; W[i][j] &gt;&gt; V[i][j];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">1</span>; j -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= S[i]; k ++ )</span><br><span class="line">            <span class="keyword">if</span> (W[i][k] &lt;= j)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - W[i][k]] + V[i][k]);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[m] &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背包问题&quot;&gt;&lt;a href=&quot;#背包问题&quot; class=&quot;headerlink&quot; title=&quot;背包问题&quot;&gt;&lt;/a&gt;背包问题&lt;/h1&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://bugcat.top/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="acwing算法学习" scheme="https://bugcat.top/tags/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="背包问题" scheme="https://bugcat.top/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>区间合并</title>
    <link href="https://bugcat.top/2023/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/8.%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <id>https://bugcat.top/2023/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/8.%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</id>
    <published>2023-08-06T22:01:56.000Z</published>
    <updated>2024-10-20T13:34:26.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><p>给定多个区间，将有重叠的合并到一起<br><span id="more"></span></p><ol><li>按区间的左端点排序；</li><li>从左到右扫描，维护一个当前区间（随着遍历，若相交则区间变长）</li><li>每次遍历的区间和当前区间有三种情况分类讨论：<ul><li>右端点小于当前区间右端点，当前区间不变；</li><li>右端点大于当前区间右端点，当前区间变长；</li><li>左端点大于当前区间右端点，将该区间置为当前区间；</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/merge-intervals/description/">合并区间</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;区间合并&quot;&gt;&lt;a href=&quot;#区间合并&quot; class=&quot;headerlink&quot; title=&quot;区间合并&quot;&gt;&lt;/a&gt;区间合并&lt;/h1&gt;&lt;p&gt;给定多个区间，将有重叠的合并到一起&lt;br&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://bugcat.top/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="acwing算法学习" scheme="https://bugcat.top/tags/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="区间合并" scheme="https://bugcat.top/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>区间和</title>
    <link href="https://bugcat.top/2023/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/7.%E5%8C%BA%E9%97%B4%E5%92%8C/"/>
    <id>https://bugcat.top/2023/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/7.%E5%8C%BA%E9%97%B4%E5%92%8C/</id>
    <published>2023-08-06T21:35:14.000Z</published>
    <updated>2024-10-20T13:34:26.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h1><p>这个区间和思想和之前的前缀和思想有相同之处，区别在于这个区间和是离散化的，在一个较大的区间中，多数元素为0，少部分有数据，求这部分区间和。<br><span id="more"></span></p><ol><li>首先取操作涉及的下标，即将要存数字的下标与求和范围两端的下标，存入小数组q中;</li><li>对数组q排序;</li><li>重新创建一个大小与q相同的数组s，从数组q中找到对应大数组要存入数据的位置映射，在s相同位置存入数据（q中找映射可以用二分法）;</li><li>找大数组求和范围两端点在q中的映射位置，在数组s对应映射位置求和即可，可用前缀和.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;区间和&quot;&gt;&lt;a href=&quot;#区间和&quot; class=&quot;headerlink&quot; title=&quot;区间和&quot;&gt;&lt;/a&gt;区间和&lt;/h1&gt;&lt;p&gt;这个区间和思想和之前的前缀和思想有相同之处，区别在于这个区间和是离散化的，在一个较大的区间中，多数元素为0，少部分有数据，求这部分区间和。&lt;br&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://bugcat.top/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="acwing算法学习" scheme="https://bugcat.top/tags/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="区间和" scheme="https://bugcat.top/tags/%E5%8C%BA%E9%97%B4%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="https://bugcat.top/2023/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/6.%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>https://bugcat.top/2023/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/6.%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2023-08-06T21:34:07.000Z</published>
    <updated>2024-10-20T13:34:26.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见问题分类：</p><ol><li>对于一个序列，用两个指针维护一段区间</li><li>对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;双指针&quot;&gt;&lt;a href=&quot;#双指针&quot; class=&quot;headerlink&quot; title=&quot;双指针&quot;&gt;&lt;/a&gt;双指针&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa</summary>
      
    
    
    
    <category term="算法学习" scheme="https://bugcat.top/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="acwing算法学习" scheme="https://bugcat.top/tags/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="双指针" scheme="https://bugcat.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="https://bugcat.top/2023/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/5.%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>https://bugcat.top/2023/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/5.%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2023-08-06T21:02:06.000Z</published>
    <updated>2024-10-20T13:34:26.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>这里主要记录一下学习到的位运算算法<br><span id="more"></span></p><h2 id="求第k位数字"><a href="#求第k位数字" class="headerlink" title="求第k位数字"></a>求第k位数字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="返回n的最后一位1"><a href="#返回n的最后一位1" class="headerlink" title="返回n的最后一位1"></a>返回n的最后一位1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lowbit(n) = n &amp; -n，，如101000得1000</span><br></pre></td></tr></table></figure><p>这个可能咋看一下不好理解，但是可以推理出来:</p><ol><li>假设<code>x = 1010...10000</code></li><li><code>-x = ~x+1</code></li><li><code>~x = 0101...01111</code></li><li><code>~x + 1 = 0101...10000</code></li><li><code>x &amp; (~x+1) = (1010...10000) &amp; (0101...10000) = 0000...10000</code><br>可以通过上面步骤发现<code>lowbit(n)</code>算法最终取到最后一位1和后面的二进制</li></ol><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/number-of-1-bits/description/">位1的个数</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink&quot; title=&quot;位运算&quot;&gt;&lt;/a&gt;位运算&lt;/h1&gt;&lt;p&gt;这里主要记录一下学习到的位运算算法&lt;br&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://bugcat.top/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="acwing算法学习" scheme="https://bugcat.top/tags/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="位运算" scheme="https://bugcat.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>static、extern和inline</title>
    <link href="https://bugcat.top/2023/08/05/C++/static%E3%80%81extern%E5%92%8Cinline/"/>
    <id>https://bugcat.top/2023/08/05/C++/static%E3%80%81extern%E5%92%8Cinline/</id>
    <published>2023-08-05T20:40:11.000Z</published>
    <updated>2024-10-20T13:34:26.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="static、extern和inline"><a href="#static、extern和inline" class="headerlink" title="static、extern和inline"></a>static、extern和inline</h1><p>在实习写C++的时候遇到static、extern和inline相关的概念和使用，记录一下<br><span id="more"></span></p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><code>static</code>关键字作用很多，这里主要说明<code>static</code>变量。<code>static</code>变量生命周期是整个程序，可见性是文件可见(这些都是很基础的知识)<br>但是需要注意的是假如我们在头文件中定义了一个<code>static</code>变量（这里假设为<code>staticVar</code>），那么包含这个头文件的文件都会有这样一个变量<code>staticVar</code>不会发生冲突。这个特性有时候有用，<strong>但是绝大多数情况还是没有用的，而且会浪费空间，不建议使用</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件A.h </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源文件B.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span> <span class="comment">// B.cpp中包含一个 staticVar</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源文件C.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span> <span class="comment">// C.cpp中包含一个 staticVar</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p><code>extern</code>关键字在C++中用来声明全局变量，它用来告诉编译器，这个变量在其他文件中定义的，以避免重复定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源文件 A.cpp</span></span><br><span class="line"><span class="type">int</span> globalVariable = <span class="number">10</span>; <span class="comment">// 定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源文件 B.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> globalVariable; <span class="comment">// 声明全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用全局变量</span></span><br><span class="line">  globalVariable = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有的时候我们可以在头文件中使用<code>extern</code>来<strong>声明</strong>一个变量，在某个源文件中进行定义，然后其他包含这个头文件的源文件就都有这个变量的声明，它们共享一份内容。</p><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p><code>inline</code>关键字修饰函数，用于向编译器提供函数内联的建议，但是我没有想到<code>inline</code>关键字可以解决跨模块（动态库）的使用函数的问题。<br>比如我有一个动态库A（A.dll）和一个动态库B（B.dll）,动态库B使用了A里面的函数，但是B在链接的时候A还没有编译，这个时候可以将A里面的函数加上<code>inline</code>进行修饰，就不会报符号找不到的问题。<br>底层来看是因为<code>inline</code>关键字修饰的函数，在调用的时候会进行展开，这样就不会查找这个符号，但是这个特性确实有时候可以解决这样类似的编译问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;static、extern和inline&quot;&gt;&lt;a href=&quot;#static、extern和inline&quot; class=&quot;headerlink&quot; title=&quot;static、extern和inline&quot;&gt;&lt;/a&gt;static、extern和inline&lt;/h1&gt;&lt;p&gt;在实习写C++的时候遇到static、extern和inline相关的概念和使用，记录一下&lt;br&gt;</summary>
    
    
    
    <category term="C++" scheme="https://bugcat.top/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>高精度计算</title>
    <link href="https://bugcat.top/2023/07/03/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/3.%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/"/>
    <id>https://bugcat.top/2023/07/03/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/3.%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/</id>
    <published>2023-07-03T23:11:20.000Z</published>
    <updated>2024-10-20T13:34:26.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高精度计算"><a href="#高精度计算" class="headerlink" title="高精度计算"></a>高精度计算</h1><span id="more"></span><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/ C = A + B, A &gt;= <span class="number">0</span>, B &gt;= <span class="number">0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; <span class="built_in">add</span>(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/add-strings/description/">字符串相加</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;高精度计算&quot;&gt;&lt;a href=&quot;#高精度计算&quot; class=&quot;headerlink&quot; title=&quot;高精度计算&quot;&gt;&lt;/a&gt;高精度计算&lt;/h1&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://bugcat.top/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="acwing算法学习" scheme="https://bugcat.top/tags/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="高精度加法、减法、乘法、除法" scheme="https://bugcat.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95%E3%80%81%E5%87%8F%E6%B3%95%E3%80%81%E4%B9%98%E6%B3%95%E3%80%81%E9%99%A4%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前缀和与差分</title>
    <link href="https://bugcat.top/2023/07/03/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/4.%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <id>https://bugcat.top/2023/07/03/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/4.%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</id>
    <published>2023-07-03T22:55:14.000Z</published>
    <updated>2024-10-20T13:34:26.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h1><span id="more"></span><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><p><code>a[i]</code> 表示数组中第i个数、<code>s[i]</code>表示为前i个数之和</p><ol><li><code>s[i] = a[1] + a[2] + ……+ a[i] = s[i-1] + a[i]</code></li><li><code>[l, r]</code>区间内数的和：<code>s[r] - s[l-1]</code>（为了当l=1时不需要进行特判。规定s[0]记为0，且读入数组的时候从下标1开始记录）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S[i] = a[1] + a[2] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - 1]</span><br></pre></td></tr></table></figure><p>封装一下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维前缀和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PreSum</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">PreSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; m_preSum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PreSum::<span class="built_in">PreSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">m_preSum.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">m_preSum[i] = m_preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PreSum::query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_preSum[right + <span class="number">1</span>] - m_preSum[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p>差分是前缀和的逆运算，简单封装<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Difference</span>(vector&lt;<span class="type">int</span>&gt; nums);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; m_diff;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Difference::<span class="built_in">Difference</span>(vector&lt;<span class="type">int</span>&gt; nums)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">m_diff.<span class="built_in">resize</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">m_diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Difference::increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_diff[i] += val;</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> &lt; m_diff.<span class="built_in">size</span>()) &#123;</span><br><span class="line">m_diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Difference::result</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(m_diff.size())</span></span>;</span><br><span class="line">res[<span class="number">0</span>] = m_diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m_diff.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">res[i] = res[i - <span class="number">1</span>] + m_diff[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/range-sum-query-immutable/">前缀和</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前缀和与差分&quot;&gt;&lt;a href=&quot;#前缀和与差分&quot; class=&quot;headerlink&quot; title=&quot;前缀和与差分&quot;&gt;&lt;/a&gt;前缀和与差分&lt;/h1&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://bugcat.top/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="acwing算法学习" scheme="https://bugcat.top/tags/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="前缀和与差分" scheme="https://bugcat.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>整数二分</title>
    <link href="https://bugcat.top/2023/07/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/2.%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/"/>
    <id>https://bugcat.top/2023/07/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/2.%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/</id>
    <published>2023-07-01T21:54:29.000Z</published>
    <updated>2024-10-20T13:34:26.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h1><p>可以划分为满足某种性质与不满足某种性质的两个区间，用二分法可以找到两区间边界的左右两个点。如图中红色和绿色区间，可以通过二分找到这个区间边界。这里需要注意的是利用单调性二分只是其中一种，其他性质其实也可以二分，不过我们掌握单调性进行二分查找就行。<br><span id="more"></span><br><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/算法学习/二分-第 3 页.drawio.png" alt="二分-第 3 页.drawio"></p><ol><li>寻找红色区域的边界。<ul><li>mid = (l+r+1)/2</li><li>如果mid在红色区域，[l,r]-&gt;[mid,r]</li><li>如果mid不在红色区域，也就是红色右侧的区域，[l,r]-&gt;[l,mid-1]</li></ul></li><li>寻找绿色区域的边界。<ul><li>mid = (l+r)/2 </li><li>如果mid在绿色区域，[l,r]-&gt;[l,mid] </li><li>如果mid不在绿色区域，也就是绿色左侧的区域，[l,r]-&gt;[mid+1,r]</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 二分查找</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用二分查找3的起始位置和终止位置，我可以使用上面的方法进行查找</p><p>可以使用bsearch_2查找3的终止位置，条件是<code>x&lt;=3</code></p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/算法学习/二分.drawio.png" alt="二分.drawio"></p><p>可以使用bsearch_1查找3的终止位置，条件是<code>x&gt;=3</code></p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/算法学习/二分-第 2 页.drawio.png" alt="二分-第 2 页.drawio"></p><h2 id="对应题目"><a href="#对应题目" class="headerlink" title="对应题目"></a>对应题目</h2><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">在排序数组中查找元素的第一个和最后一个位置</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>())<span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">LeftBound</span>(nums,target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[l]!=target)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">RightBound</span>(nums,target);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对应bsearch_1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LeftBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应bsearch_2</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">RightBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;整数二分&quot;&gt;&lt;a href=&quot;#整数二分&quot; class=&quot;headerlink&quot; title=&quot;整数二分&quot;&gt;&lt;/a&gt;整数二分&lt;/h1&gt;&lt;p&gt;可以划分为满足某种性质与不满足某种性质的两个区间，用二分法可以找到两区间边界的左右两个点。如图中红色和绿色区间，可以通过二分找到这个区间边界。这里需要注意的是利用单调性二分只是其中一种，其他性质其实也可以二分，不过我们掌握单调性进行二分查找就行。&lt;br&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://bugcat.top/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="acwing算法学习" scheme="https://bugcat.top/tags/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="二分" scheme="https://bugcat.top/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://bugcat.top/2023/07/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E6%8E%92%E5%BA%8F/"/>
    <id>https://bugcat.top/2023/07/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E6%8E%92%E5%BA%8F/</id>
    <published>2023-07-01T21:16:03.000Z</published>
    <updated>2024-10-20T13:34:26.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><span id="more"></span><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ol><li>确定分界点（随机取任意一个数为分界点，一般取中点）；</li><li>调整区间，把小于<code>x</code>的数移到左边，把大于<code>x</code>的数移到右边，把区间分为<code>[l, j]</code>、<code>[j + 1, r]</code>；</li><li>递归左右。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 快速排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = nums[l + (r - l) &gt;&gt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> i++; <span class="keyword">while</span> (nums[i] &lt; x);</span><br><span class="line"><span class="keyword">do</span> j--; <span class="keyword">while</span> (nums[j] &gt; x);</span><br><span class="line"><span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">QuickSort</span>(nums, l, j);</span><br><span class="line"><span class="built_in">QuickSort</span>(nums, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ol><li>取数组的中间数作为分界点；</li><li>将分界点左右两边分别排好序；</li><li>将左右两边进行合并。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid = l + (r - l) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">MergeSort</span>(nums, l, mid);</span><br><span class="line"><span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt;= nums[j])</span><br><span class="line">tmp[k++] = nums[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[k++] = nums[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) tmp[k++] = nums[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r) tmp[k++] = nums[j++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) nums[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对应的题目"><a href="#对应的题目" class="headerlink" title="对应的题目"></a>对应的题目</h2><p><a href="https://leetcode.cn/problems/sort-an-array/submissions/">排序数组</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://bugcat.top/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="排序" scheme="https://bugcat.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="acwing算法学习" scheme="https://bugcat.top/tags/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用muduo编写webserver</title>
    <link href="https://bugcat.top/2023/02/13/Linux/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAmuduo/%E4%BD%BF%E7%94%A8muduo%E7%BC%96%E5%86%99webserver/"/>
    <id>https://bugcat.top/2023/02/13/Linux/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAmuduo/%E4%BD%BF%E7%94%A8muduo%E7%BC%96%E5%86%99webserver/</id>
    <published>2023-02-13T11:48:07.000Z</published>
    <updated>2024-10-20T13:34:26.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用muduo编写webserver"><a href="#使用muduo编写webserver" class="headerlink" title="使用muduo编写webserver"></a>使用muduo编写webserver</h1><p>因为学习了muduo库，想通过muduo库写一个webserver作为项目，在muduo和tinyWebserver的基础上改了一下，简单的把他们融合了一下。</p><span id="more"></span><h2 id="httpserver"><a href="#httpserver" class="headerlink" title="httpserver"></a>httpserver</h2><p>在muduo原本的httpserver的基础上进行了改造，加入简单的数据库操作的部分。针对http请求处理的逻辑部分封装在了<code>onHttpProcess</code>中。</p><p>HttpServer.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HTTPSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HTTPSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../net/TcpServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../base/SqlConnectionPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tinyMuduo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> net</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">HttpRequest</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">HttpResponse</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// A simple embeddable HTTP server designed for report status of a program.</span></span><br><span class="line">        <span class="comment">/// It is not a fully HTTP 1.1 compliant server, but provides minimum features</span></span><br><span class="line">        <span class="comment">/// that can communicate with HttpClient and Web browser.</span></span><br><span class="line">        <span class="comment">/// It is synchronous, just like Java Servlet.</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">HttpServer</span> : boost::noncopyable</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">const</span> HttpRequest &amp;,</span><br><span class="line">                                       HttpResponse *)&gt;</span><br><span class="line">                HttpCallback;</span><br><span class="line">            <span class="built_in">HttpServer</span>(EventLoop *loop,</span><br><span class="line">                       <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                       <span class="type">const</span> string &amp;name,</span><br><span class="line">                       <span class="type">const</span> string &amp;user,</span><br><span class="line">                       <span class="type">const</span> string &amp;passwd,</span><br><span class="line">                       <span class="type">const</span> string &amp;databaseName,</span><br><span class="line">                       <span class="type">int</span> sqlNum,</span><br><span class="line">                       TcpServer::Option option = TcpServer::kNoReusePort);</span><br><span class="line"></span><br><span class="line">            <span class="function">EventLoop *<span class="title">getLoop</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> server_.<span class="built_in">getLoop</span>(); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Not thread safe, callback be registered before calling start().</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setHttpCallback</span><span class="params">(<span class="type">const</span> HttpCallback &amp;cb)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                httpCallback_ = cb;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                server_.<span class="built_in">setThreadNum</span>(numThreads);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Buffer *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Timestamp receiveTime)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">onRequest</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;, <span class="type">const</span> HttpRequest &amp;)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">onWriteComplete</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">initmysql</span><span class="params">(ConnectionPool *connPool)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">onHttpProcess</span><span class="params">(<span class="type">const</span> HttpRequest &amp;req, HttpResponse *resp)</span></span>;</span><br><span class="line">            TcpServer server_;</span><br><span class="line">            HttpCallback httpCallback_;</span><br><span class="line"></span><br><span class="line">            ConnectionPool *connPool_; <span class="comment">// 数据库相关</span></span><br><span class="line">            string user_;              <span class="comment">// 登陆数据库用户名</span></span><br><span class="line">            string passwd_;            <span class="comment">// 登陆数据库密码</span></span><br><span class="line">            string databaseName_;      <span class="comment">// 使用数据库名</span></span><br><span class="line">            <span class="type">int</span> sqlNum_;</span><br><span class="line">            map&lt;string, string&gt; users;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">// namespace net</span></span><br><span class="line">&#125; <span class="comment">// namespace tinyMuduo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _HTTPSERVER_H</span></span></span><br></pre></td></tr></table></figure><p>HttpServer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../net/http/HttpServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../base/Logging.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../net/http/HttpContext.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../net/http/HttpRequest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../net/http/HttpResponse.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tinyMuduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tinyMuduo::net;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tinyMuduo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> net</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">namespace</span> detail</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">defaultHttpCallback</span><span class="params">(<span class="type">const</span> HttpRequest &amp;, HttpResponse *resp)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                resp-&gt;<span class="built_in">setStatusCode</span>(HttpResponse::k404NotFound);</span><br><span class="line">                resp-&gt;<span class="built_in">setStatusMessage</span>(<span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">                resp-&gt;<span class="built_in">setCloseConnection</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="comment">// namespace detail</span></span><br><span class="line">    &#125;     <span class="comment">// namespace net</span></span><br><span class="line">&#125; <span class="comment">// namespace tinyMuduo</span></span><br><span class="line"></span><br><span class="line">HttpServer::<span class="built_in">HttpServer</span>(EventLoop *loop,</span><br><span class="line">                       <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                       <span class="type">const</span> string &amp;name,</span><br><span class="line">                       <span class="type">const</span> string &amp;user,</span><br><span class="line">                       <span class="type">const</span> string &amp;passwd,</span><br><span class="line">                       <span class="type">const</span> string &amp;databaseName,</span><br><span class="line">                       <span class="type">int</span> sqlNum,</span><br><span class="line">                       TcpServer::Option option)</span><br><span class="line">    : <span class="built_in">server_</span>(loop, listenAddr, name, option), <span class="built_in">user_</span>(user), <span class="built_in">passwd_</span>(passwd), <span class="built_in">databaseName_</span>(databaseName), <span class="built_in">sqlNum_</span>(sqlNum)</span><br><span class="line">&#123;</span><br><span class="line">    server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;HttpServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">    server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;HttpServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">    server_.<span class="built_in">setWriteCompleteCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;HttpServer::onWriteComplete, <span class="keyword">this</span>, _1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setHttpCallback</span>(std::<span class="built_in">bind</span>(&amp;HttpServer::onHttpProcess, <span class="keyword">this</span>, _1, _2));</span><br><span class="line">    <span class="comment">// user_ = &quot;root&quot;;</span></span><br><span class="line">    <span class="comment">// passwd_ = &quot;123456&quot;;</span></span><br><span class="line">    <span class="comment">// databaseName_ = &quot;yourdb&quot;;</span></span><br><span class="line">    <span class="comment">// sqlNum_ = 8;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化数据库</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param connPool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::initmysql</span><span class="params">(ConnectionPool *connPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先从连接池中取一个连接</span></span><br><span class="line">    MYSQL *mysql = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">tinyMuduo::ConnectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;mysql, connPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在user表中检索username，passwd数据，浏览器端输入</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(mysql, <span class="string">&quot;SELECT username,passwd FROM user&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">&quot;SELECT error: &quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(mysql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从表中检索完整的结果集</span></span><br><span class="line">    MYSQL_RES *result = <span class="built_in">mysql_store_result</span>(mysql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果集中的列数</span></span><br><span class="line">    <span class="type">int</span> num_fields = <span class="built_in">mysql_num_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回所有字段结构的数组</span></span><br><span class="line">    MYSQL_FIELD *fields = <span class="built_in">mysql_fetch_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从结果集中获取下一行，将对应的用户名和密码，存入map中</span></span><br><span class="line">    <span class="keyword">while</span> (MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(result))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">string <span class="title">temp1</span><span class="params">(row[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="function">string <span class="title">temp2</span><span class="params">(row[<span class="number">1</span>])</span></span>;</span><br><span class="line">        users[temp1] = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">&quot;HttpServer[&quot;</span> &lt;&lt; server_.<span class="built_in">name</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;] starts listening on &quot;</span> &lt;&lt; server_.<span class="built_in">ipPort</span>();</span><br><span class="line">    server_.<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">// 初始化数据库连接池</span></span><br><span class="line">    connPool_ = ConnectionPool::<span class="built_in">getInstance</span>();</span><br><span class="line">    connPool_-&gt;<span class="built_in">init</span>(<span class="string">&quot;127.0.0.1&quot;</span>, user_, passwd_, databaseName_, <span class="number">3306</span>, sqlNum_);</span><br><span class="line">    <span class="built_in">initmysql</span>(connPool_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;<span class="built_in">connected</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        conn-&gt;<span class="built_in">setContext</span>(<span class="built_in">HttpContext</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Buffer *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HttpContext *context = boost::<span class="built_in">any_cast</span>&lt;HttpContext&gt;(conn-&gt;<span class="built_in">getMutableContext</span>());</span><br><span class="line">    <span class="comment">// LOG_INFO &lt;&lt; buf-&gt;toStringPiece();</span></span><br><span class="line">    <span class="keyword">if</span> (!context-&gt;<span class="built_in">parseRequest</span>(buf, receiveTime))</span><br><span class="line">    &#123;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(<span class="string">&quot;HTTP/1.1 400 Bad Request\r\n\r\n&quot;</span>);</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context-&gt;<span class="built_in">gotAll</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">onRequest</span>(conn, context-&gt;<span class="built_in">request</span>());</span><br><span class="line">        context-&gt;<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::onRequest</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, <span class="type">const</span> HttpRequest &amp;req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> string &amp;connection = req.<span class="built_in">getHeader</span>(<span class="string">&quot;Connection&quot;</span>);</span><br><span class="line">    <span class="type">bool</span> close = connection == <span class="string">&quot;close&quot;</span> ||</span><br><span class="line">                 (req.<span class="built_in">getVersion</span>() == HttpRequest::kHttp10 &amp;&amp; connection != <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">    <span class="function">HttpResponse <span class="title">response</span><span class="params">(close)</span></span>;</span><br><span class="line">    <span class="built_in">httpCallback_</span>(req, &amp;response);</span><br><span class="line">    Buffer buf;</span><br><span class="line">    response.<span class="built_in">appendToBuffer</span>(&amp;buf);</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(&amp;buf);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = response.g_file.<span class="built_in">c_str</span>();</span><br><span class="line">    FILE *fp = ::<span class="built_in">fopen</span>(file, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">TcpConnection::FilePtr <span class="title">ctx</span><span class="params">(fp, ::fclose)</span></span>;</span><br><span class="line">        <span class="comment">// conn-&gt;setContext(ctx);</span></span><br><span class="line">        conn-&gt;filePtr_.<span class="built_in">swap</span>(ctx);</span><br><span class="line">        <span class="type">char</span> buf[TcpConnection::kBufSize];</span><br><span class="line">        <span class="type">size_t</span> nread = ::<span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="keyword">sizeof</span> buf, fp);</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(buf, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(nread));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; file &lt;&lt; <span class="string">&quot; no such file&quot;</span>;</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::onWriteComplete</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[TcpConnection::kBufSize];</span><br><span class="line">    <span class="type">size_t</span> nread = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;filePtr_)</span><br><span class="line">        nread = ::<span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="keyword">sizeof</span> buf, <span class="built_in">get_pointer</span>(conn-&gt;filePtr_));</span><br><span class="line">    <span class="keyword">if</span> (nread &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(buf, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(nread));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        conn-&gt;filePtr_.<span class="built_in">reset</span>();</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">&quot;FileServer - done&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 对http消息进行处理的函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param req</span></span><br><span class="line"><span class="comment"> * @param resp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::onHttpProcess</span><span class="params">(<span class="type">const</span> HttpRequest &amp;req, HttpResponse *resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;Headers &quot;</span> &lt;&lt; req.<span class="built_in">methodString</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; req.<span class="built_in">path</span>();</span><br><span class="line"></span><br><span class="line">    std::string file;</span><br><span class="line">    <span class="keyword">if</span> (!req.<span class="built_in">body</span>().<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *bodyStr = req.<span class="built_in">body</span>().<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="comment">// 将用户名和密码提取出来</span></span><br><span class="line">        <span class="comment">// user=123&amp;passwd=123</span></span><br><span class="line">        <span class="type">char</span> name[<span class="number">100</span>], password[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">5</span>; bodyStr[i] != <span class="string">&#x27;&amp;&#x27;</span>; ++i)</span><br><span class="line">            name[i - <span class="number">5</span>] = bodyStr[i];</span><br><span class="line">        name[i - <span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = i + <span class="number">10</span>; bodyStr[i] != <span class="string">&#x27;\0&#x27;</span>; ++i, ++j)</span><br><span class="line">            password[j] = bodyStr[i];</span><br><span class="line">        password[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/3CGISQL.cgi&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 表示注册</span></span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">count</span>(name))</span><br><span class="line">            &#123;</span><br><span class="line">                file.<span class="built_in">append</span>(<span class="string">&quot;resources/registerError.html&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果是注册，先检测数据库中是否有重名的</span></span><br><span class="line">                <span class="comment">// 没有重名的，进行增加数据</span></span><br><span class="line">                <span class="type">char</span> *sql_insert = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">                <span class="built_in">strcpy</span>(sql_insert, <span class="string">&quot;INSERT INTO user(username, passwd) VALUES(&quot;</span>);</span><br><span class="line">                <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                <span class="built_in">strcat</span>(sql_insert, name);</span><br><span class="line">                <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;, &#x27;&quot;</span>);</span><br><span class="line">                <span class="built_in">strcat</span>(sql_insert, password);</span><br><span class="line">                <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 先从连接池中取一个连接</span></span><br><span class="line">                MYSQL *mysql = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="function">ConnectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;mysql, connPool_)</span></span>;</span><br><span class="line">                <span class="comment">// 此处感觉需要锁一下</span></span><br><span class="line">                <span class="type">int</span> res = <span class="built_in">mysql_query</span>(mysql, sql_insert);</span><br><span class="line">                <span class="keyword">if</span> (!res)</span><br><span class="line">                &#123;</span><br><span class="line">                    users[name] = password;</span><br><span class="line">                    file.<span class="built_in">append</span>(<span class="string">&quot;resources/login.html&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    file.<span class="built_in">append</span>(<span class="string">&quot;resources/registerError.html&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/2CGISQL.cgi&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 表示登录</span></span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">count</span>(name) &amp;&amp; users[name] == password)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                file.<span class="built_in">append</span>(<span class="string">&quot;resources/welcome.html&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                file.<span class="built_in">append</span>(<span class="string">&quot;resources/logError.html&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/register.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/1&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/login.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/5&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/picture.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/6&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/video.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/7&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/fans.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/404&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/404.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// strcpy(file, &quot;resources&quot;);</span></span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources&quot;</span>);</span><br><span class="line">        <span class="comment">// int len = strlen(file);</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *url_real = req.<span class="built_in">path</span>().<span class="built_in">c_str</span>();</span><br><span class="line">        file.<span class="built_in">append</span>(url_real);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件状态</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> fileStat;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stat</span>(file.<span class="built_in">c_str</span>(), &amp;fileStat) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; file &lt;&lt; <span class="string">&quot; no such file&quot;</span>;</span><br><span class="line">        file.<span class="built_in">clear</span>();</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/404.html&quot;</span>);</span><br><span class="line">        <span class="built_in">stat</span>(file.<span class="built_in">c_str</span>(), &amp;fileStat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (!(fileStat.st_mode &amp; S_IROTH))</span></span><br><span class="line">    <span class="comment">//   return;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (S_ISDIR(fileStat.st_mode))</span></span><br><span class="line">    <span class="comment">//   return;</span></span><br><span class="line"></span><br><span class="line">    resp-&gt;<span class="built_in">setStatusCode</span>(HttpResponse::k200Ok);</span><br><span class="line">    resp-&gt;<span class="built_in">setStatusMessage</span>(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Server&quot;</span>, <span class="string">&quot;tinyMuduo&quot;</span>);</span><br><span class="line">    resp-&gt;<span class="built_in">setContentLength</span>(fileStat.st_size);</span><br><span class="line">    resp-&gt;<span class="built_in">setFile</span>(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的东西是<code>onHttpProcess</code>函数，这个函数是处理http请求的逻辑。其次我觉得重要的是<code>onRequest</code>中发送文件，因为图片、html页面等文件太大，所以一次发可能装不下，所以这里参考了muduo中ftp的实现，在<code>onRequest</code>中发送一次文件，如果没有发送完会在<code>onWriteComplete</code>中接着发送。</p><h2 id="SqlConnectionPool"><a href="#SqlConnectionPool" class="headerlink" title="SqlConnectionPool"></a>SqlConnectionPool</h2><p>因为涉及连接数据库，简单将tinyWEbserver里面的数据库池搬了过来。</p><p>SqlConnectionPool.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SQLCONNECTIONPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SQLCONNECTIONPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logging.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tinyMuduo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ConnectionPool</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">MYSQL *<span class="title">getConnection</span><span class="params">()</span></span>;              <span class="comment">// 获取数据库连接</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">releaseConnection</span><span class="params">(MYSQL *conn)</span></span>; <span class="comment">// 释放连接</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getFreeConn</span><span class="params">()</span></span>;                   <span class="comment">// 获取连接</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">destroyPool</span><span class="params">()</span></span>;                  <span class="comment">// 销毁所有连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单例模式</span></span><br><span class="line">        <span class="function"><span class="type">static</span> ConnectionPool *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string url, string User, string PassWord, string DataBaseName, <span class="type">int</span> Port, <span class="type">int</span> MaxConn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">ConnectionPool</span>();</span><br><span class="line">        ~<span class="built_in">ConnectionPool</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxConn_;          <span class="comment">// 最大连接数</span></span><br><span class="line">        <span class="type">int</span> curConn_;          <span class="comment">// 当前已使用的连接数</span></span><br><span class="line">        <span class="type">int</span> freeConn_;         <span class="comment">// 当前空闲的连接数</span></span><br><span class="line">        list&lt;MYSQL *&gt; connList; <span class="comment">// 连接池</span></span><br><span class="line">        std::mutex mutex_;</span><br><span class="line">        std::condition_variable condition_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string url_;          <span class="comment">// 主机地址</span></span><br><span class="line">        string port_;         <span class="comment">// 数据库端口号</span></span><br><span class="line">        string user_;         <span class="comment">// 登陆数据库用户名</span></span><br><span class="line">        string passwd_;     <span class="comment">// 登陆数据库密码</span></span><br><span class="line">        string databaseName_; <span class="comment">// 使用数据库名</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ConnectionRAII</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ConnectionRAII</span>(MYSQL **con, ConnectionPool *connPool);</span><br><span class="line">        ~<span class="built_in">ConnectionRAII</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MYSQL *conRAII_;</span><br><span class="line">        ConnectionPool *poolRAII_;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _SQLCONNECTIONPOOL_H</span></span></span><br></pre></td></tr></table></figure><p>SqlConnectionPool.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SqlConnectionPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tinyMuduo</span><br><span class="line">&#123;</span><br><span class="line">    ConnectionPool::<span class="built_in">ConnectionPool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        curConn_ = <span class="number">0</span>;</span><br><span class="line">        freeConn_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ConnectionPool *<span class="title">ConnectionPool::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> ConnectionPool connPool;</span><br><span class="line">        <span class="keyword">return</span> &amp;connPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ConnectionPool::init</span><span class="params">(string url, string User, string PassWord, string DBName, <span class="type">int</span> Port, <span class="type">int</span> MaxConn)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        url_ = url;</span><br><span class="line">        port_ = Port;</span><br><span class="line">        user_ = User;</span><br><span class="line">        passwd_ = PassWord;</span><br><span class="line">        databaseName_ = DBName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxConn; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            MYSQL *con = <span class="literal">NULL</span>;</span><br><span class="line">            con = <span class="built_in">mysql_init</span>(con);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (con == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG_ERROR &lt;&lt; <span class="string">&quot;MySQL Error&quot;</span>;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            con = <span class="built_in">mysql_real_connect</span>(con, url.<span class="built_in">c_str</span>(), User.<span class="built_in">c_str</span>(), PassWord.<span class="built_in">c_str</span>(), DBName.<span class="built_in">c_str</span>(), Port, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (con == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG_ERROR &lt;&lt; <span class="string">&quot;MySQL Error&quot;</span>;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            connList.<span class="built_in">push_back</span>(con);</span><br><span class="line">            ++freeConn_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxConn_ = freeConn_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当有请求时，从数据库连接池中返回一个可用连接，更新使用和空闲连接数</span></span><br><span class="line">    <span class="function">MYSQL *<span class="title">ConnectionPool::getConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MYSQL *con = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == connList.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">        con = connList.<span class="built_in">front</span>();</span><br><span class="line">        connList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        --freeConn_;</span><br><span class="line">        ++curConn_;</span><br><span class="line">        <span class="keyword">while</span> (freeConn_ &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            condition_.<span class="built_in">wait</span>(lk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放当前使用的连接</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ConnectionPool::releaseConnection</span><span class="params">(MYSQL *con)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == con)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">        connList.<span class="built_in">push_back</span>(con);</span><br><span class="line">        ++freeConn_;</span><br><span class="line">        --curConn_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// condition_.wait(lk);</span></span><br><span class="line">        <span class="keyword">if</span> (freeConn_ &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            condition_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁数据库连接池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ConnectionPool::destroyPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connList.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            list&lt;MYSQL *&gt;::iterator it;</span><br><span class="line">            <span class="keyword">for</span> (it = connList.<span class="built_in">begin</span>(); it != connList.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            &#123;</span><br><span class="line">                MYSQL *con = *it;</span><br><span class="line">                <span class="built_in">mysql_close</span>(con);</span><br><span class="line">            &#125;</span><br><span class="line">            curConn_ = <span class="number">0</span>;</span><br><span class="line">            freeConn_ = <span class="number">0</span>;</span><br><span class="line">            connList.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前空闲的连接数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ConnectionPool::getFreeConn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;freeConn_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConnectionPool::~<span class="built_in">ConnectionPool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">destroyPool</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConnectionRAII::<span class="built_in">ConnectionRAII</span>(MYSQL **SQL, ConnectionPool *connPool)</span><br><span class="line">    &#123;</span><br><span class="line">        *SQL = connPool-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line"></span><br><span class="line">        conRAII_ = *SQL;</span><br><span class="line">        poolRAII_ = connPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConnectionRAII::~<span class="built_in">ConnectionRAII</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        poolRAII_-&gt;<span class="built_in">releaseConnection</span>(conRAII_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// namespace tinyMuduo</span></span><br></pre></td></tr></table></figure><p>测试SqlConnectionPool_test.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../base/SqlConnectionPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要修改的数据库信息,登录名,密码,库名</span></span><br><span class="line">string user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">string passwd = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">string databasename = <span class="string">&quot;yourdb&quot;</span>;</span><br><span class="line"></span><br><span class="line">map&lt;string, string&gt; users;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initmysqlResult</span><span class="params">(tinyMuduo::ConnectionPool *connPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先从连接池中取一个连接</span></span><br><span class="line">    MYSQL *mysql = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">tinyMuduo::ConnectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;mysql, connPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在user表中检索username，passwd数据，浏览器端输入</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(mysql, <span class="string">&quot;SELECT username,passwd FROM user&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">&quot;SELECT error: &quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(mysql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从表中检索完整的结果集</span></span><br><span class="line">    MYSQL_RES *result = <span class="built_in">mysql_store_result</span>(mysql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果集中的列数</span></span><br><span class="line">    <span class="type">int</span> num_fields = <span class="built_in">mysql_num_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回所有字段结构的数组</span></span><br><span class="line">    MYSQL_FIELD *fields = <span class="built_in">mysql_fetch_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从结果集中获取下一行，将对应的用户名和密码，存入map中</span></span><br><span class="line">    <span class="keyword">while</span> (MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(result))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">string <span class="title">temp1</span><span class="params">(row[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="function">string <span class="title">temp2</span><span class="params">(row[<span class="number">1</span>])</span></span>;</span><br><span class="line">        users[temp1] = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化数据库连接池</span></span><br><span class="line">    tinyMuduo::ConnectionPool *connPool = tinyMuduo::ConnectionPool::<span class="built_in">getInstance</span>();</span><br><span class="line">    connPool-&gt;<span class="built_in">init</span>(<span class="string">&quot;127.0.0.1&quot;</span>, user, passwd, databasename, <span class="number">3306</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据库读取表</span></span><br><span class="line">    <span class="built_in">initmysqlResult</span>(connPool);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = users.<span class="built_in">begin</span>(); iter != users.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; passwd: &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mysql是使用docker进行安装的，进入docker查看一下数据</p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20230213144740181.png" alt="image-20230213144740181"></p><p>运行测试</p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20230213144824101.png" alt="image-20230213144824101"></p><p>可以看到简单的连接是成功的</p><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>main里面实现很简单，主要是需要写好数据库相关的信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/Logging.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net/EventLoop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net/http/HttpServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net/http/HttpRequest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net/http/HttpResponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tinyMuduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tinyMuduo::net;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要修改的数据库信息,登录名,密码,库名</span></span><br><span class="line">  string user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">  string passwd = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">  string databasename = <span class="string">&quot;yourdb&quot;</span>;</span><br><span class="line">  <span class="type">int</span> sqlNum = <span class="number">8</span>;</span><br><span class="line">  <span class="type">int</span> numThreads = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  EventLoop loop;</span><br><span class="line">  <span class="function">HttpServer <span class="title">server</span><span class="params">(&amp;loop, InetAddress(<span class="number">8080</span>), <span class="string">&quot;webserver&quot;</span>, user, passwd, databasename, sqlNum)</span></span>;</span><br><span class="line">  server.<span class="built_in">setThreadNum</span>(numThreads);</span><br><span class="line">  server.<span class="built_in">start</span>();</span><br><span class="line">  loop.<span class="built_in">loop</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>登录界面</p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20230213151254186.png" alt="image-20230213151254186"></p><p>选择界面</p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20230213151319812.png" alt="image-20230213151319812"></p><p>关注界面</p><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20230213151339389.png" alt="image-20230213151339389"></p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>感谢muduo的仓库和tinyWebserver仓库</p><p>muduo：<a href="https://github.com/chenshuo/muduo">https://github.com/chenshuo/muduo</a></p><p>tinyWebServer:<a href="https://github.com/qinguoyi/TinyWebServer">https://github.com/qinguoyi/TinyWebServer</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在muduo的基础上想写个webserver很简单，只需要在他http的基础上进行改进就可以。</p><p>最好代码仓库：<a href="https://github.com/bugcat9/tinyMuduo">https://github.com/bugcat9/tinyMuduo</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用muduo编写webserver&quot;&gt;&lt;a href=&quot;#使用muduo编写webserver&quot; class=&quot;headerlink&quot; title=&quot;使用muduo编写webserver&quot;&gt;&lt;/a&gt;使用muduo编写webserver&lt;/h1&gt;&lt;p&gt;因为学习了muduo库，想通过muduo库写一个webserver作为项目，在muduo和tinyWebserver的基础上改了一下，简单的把他们融合了一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://bugcat.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://bugcat.top/tags/Linux/"/>
    
    <category term="muduo" scheme="https://bugcat.top/tags/muduo/"/>
    
  </entry>
  
</feed>
