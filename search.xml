<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Activity的生命周期简单的例子</title>
    <url>/2021/08/18/Android%E5%AD%A6%E4%B9%A0/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="Activity的生命周期简单的例子"><a href="#Activity的生命周期简单的例子" class="headerlink" title="Activity的生命周期简单的例子"></a>Activity的生命周期简单的例子</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Activity</code>是android当中重要的内容，每个<code>Activity</code>实例都有其生命周期。在其生命周期内，<code>Activity</code>在运行、暂停、停止和不存在这四种状态间转换，每次状态转换时，都有相应的Activity方法发消息通知activity。Activity 类提供六个核心回调：<code>onCreate()、onStart()、onResume()、onPause()、onStop()、onDestory()</code>，官方给出的状态变化以及函数调用如下图所展示</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/activity_lifecycle.png" alt="img"></p>
<p>但是我感觉比较好理解的是《Android编程权威指南》中的图解</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210818155656276.png" alt="image-20210818155656276"></p>
<p>可以根据内存中有没有<code>activity</code>的实例，用户是否看得到，是否活跃在前台（等待或接受用户输入中）等这些作为判断，调用了那些函数。完整总结如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">有内存实例</th>
<th style="text-align:center">用户可见</th>
<th style="text-align:center">处于前台</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">不存在</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">停止</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">暂停</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是或者部分</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">运行</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
</div>
<span id="more"></span>
<h2 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h2><h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><p>在<code>Android Studio</code>中创建项目<code>ActivityLifecycle</code>，然后在<code>MainActivity</code>中写入下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.activitylifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate() called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStart() called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onResume() called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onPause() called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStop();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStop() called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroy() called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行程序，安装到Android手机上，再查看LogCat</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210818172208317.png" alt="image-20210818172208317"></p>
<p>可以看到<code>onCreate()、onStart()、onResume()</code>按照顺序被调用，这也符合<code>Activity</code>的状态从<code>不存在→停止→暂停→运行</code>的转变。</p>
<p>接着在手机上我们可以单击后退键，再查看LogCat。可以看到，日志显示 <code>MainActivity</code>的 <code>onPause()、 onStop() 、onDestroy()</code>方法被依次调用了</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210818173551090.png" alt="image-20210818173551090"></p>
<p>单击设备的后退键，相当于告诉Android系统：“activity已用完，现在不需要它了。”随即， 系统就销毁了该activity的视图及其内存里的相关信息。这实际是Android系统节约使用设备有限资源的一种方式。对应着<code>Activity</code>中状态从<code>运行→暂停→停止→不存在</code>，这也对应的图中的对应变化。</p>
<h3 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h3><p>我们再次点击应用从而启动应用，启动应用之后我们点击主屏幕键或者说是home键，退到主屏幕</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210818181407786.png" alt="image-20210818181407786"></p>
<p>日志上显示，Android先创建了全新的<code>MainActivity</code>实例， 然后调用<code>onCreate()、onStart()和onResume()</code>方法。<code>MainActivity</code>从不存在变为运行状态。然后我们点击主屏幕键后，系统调用了<code>MainActivity</code>的<code>`onPause()和onStop()</code>方法，但并没有调用<code>onDestroy()</code>方法，说明点击主屏幕键只会使得Activity处于停止状态（在内存中， 但不可见，不会活动在前台）。</p>
<p>然后再次点击应用，启动应用</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210818181510264.png" alt="image-20210818181510264"></p>
<p>LogCat日志显示，系统没有调用onCreate()方法（因为Activity实例还在内存里，自然不用重建了），而是调用了onStart()和onResume()方法。用户按了主屏幕键后，MainActivity 最后进入停止状态，再次调出应用时，MainActivity 只需要重新启动（进入暂停状态，用户可 见），然后继续运行（进入运行状态，活动在前台）。</p>
<p>需要注意的是，停止的activity能够存在多久，谁也无法保证。系统需要回收内存时，它将首先销毁那些停止的activity</p>
<h3 id="实例三"><a href="#实例三" class="headerlink" title="实例三"></a>实例三</h3><p>我们新增加一个<code>OtherActivity</code>,然后更改<code>MainActivity</code>中的代码和<code>activity_main.xml</code>中代码</p>
<p><code>MainActivity</code>中代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button mButton;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate() called&quot;</span>);</span><br><span class="line">        mButton = findViewById(R.id.button);</span><br><span class="line">        mButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, OtherActivity.class);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>activity_main.xml</code>中代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;to other activity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们运行代码点击其中的按钮</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210818222756707.png" alt="image-20210818222756707"></p>
<p>该实例其实是和实例二相同，跳转其他<code>OtherActivity</code>之后,<code>MainActivity</code>就停止了。</p>
<h3 id="实例四"><a href="#实例四" class="headerlink" title="实例四"></a>实例四</h3><p>我们点击应用，再旋转屏幕我们可以截图可以发现旋转之后<code>Activity</code>是毁灭之后再次重建，简单理解是设备旋转时，系统会销毁当前<code>Activity</code>实例，然后创建一个新的<code>Activity</code>实例</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210819101657554.png" alt="image-20210819101657554"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Activity</code>的状态变化可以以内存中有没有<code>activity</code>的实例，用户是否看得到，是否活跃在前台（等待或接受用户输入中）等这些作为判断，掌握状态的这几个点就比较好区分，目前也举出了几个例子方便我们理解<code>Activity</code>状态改变，但是遗憾的是没有遇到只是暂停的这种简单例子</p>
<p><strong>参考：</strong></p>
<ul>
<li>《Andorid编程权威指南》</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Andorid编程权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity之间通讯</title>
    <url>/2021/08/20/Android%E5%AD%A6%E4%B9%A0/Activity%E4%B9%8B%E9%97%B4%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<h1 id="Activity之间通讯"><a href="#Activity之间通讯" class="headerlink" title="Activity之间通讯"></a>Activity之间通讯</h1><p><code>Activity</code>之间经常需要传输数据，我们常用的方法就是使用<code>Intent</code></p>
<span id="more"></span>
<h2 id="实例一单方面传输"><a href="#实例一单方面传输" class="headerlink" title="实例一单方面传输"></a>实例一单方面传输</h2><p>创建项目<code>TwoActivity</code>，然后在项目中除<code>MainActivity</code>之外，再添加一个<code>SecondActivity</code></p>
<p>在<code>activity_main.xml</code>写下以下内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/editText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:ems</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;please input something&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.497&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;send to secondActivity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/editText&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>MainActivity</code>中写下以下内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.twoactivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EditText mEditText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button mButton;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mEditText = findViewById(R.id.editText);</span><br><span class="line">        mButton = findViewById(R.id.button);</span><br><span class="line">        mButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> mEditText.getText().toString();</span><br><span class="line">                <span class="comment">//启动另一个Activity</span></span><br><span class="line">                <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, SecondAcrivity.class);</span><br><span class="line">                intent.putExtra(<span class="string">&quot;information&quot;</span>, str);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>activity_second.xml</code>写入以下内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/editText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:ems</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;please input something&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.497&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;send to secondActivity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/editText&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>SecondActivity</code>写下以下内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.twoactivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondAcrivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_second);</span><br><span class="line">        mTextView = findViewById(R.id.textView);</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line">        <span class="type">String</span> <span class="variable">information</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;information&quot;</span>);</span><br><span class="line">        mTextView.setText(information);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，再输入框输入<code>test</code>，然后按下按钮</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210820175350586.png" alt="image-20210820175350586"></p>
<p>可以看到在的<code>SecondActivity</code>上展示了我们输入的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210820175557003.png" alt="image-20210820175557003" style="zoom:50%;" /></p>
<p>可以看到需要传输的内容从<code>MainActivity</code>传输到了<code>SecondActivity</code></p>
<h2 id="实例二双方互相传输"><a href="#实例二双方互相传输" class="headerlink" title="实例二双方互相传输"></a>实例二双方互相传输</h2><p>有的时候我们需要把信息从<code>MainActivity</code>传输到<code>SecondActivity</code>，这种类似于父子<code>Activity</code>之间的传输，原本是使用<code>startActivityForResult</code>进行处理，但是由于<code>startActivityForResult</code>存在的问题，现在官方推荐的是使用<code>registerForActivityResult()</code>等<code>Activity Results API</code>相关的方法</p>
<p>👉官方文档：<a href="https://developer.android.com/training/basics/intents/result">https://developer.android.com/training/basics/intents/result</a></p>
<p>更改<code>MainActivity</code>中代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.twoactivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.activity.result.ActivityResultCallback;</span><br><span class="line"><span class="keyword">import</span> androidx.activity.result.ActivityResultLauncher;</span><br><span class="line"><span class="keyword">import</span> androidx.activity.result.contract.ActivityResultContract;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EditText mEditText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button mButton;</span><br><span class="line">	<span class="comment">//制定协议</span></span><br><span class="line">    <span class="keyword">private</span> ActivityResultContract&lt;String, String&gt; mStringStringActivityResultContract = <span class="keyword">new</span> <span class="title class_">ActivityResultContract</span>&lt;String, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Intent <span class="title function_">createIntent</span><span class="params">(<span class="meta">@NonNull</span> Context context, String input)</span> &#123;</span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, SecondAcrivity.class);</span><br><span class="line">            intent.putExtra(<span class="string">&quot;information&quot;</span>, input);</span><br><span class="line">            <span class="keyword">return</span> intent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">parseResult</span><span class="params">(<span class="type">int</span> resultCode, <span class="meta">@Nullable</span> Intent intent)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultCode != Activity.RESULT_OK || intent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> intent.getStringExtra(<span class="string">&quot;second information&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//制定启动器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ActivityResultLauncher</span> <span class="variable">mActivityResultLauncher</span> <span class="operator">=</span> registerForActivityResult(mStringStringActivityResultContract,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ActivityResultCallback</span>&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(String result)</span> &#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="built_in">this</span>, result, Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mEditText = findViewById(R.id.editText);</span><br><span class="line">        mButton = findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line">        mButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> mEditText.getText().toString();</span><br><span class="line">                mActivityResultLauncher.launch(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ActivityResultContract</code>和<code>ActivityResultLauncher</code>是<code>Activity Results API</code>中两个重要的组件</p>
<ul>
<li><code>ActivityResultContract</code>: 协议，它定义了如何传递数据和如何处理返回的数据。<code>ActivityResultContract</code>是一个抽象类，你需要继承它来创建自己的协议，每个 <code>ActivityResultContract</code> 都需要定义输入和输出类，如果您不需要任何输入，可使用 Void（在 Kotlin 中，使用 Void? 或 Unit）作为输入类型。</li>
<li><code>ActivityResultLauncher</code>: 启动器，调用<code>ActivityResultLauncher</code>的<code>launch</code>方法来启动页面跳转，作用相当于原来的<code>startActivity()</code></li>
</ul>
<p><code>SecondAcrivity</code>写入以下内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.twoactivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondAcrivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_second);</span><br><span class="line">        mTextView = findViewById(R.id.textView);</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line">        <span class="type">String</span> <span class="variable">information</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;information&quot;</span>);</span><br><span class="line">        mTextView.setText(information);</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">        data.putExtra(<span class="string">&quot;second information&quot;</span>, <span class="string">&quot;返回了secondActivity的信息&quot;</span>);</span><br><span class="line">        <span class="comment">//设置返回结果</span></span><br><span class="line">        setResult(Activity.RESULT_OK, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现子<code>activity</code>发送返回信息给父<code>activity</code>，有以下两种方法可用：</p>
<p> <code>public final void setResult(int resultCode)</code></p>
<p>  <code>public final void setResult(int resultCode, Intent data)</code></p>
<p>一般来说，参数<code>resultCode</code>可以是以下任意一个预定义常量。</p>
<ul>
<li><code>Activity.RESULT_OK</code></li>
<li><code>Activity.RESULT_CANCELED</code></li>
</ul>
<p>当然如需自己定义结果代码，还可使用另一个常量：<code>RESULT_FIRST_USER</code>。</p>
<p>在父<code>activity</code>需要依据子<code>activity</code>的完成结果采取不同操作时，设置结果代码就非常有用。 例如，假设子<code>activity</code>有一个<code>OK</code>按钮和一个<code>Cancel</code>按钮，并且每个按钮的单击动作分别设置 有不同的结果代码。那么，根据不同的结果代码，父<code>activity</code>就能采取不同的操作。  子<code>activity</code>可以不调用<code>setResult(...)</code>方法。如果不需要区分附加在intent上的结果或其他信 息，可让操作系统发送默认的结果代码。如果子<code>activity</code>是以调用<code>startActivityForResult(...)</code>或者<code>ActivityResultLauncher</code>方法启动的，结果代码则总是会返回给父<code>activity</code>。在没有调用<code>setResult(...)</code>方法的情况下， 如果用户按了后退按钮，父<code>activity</code>则会收到<code>Activity.RESULT_CANCELED</code>的结果代码。</p>
<p>最终结果展示，发送信息之后按返回键，会出结果展示</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210820215024582.png" alt="image-20210820215024582"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写了两个有关<code>Android</code>之间<code>Activity</code>的信息相互传输</p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://segmentfault.com/a/1190000037601888">https://segmentfault.com/a/1190000037601888</a></li>
<li><a href="https://developer.android.com/training/basics/intents/result">https://developer.android.com/training/basics/intents/result</a></li>
<li>《Android编程权威指南中文第3版》</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Andorid编程权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title>Android权限学习</title>
    <url>/2021/09/18/Android%E5%AD%A6%E4%B9%A0/Android%E6%9D%83%E9%99%90%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Android权限学习"><a href="#Android权限学习" class="headerlink" title="Android权限学习"></a>Android权限学习</h1><p>Android权限可以分为两大类：安装时权限、运行时权限和特殊权限，安装时权限包括普通权限和签名权限。</p>
<p>一般在应用商城上架的软件都可以看到对应的需要的权限，下面就是Android的王者荣誉当中展示的需要的权限</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210918202325809.png" alt="image-20210918202325809"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210918202805326.png" alt="image-20210918202805326"></p>
<p><strong>本文主要针对于<code>Android6.0</code>之后的介绍！！！</strong></p>
<span id="more"></span>
<h2 id="权限介绍"><a href="#权限介绍" class="headerlink" title="权限介绍"></a>权限介绍</h2><h3 id="普通权限"><a href="#普通权限" class="headerlink" title="普通权限"></a>普通权限</h3><p>在官方文档当中，普通权限此类权限允许访问超出应用沙盒的数据和执行超出应用沙盒的操作。但是，这些数据和操作对用户隐私及对其他应用的操作带来的风险非常小。系统会为普通权限分配“normal”保护级别</p>
<p>这类权限不太需要重点关注，申请这类权限只需要在<code>AndroidManifest</code>中声明即可</p>
<h3 id="签名权限"><a href="#签名权限" class="headerlink" title="签名权限"></a>签名权限</h3><p>官方的介绍是当应用声明了其他应用已定义的签名权限时，如果两个应用使用同一证书进行签名，系统会在安装时向前者授予该权限。否则，系统无法向前者授予该权限。</p>
<p>系统会为签名权限分配“signature”保护级别</p>
<p>目前我并没有查找到和签名权限相关的较多资料暂且跳过。</p>
<h3 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h3><p>运行时权限又成为危险权限，他是学习的重点，该权限在系统请求的时候，系统会显示运行时权限提示。</p>
<p>比如我在市面上找到的一款小说软件，他就申请的电话权限。</p>
<p>后面我们也会实现这样的功能</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210918205745566.png" alt="image-20210918205745566"></p>
<p>系统会为运行时权限分配“dangerous”保护级别</p>
<h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><p>特殊权限与特定的应用操作相对应。只有平台和原始设备制造商 (OEM) 可以定义特殊权限。此外，如果平台和 OEM 想要防止有人执行功能特别强大的操作（例如通过其他应用绘图），通常会定义特殊权限。</p>
<p>系统设置中的<strong>特殊应用访问权限</strong>页面包含一组用户可切换的操作。其中的许多操作都以特殊权限的形式实现。</p>
<p>每项特殊权限都有自己的实现细节。</p>
<p>系统会为特殊权限分配“appop”保护级别。</p>
<p>特殊权限不在本次学习的重点之内，基本可以忽略</p>
<h2 id="声明应用权限"><a href="#声明应用权限" class="headerlink" title="声明应用权限"></a>声明应用权限</h2><p>声明权限比较简单只需要在<code>AndroidManifest</code>中加入对应的权限就行</p>
<p>如申明网络权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>申明了权限之后如果该权限是安装时权限，系统会在安装您的应用时自动为其授予相应权限。</p>
<p><strong>如果该权限时运行时权限，那么光声明权限还是不够的，还需要继续请求权限。</strong></p>
<p>当然如果是运行时权限，直接不写声明，那么请求权限是发不出去的，一发出去就会被拒绝。</p>
<h2 id="请求权限"><a href="#请求权限" class="headerlink" title="请求权限"></a>请求权限</h2><h3 id="检测权限"><a href="#检测权限" class="headerlink" title="检测权限"></a>检测权限</h3><p>请求的权限一般是危险权限也就是运行时权限，在请求权限之前我们可以检测一下权限，查看权限是否授予</p>
<p>检查权限使用的函数是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">checkSelfPermission</span> <span class="params">(Context context, String permission)</span></span><br></pre></td></tr></table></figure>
<p>此方法会返回 <a href="https://developer.android.com/reference/android/content/pm/PackageManager#PERMISSION_GRANTED"><code>PERMISSION_GRANTED</code></a> 或 <a href="https://developer.android.com/reference/android/content/pm/PackageManager#PERMISSION_DENIED"><code>PERMISSION_DENIED</code></a>。然后我们就可以知道是否获得了该权限</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    <span class="type">int</span> <span class="variable">permissionCheck</span> <span class="operator">=</span> ContextCompat.checkSelfPermission(<span class="built_in">this</span>, Manifest.permission.CAMERA);</span><br><span class="line">    <span class="keyword">if</span> (permissionCheck == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Manifest.permission.CAMERA is  granted&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Manifest.permission.CAMERA is not granted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="请求对应权限"><a href="#请求对应权限" class="headerlink" title="请求对应权限"></a>请求对应权限</h3><p>请求对应的权限的代码目前看来有两种方式，第一种方式是使用<code>ActivityResultLauncher</code>，第二种是使用函数<code>requestPermissions</code></p>
<h4 id="使用ActivityResultLauncher"><a href="#使用ActivityResultLauncher" class="headerlink" title="使用ActivityResultLauncher"></a>使用<code>ActivityResultLauncher</code></h4><p>使用<code>ActivityResultLauncher</code>需要先指定<code>ActivityResultContract</code>类型的协议不过在Android当中已经有实现好的类，那就是<code>RequestPermission</code>类</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210923204407573.png" alt="image-20210923204407573"></p>
<p>可以看到<code>RequestPermission</code>类是<code>ActivityResultContract&lt;String,Boolean&gt;</code>类型的，其中<code>String</code>代表权限的名字，而<code>Boolean</code>代表最后返回是否授予权限的结果，所以使用起来比较简单，类似有Activity的跳转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册权限回调，它处理用户对系统权限对话框的响应。</span></span><br><span class="line"><span class="comment">//将返回值(ActivityResultLauncher的一个实例)保存为实例变量。</span></span><br><span class="line"><span class="keyword">private</span> ActivityResultLauncher&lt;String&gt; requestPermissionLauncher =</span><br><span class="line">        registerForActivityResult(<span class="keyword">new</span> <span class="title class_">ActivityResultContracts</span>.RequestPermission(), isGranted -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (isGranted) &#123;</span><br><span class="line">                <span class="comment">// 权限被授予的情况</span></span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;第一种方式：权限被授予&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//向用户解释该功能不可用，因为该功能需要用户拒绝的权限。</span></span><br><span class="line">                <span class="comment">// 同时，尊重用户的决定。不要链接到系统设置，试图说服用户改变他们的决定。</span></span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;第一种方式：权限未授予&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>我们请求摄像头权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式使用 ActivityResultLauncher</span></span><br><span class="line">requestPermissionLauncher.launch(Manifest.permission.CAMERA);</span><br></pre></td></tr></table></figure>
<p>调用结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210923205400390.png" alt="image-20210923205400390"></p>
<h4 id="使用requestPermissions"><a href="#使用requestPermissions" class="headerlink" title="使用requestPermissions"></a>使用<code>requestPermissions</code></h4><p><code>requestPermissions</code>也可请求权限，并且可以请求多个权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">requestPermissions</span><span class="params">(<span class="meta">@NonNull</span> String[] permissions, <span class="type">int</span> requestCode)</span></span><br></pre></td></tr></table></figure>
<p>使用<code>requestPermissions</code>请求权限之后，需要使用<code>onRequestPermissionsResult</code>函数作为回调函数</p>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="comment">// You can directly ask for the permission.</span></span><br><span class="line">requestPermissions(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Manifest.permission.CAMERA&#125;, PERMISSION_REQUEST_CODE);</span><br></pre></td></tr></table></figure>
<p>回调后方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRequestPermissionsResult</span><span class="params">(<span class="type">int</span> requestCode, String[] permissions, <span class="type">int</span>[] grantResults)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> PERMISSION_REQUEST_CODE:</span><br><span class="line">            <span class="comment">// If request is cancelled, the result arrays are empty.</span></span><br><span class="line">            <span class="keyword">if</span> (grantResults.length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="comment">// Permission is granted. Continue the action or workflow</span></span><br><span class="line">                <span class="comment">// in your app.</span></span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;第二种方式：权限被授予&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Explain to the user that the feature is unavailable because</span></span><br><span class="line">                <span class="comment">// the features requires a permission that the user has denied.</span></span><br><span class="line">                <span class="comment">// At the same time, respect the user&#x27;s decision. Don&#x27;t link to</span></span><br><span class="line">                <span class="comment">// system settings in an effort to convince the user to change</span></span><br><span class="line">                <span class="comment">// their decision.</span></span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;第二种方式：权限未被授予&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Other &#x27;case&#x27; lines to check for other</span></span><br><span class="line">    <span class="comment">// permissions this app might request.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用起来比较简单也比较方便</p>
<h4 id="shouldShowRequestPermissionRationale函数理解"><a href="#shouldShowRequestPermissionRationale函数理解" class="headerlink" title="shouldShowRequestPermissionRationale函数理解"></a><code>shouldShowRequestPermissionRationale</code>函数理解</h4><p><code>shouldShowRequestPermissionRationale</code>向用户显示指导界面，在此界面中说明用户希望启用的功能为何需要特定权限。</p>
<p><code>shouldShowRequestPermissionRationale</code>函数会返回true或者false。按照请求权限的流程可以这样区分</p>
<p>①刚刚安装程序打开程序，<code>shouldShowRequestPermissionRationale</code>返回false，这个时候会弹出权限请求框，如果我们允许那么<code>shouldShowRequestPermissionRationale</code>会一直返回false</p>
<p>②如果①里面拒绝了权限，再次进行程序<code>shouldShowRequestPermissionRationale</code>会返回true，这时候我们应该展示为啥需要权限</p>
<p>③如果我们一直请求权限，然后用户不耐烦了，点击了不再询问，那么<code>shouldShowRequestPermissionRationale</code>会一直返回false</p>
<p>举个例子，我们在第二个分支使用<code>shouldShowRequestPermissionRationale</code>，它会弹出一个对话框，说明权限的重要性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mTextView = findViewById(R.id.textView);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="built_in">this</span>, Manifest.permission.CAMERA) ==</span><br><span class="line">                PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            <span class="comment">// You can use the API that requires the permission.</span></span><br><span class="line">            Log.d(TAG, <span class="string">&quot;Manifest.permission.CAMERA is  granted&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldShowRequestPermissionRationale(Manifest.permission.CAMERA)) &#123;</span><br><span class="line">            <span class="comment">//说明权限重要性</span></span><br><span class="line">            showNormalDialog();</span><br><span class="line">            <span class="comment">//第一种方式使用 ActivityResultLauncher</span></span><br><span class="line">            requestPermissionLauncher.launch(Manifest.permission.CAMERA);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// You can directly ask for the permission.</span></span><br><span class="line">            <span class="comment">// The registered ActivityResultCallback gets the result of this request.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//第一种方式使用 ActivityResultLauncher</span></span><br><span class="line"><span class="comment">//            requestPermissionLauncher.launch(Manifest.permission.CAMERA);</span></span><br><span class="line">            <span class="comment">//第二种方式</span></span><br><span class="line">            <span class="comment">// You can directly ask for the permission.</span></span><br><span class="line">            requestPermissions(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Manifest.permission.CAMERA&#125;, PERMISSION_REQUEST_CODE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showNormalDialog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* @setIcon 设置对话框图标</span></span><br><span class="line"><span class="comment">         * @setTitle 设置对话框标题</span></span><br><span class="line"><span class="comment">         * @setMessage 设置对话框消息提示</span></span><br><span class="line"><span class="comment">         * setXXX方法返回Dialog对象，因此可以链式设置属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> AlertDialog.<span class="type">Builder</span> <span class="variable">normalDialog</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AlertDialog</span>.Builder(MainActivity.<span class="built_in">this</span>);</span><br><span class="line">        normalDialog.setTitle(<span class="string">&quot;我是一个普通Dialog&quot;</span>);</span><br><span class="line">        normalDialog.setMessage(<span class="string">&quot;我需要摄像头权限，快给我！！！&quot;</span>);</span><br><span class="line">        normalDialog.setPositiveButton(<span class="string">&quot;确定&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialog, <span class="type">int</span> which)</span> &#123;</span><br><span class="line">                        <span class="comment">//...To-do</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 显示</span></span><br><span class="line">        normalDialog.show();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们一开始安装程序进入程序，<code>shouldShowRequestPermissionRationale</code>返回false，所以进入第三个分支，并且请求授予权限</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210927111601508.png" alt="image-20210927111601508"></p>
<p>我们点击拒绝后，关闭程序(后台杀死)，再次进入程序</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210927111714036.png" alt="image-20210927111714036"></p>
<p>点击拒绝后可以看到下图的内容，说明这个时候进入第二个分支，<code>shouldShowRequestPermissionRationale</code>返回true</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210927111813939.png" alt="image-20210927111813939"></p>
<p>关闭程序(后台杀死)，再次进入程序，这次我们点击拒绝并且不在询问，然后再关闭程序(后台杀死)，再进入</p>
<p>这次直接跳转第三个分支，并且直接拒绝权限授予，说明<code>shouldShowRequestPermissionRationale</code>返回false</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210927112331524.png" alt="image-20210927112331524"></p>
<h3 id="请求权限建议流程："><a href="#请求权限建议流程：" class="headerlink" title="请求权限建议流程："></a>请求权限建议流程：</h3><p>官方建议流程就是上面那种类似于三个分支的流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(</span><br><span class="line">        CONTEXT, Manifest.permission.REQUESTED_PERMISSION) ==</span><br><span class="line">        PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    <span class="comment">// You can use the API that requires the permission.</span></span><br><span class="line">    performAction(...);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldShowRequestPermissionRationale(...)) &#123;</span><br><span class="line">    <span class="comment">// In an educational UI, explain to the user why your app requires this</span></span><br><span class="line">    <span class="comment">// permission for a specific feature to behave as expected. In this UI,</span></span><br><span class="line">    <span class="comment">// include a &quot;cancel&quot; or &quot;no thanks&quot; button that allows the user to</span></span><br><span class="line">    <span class="comment">// continue using your app without granting the permission.</span></span><br><span class="line">    showInContextUI(...);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// You can directly ask for the permission.</span></span><br><span class="line">    <span class="comment">// The registered ActivityResultCallback gets the result of this request.</span></span><br><span class="line">    requestPermissionLauncher.launch(</span><br><span class="line">            Manifest.permission.REQUESTED_PERMISSION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个分支，一个是获得了权限，一个是没有完全拒绝，可以说明权限的重要性，一个是请求权限。比较简单，可以看看上面的例子</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>请求权限总算是弄懂了不少，但是具体那个权限需要查那个目前还不清楚，等后续总结后再来讲讲。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Andorid编程权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title>Android的设备配置和备选资源</title>
    <url>/2021/08/19/Android%E5%AD%A6%E4%B9%A0/Android%E7%9A%84%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%87%E9%80%89%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="Android的设备配置和配置修饰符"><a href="#Android的设备配置和配置修饰符" class="headerlink" title="Android的设备配置和配置修饰符"></a>Android的设备配置和配置修饰符</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>设备配置</strong>是一系列特征组合，用来描述设备当前状态。这些特征有：屏幕方向、屏幕像素密度、屏幕尺寸、键盘类型、底座模式以及语言等。 通常，为匹配不同的设备配置，应用会提供不同的备选资源。比如：为适应不同分辨率的屏幕，向项目添加多套标就是这样一个使用案例。 可以说这些各种各样的配置只是为了兼容各种各种乱七八糟的设备</p>
<span id="more"></span>
<h2 id="旋转屏幕"><a href="#旋转屏幕" class="headerlink" title="旋转屏幕"></a>旋转屏幕</h2><p>设备的屏幕像素密度是个固定的设备配置，无法在运行时发生改变。然而，屏幕方向等特征可以在应用运行时改变。 在运行时配置变更（runtime configuration change）发生时，可能会有更合适的资源来匹配新 的设备配置。于是，Android回销毁当前activity，为新配置寻找最佳资源，然后创建新实例使用这些资源。</p>
<p>创建一个<code>Activitycompatible</code>的项目，<code>MainActivity</code>保持默认</p>
<p>在<code>activity_main.xml</code>中写入下列代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;这是竖屏展示!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着我们创建建水平模式布局，在项目工具窗口中，右键单击res目录后选择New → Android resource directory菜单项。创建资源目录界面列出了资源类型及其对应的资源特征，如图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210819173327553.png" alt="image-20210819173327553"></p>
<p>从资源类型（Resource type） 列表中选择layout，保持Source set的main选项不变。</p>
<p>接下来选中待选资源特征列表中的Orientation，然后单击<code>&gt;&gt;</code>按钮将其移动至已选资源特征 （Chosen qualifiers）区域。 最后，确认选中Screen orientation下拉列表中的Landscape选项，并确保目录名（Directory  name）显示为layout-land，如图所示。</p>
<p>这个窗口看起来有模有样，但实际用途仅限于设置目录名。点击OK按钮让Android Studio创建res/layout-land。 这里的-land后缀名是配置修饰符的一个使用例子。Android依靠res子目录的配置修饰符定位最佳资源以匹配当前设备配置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210819180013963.png" alt="image-20210819180013963"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210819180056828.png" alt="image-20210819180056828"></p>
<p>我们将<code>layout-land</code>中的<code>activity_main.xml</code>写入以下内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;这是横屏展示!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行程序，竖屏时结果如下（这个截图是使用Android studio截图的，有点长）</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210819212529509.png" alt="image-20210819212529509" style="zoom:50%;" /></p>
<p>我们再进行横屏，结果如下(吐槽一下，这个黑屏部分时刘海屏)</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210819212627488.png" alt="image-20210819212627488"></p>
<p>可以看到这两个界面使用的<code>layput</code>文件是不相同的，通过不同目录名或者叫修饰符由系统进行选择</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Andorid编程权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title>Android编程权威指南第1章挑战练习</title>
    <url>/2021/08/19/Android%E5%AD%A6%E4%B9%A0/Android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC1%E7%AB%A0%E6%8C%91%E6%88%98%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Android编程权威指南第1章挑战练习"><a href="#Android编程权威指南第1章挑战练习" class="headerlink" title="Android编程权威指南第1章挑战练习"></a>Android编程权威指南第1章挑战练习</h1><h2 id="定制-toast-消息"><a href="#定制-toast-消息" class="headerlink" title="定制 toast 消息"></a>定制 toast 消息</h2><p>这个练习需要你定制toast消息，改在屏幕顶部而不是底部显示弹出消息。这需要使用Toast 类的setGravity方法，并使用Gravity.TOP重力值。具体如何使用，请参考Android开发者文档。 </p>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>参考官方给定的<code>Toast</code>例子结合对<code>setGravity</code>函数的讲解</p>
<p>我们只需要在<code>QuizActivity</code>中的函数中填入下属代码即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        mTrueButton = (Button) findViewById(R.id.true_button);</span><br><span class="line">        mTrueButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="type">Toast</span> <span class="variable">toast</span> <span class="operator">=</span> Toast.makeText(QuizActivity.<span class="built_in">this</span>, R.string.correct_toast, Toast.LENGTH_SHORT);</span><br><span class="line"><span class="comment">//                第一章挑战练习:设置toast在上方显示</span></span><br><span class="line">                toast.setGravity(Gravity.TOP, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                toast.show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://developer.android.com/reference/android/widget/Toast?hl=en#setGravity(int,%20int,%20int">https://developer.android.com/reference/android/widget/Toast?hl=en#setGravity(int,%20int,%20int</a>)</li>
<li><a href="https://developer.android.com/guide/topics/ui/notifiers/toasts">https://developer.android.com/guide/topics/ui/notifiers/toasts</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Andorid编程权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title>ConstraintLayout学习</title>
    <url>/2021/08/21/Android%E5%AD%A6%E4%B9%A0/ConstraintLayout%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="ConstraintLayout学习"><a href="#ConstraintLayout学习" class="headerlink" title="ConstraintLayout学习"></a>ConstraintLayout学习</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ConstraintLayout似乎是现在Android官方目前推荐的一个layout，性能也不错，但是我目前还不是很会使用这个东西，所以看网上的资料学习了一下爱，顺便记录一下。</p>
<span id="more"></span>
<h2 id="使用ConstraintLayout"><a href="#使用ConstraintLayout" class="headerlink" title="使用ConstraintLayout"></a>使用ConstraintLayout</h2><h3 id="1-Constraint（约束）"><a href="#1-Constraint（约束）" class="headerlink" title="1.Constraint（约束）"></a>1.Constraint（约束）</h3><p>Constraint即约束，对一个View的Left（Start），Top，Right（End），Bottom四个方向添加Constraint条件后，此View的位置也就确定下来了，Constraint也是ConstraintLayout最基本的操作。</p>
<p>ConstraintLayout包含这些属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app:layout_constraintBottom_toBottomOf//举一反三app:layout_constraintBottom_toTopOf</span><br><span class="line">app:layout_constraintEnd_toEndOf//举一反三app:layout_constraintEnd_toStartOf</span><br><span class="line">app:layout_constraintStart_toStartOf//举一反三app:layout_constraintStart_toEndOf</span><br><span class="line">app:layout_constraintTop_toTopOf//举一反三app:layout_constraintTop_toBottomOf</span><br></pre></td></tr></table></figure>
<p>这些属性比较简单，简单来说就是到某个view到某个方向的约束，比如top约束包含：</p>
<p>约束在某个View的top(意思是和当前View的top这个View的top对齐)或者某个View的bottom(意思是和当前View的top这个View的bottom对齐)，因此四个方向的约束条件相加总共是有8个约束条件。</p>
<p>创建<code>Constraint</code>如图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/动画.gif" alt="动画"></p>
<p><code>Constraint</code>的属性如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210821174332342.png" alt="image-20210821174332342"></p>
<p><code>view</code>水平方向和竖直方向的尺寸是分别由宽度设置和高度设置决定的。能设置的值有以下三种</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210821174936423.png" alt="image-20210821174936423"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>设置类型</th>
<th>设置值</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>固定大小（Fixed）</td>
<td>Xdp</td>
<td>以dp为单位，为视图指定固定值</td>
</tr>
<tr>
<td>包裹内容（wrap_content）</td>
<td>wrap_content</td>
<td>设置视图想要的尺寸（随内容走），也就是说，大到足够容纳内容</td>
</tr>
<tr>
<td>动态适应(match Constraint)</td>
<td>0dp</td>
<td>允许视图缩放以满足指定约束</td>
</tr>
</tbody>
</table>
</div>
<p>对于前两类理解起来可能比较简单，对于动态适应的话我理解的是就是之前的<code>match parent</code>,设置为动态适应之后就回充满整个Constraint</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210821180855391.png" alt="image-20210821180855391"></p>
<h3 id="2-Bias"><a href="#2-Bias" class="headerlink" title="2.Bias"></a>2.Bias</h3><p><code>Bias</code>是偏置,主要用来设置位置偏移比例，取值范围从0到1，默认是0.5也就是居中。这个偏置对应着图中红色框框部分,可以通过移动这一部分进行<code>view</code>移动，当然也可以在蓝色框框部分进行填写</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210821220201491.png" alt="image-20210821220201491"></p>
<p>我们可以通过修改<code>Bias</code>的值来移动位置，比如修改成0.2，然后展示结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210821220900560.png" alt="image-20210821220900560"></p>
<h3 id="3-Guideline"><a href="#3-Guideline" class="headerlink" title="3.Guideline"></a>3.Guideline</h3><p><code>Guideline</code>比较简单，可以理解成一个不可见的<code>View</code>放在<code>ConstraintLayout</code>某个位置，然后子<code>View</code>就可以以他作为<code>Constraint</code>目标来定位。</p>
<p>比如说我们加一个<code>horizontal guideline</code> </p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210821230855642.png" alt="image-20210821230855642"></p>
<h3 id="4-Barrier"><a href="#4-Barrier" class="headerlink" title="4.Barrier"></a>4.Barrier</h3><p><code>Barrier</code>意为屏障，和<code>Guideline</code>相似，也是一个不可见的<code>View</code>，但<code>Barrier</code>可以保证一直位于某几个<code>View</code>的<code>Top/Bottom/Left/Right</code>下面，有些场景下可能很有用。</p>
<p>比如，我们需要一个<code>ImageView</code>一直在一排按钮之下<code>100dp</code>的位置，就可以使用这个<code>Barrier</code>，可以看到动图上<code>ImageView</code>是一直在这三个按钮之下<code>100dp</code>的位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/动画2.gif" alt="动画2"></p>
<p>具体做法是先添加一个<code>Barrier</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210822110903058.png" alt="image-20210822110903058"></p>
<p>然后完成<code>View</code>的绑定，在<code>ComponentTree</code>窗口里，直接拖动对应的子<code>View</code>到<code>Barrier</code>里就完成绑定了，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210822111508491.png" alt="image-20210822111508491"></p>
<p>然后在属性中设置<code>Barrier</code>的方向</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210822111630034.png" alt="image-20210822111630034"></p>
<p>最后<code>View</code>添加约束到<code>Barrier</code></p>
<p>我在可视化编辑器上添加添加不了这个约束，我采取的是手动添加</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210822112652686.png" alt="image-20210822112652686"></p>
<p>最终达到的效果如上面动图一样</p>
<h3 id="5-Chain"><a href="#5-Chain" class="headerlink" title="5.Chain"></a>5.Chain</h3><p>链是一组视图，这些视图通过双向位置约束条件相互链接到一起，ConstraintLayout借助此功能，可以实现LinearLayout大部分效果。</p>
<p>这是官方给定的一组图</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/constraint-chain-styles_2x.png" alt="img"></p>
<ol>
<li><strong>Spread</strong>：视图是均匀分布的（在考虑外边距之后）。这是默认值。</li>
<li><strong>Spread inside</strong>：第一个和最后一个视图固定在链两端的约束边界上，其余视图均匀分布。</li>
<li><strong>Weighted</strong>：当链设置为 <strong>spread</strong> 或 <strong>spread inside</strong> 时，您可以通过将一个或多个视图设置为“match constraints”(<code>0dp</code>) 来填充剩余空间。默认情况下，设置为“match constraints”的每个视图之间的空间均匀分布，但您可以使用 <code>layout_constraintHorizontal_weight</code> 和 <code>layout_constraintVertical_weight</code> 属性为每个视图分配重要性权重。如果您熟悉<a href="https://developer.android.com/guide/topics/ui/layout/linear?hl=zh-cn">线性布局</a>中的 <code>layout_weight</code> 的话，就会知道该样式与它的原理是相同的。因此，权重值最高的视图获得的空间最大；相同权重的视图获得同样大小的空间。</li>
<li><strong>Packed</strong>：视图打包在一起（在考虑外边距之后）。 然后，您可以通过更改链的头视图偏差调整整条链的偏差（左/右或上/下）。</li>
</ol>
<p>如需创建链，请选择要包含在链中的所有视图，右键点击其中一个视图，选择 <strong>Chains</strong>，然后选择 <strong>Center Horizontally</strong> 或 <strong>Center Vertically</strong>，如下动图中所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/动画3.gif" alt="动画3"></p>
<p>需要注意的是创建<code>Chain</code>的时候这些子<code>View</code>不要带<code>Constraint</code>，有的话要清除掉<code>Constraint</code>，因为已有的<code>Constraint</code>会影响后续的操作</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前<code>ConstraintLayout</code>就总结到这里，还有一些点的话如果需要添加到时候再添加。<code>ConstraintLayout</code>是目前推荐的布局，性能也高一些，后面可以尽量都使用这个</p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://developer.android.com/training/constraint-layout">https://developer.android.com/training/constraint-layout</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1684271">https://cloud.tencent.com/developer/article/1684271</a></li>
<li>《Android权威编程指南》</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Andorid编程权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title>隐式intent</title>
    <url>/2021/08/25/Android%E5%AD%A6%E4%B9%A0/%E9%9A%90%E5%BC%8Fintent/</url>
    <content><![CDATA[<h1 id="隐式intent"><a href="#隐式intent" class="headerlink" title="隐式intent"></a>隐式intent</h1><p>Intent 分为两种类型：</p>
<ul>
<li><strong>显式 Intent</strong>：通过提供目标应用的软件包名称或完全限定的组件类名来指定可处理 Intent 的应用。通常，您会在自己的应用中使用显式 Intent 来启动组件，这是因为您知道要启动的 Activity 或服务的类名。例如，您可能会启动您应用内的新 Activity 以响应用户操作，或者启动服务以在后台下载文件。</li>
<li><strong>隐式 Intent</strong> ：不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理。例如，如需在地图上向用户显示位置，则可以使用隐式 Intent，请求另一具有此功能的应用在地图上显示指定的位置。</li>
</ul>
<p>启动<code>Activity</code>时使用<code>Intent</code>，当使用显示<code>Intent</code>时，<code>Intent</code>对象是显式命名的某个具体的<code>Activity</code>组件时，系统立即启动该组件。</p>
<p>当使用隐式<code>Intent</code>时，Android 系统通过将 Intent 的内容与在设备上其他应用<code>AndroidManifest</code>中申明的<code>Intent filter</code>进行比较，从而找到要启动的相应组件。如果 Intent 与 Intent 过滤器匹配，则系统将启动该组件，并向其传递<code>Intent</code>对象。如果多个 Intent 过滤器兼容，则系统会显示一个对话框，支持用户选取要使用的应用。</p>
<p>具体过程如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/intent-filters_2x.png" alt="img"></p>
<ol>
<li><em>Activity A</em> 创建包含操作描述的 <code>Intent</code>，并将其传递给 <code>startActivity()</code></li>
<li>Android 系统搜索所有应用中与 Intent 匹配的 Intent 过滤器。寻找到匹配项</li>
<li>该系统通过调用匹配 Activity (<em>Activity B</em>) 的 <code>onCreate()</code> 方法并将其传递给 <code>Intent</code>，以此启动匹配 Activity。</li>
</ol>
<p>简单理解显示和隐式的区别就类似于租房子，显示<code>Intent</code>就是自己知道自己需要什么样的房子，并且已经确认自己想租的房子在那个小区那个单元那个房间（具体类名），而隐式<code>Intent</code>是只知道自己想租房，然后条件是什么，比如：房间大小、是否是独卫、是否能养宠物，然后把这些条件交给中介（Android系统），最终由中介挑选出一些合适的房间，由自己挑选是否租房。</p>
<span id="more"></span>
<h2 id="显示Intent"><a href="#显示Intent" class="headerlink" title="显示Intent"></a>显示Intent</h2><p>显示<code>Intent</code>调用比较简单，只需要指定完整的组件类名即可。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式Intent调用——构造方法传入Component</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, TestActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>当然还有一些其他方法，大致都是差不多都需要指定类名。</p>
<p>目前我有一个疑问就是<strong>显示intent是否能够跨应用启动<code>Activity</code>？</strong></p>
<p>后面根据自己的实验得来显示<code>Intent</code>是可以跨应用启动<code>Activity</code>，就是说A应用可以启动B应用的<code>Activity</code></p>
<p>比如我创建一个应用，然后在里面加入一个按钮，在<code>onCreate()</code>中写下下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    <span class="type">Button</span> <span class="variable">mButton</span> <span class="operator">=</span> findViewById(R.id.button);</span><br><span class="line">    mButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">            <span class="comment">// 启动其他应用的Activity，目标Activity不做任何配置，会报SecurityException错误</span></span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">            <span class="comment">//String, String</span></span><br><span class="line">            intent.setClassName(<span class="string">&quot;com.example.testactivity&quot;</span>, <span class="string">&quot;com.example.testactivity.MainActivity&quot;</span>);</span><br><span class="line">            startActivity(intent);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们创建对应的以<code>TestActivity</code>为应用名的应用，他的包名为<code>com.example.testactivity</code>,其中<code>MainActivity</code>的类名是<code>com.example.testactivity.MainActivity</code>。</p>
<p>然后我们在<code>TestActivity</code>应用的<code>AndroidManifest.xml</code>中，对应的目标Activity中加入<code>android:exported=&quot;true&quot;</code>属性如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后运行第一个应用按下按钮就会发现跳转到了第二个应用之中。</p>
<p>举上面的例子说明其他应用的组件我们是可以通过显示的<code>Intent</code>进行调用，但是好像官方是不推荐使用显示<code>Intent</code>启动其他的<code>Activity</code>，因为我们写的包名和具体类名都是硬编码，一旦目标Activity修改了类名、修改了包名或者移动了位置，那么我们之前写的启动代码都会失败，这明显不符合我们的代码规范。</p>
<p>所以说，启动其他应用的组件时，应该使用隐式Intent，具体来说就是使用Intent-Filter进行匹配。</p>
<h2 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h2><p>隐式Intent不会指定特定的组件，而是声明要执行的常规操作，系统会根据Intent的内容去匹配对应的Activity并启动。</p>
<p>隐式<code>Intent</code>指定一些操作后会把这个<code>Intent</code>传给Android系统，然后由Android系统进行匹配，挑选出出合适的<code>Activity</code>出来然后进行启动。而<code>Intent</code>挑选的规则是是通过<code>Intent filter</code></p>
<p>举个简单的例子：</p>
<p>我们将<code>TestActivity</code>应用中的<code>AndroidManifest.xml</code>的内容进行更改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;Test&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中<code>action</code>元素告诉操作系统，activity能够胜的任指定任务，我们设置了一个自定义的<code>action</code>为<code>Test</code>，</p>
<p>然后<code>category</code>设置谁可以访问，<code>DEFAULT</code>类别告诉操作系统（问谁可以做时），activity愿意处理某项任务。DEFAULT 类别实际隐含于所有隐式intent中</p>
<p>然后我们设置第一个应用当中的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    <span class="type">Button</span> <span class="variable">mButton</span> <span class="operator">=</span> findViewById(R.id.button);</span><br><span class="line">    mButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">            <span class="comment">//隐式启动</span></span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">            intent.setAction(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">            startActivity(intent);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的我们启动该应用点击按钮就能启动<code>TestActivity</code>应用</p>
<h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><p>具体来说隐式<code>Intent</code>有其固定的匹配规则，匹配时会对<code>Activity</code>的过滤列表进行对比，对比过滤列表当中的<code>action、category、data</code>信息，</p>
<p><strong>action</strong></p>
<p>action是一个字符串，该字符串区分大小写。系统预定义了一些action，同时我们也可以在应用中定义自己的action。</p>
<p>一个中可以有多个action，此时Intent中的action能够和中的任何一个action相同即可匹配成功。</p>
<p><strong>category</strong></p>
<p>category也是一个字符串，也区分大小写。系统预定义了一些category，同时我们也可以在应用中定义自己的category。</p>
<p>一般来说<code>Intent</code>的category有默认值，是由于系统在调用startActivity或者startActivityForResult的时候会默认为Intent加上“android.intent.category.DEFAULT”这个category。</p>
<p>因此，我们的配置中必须添加对应的配置，不然会匹配失败。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Intent中我们可以不设置category，因为系统默认给我们添加了“android.intent.category.DEFAULT”。如果我们要添加category的话，这个category就必须跟的任意一个匹配，否则会匹配失败。</p>
<p><strong>data</strong></p>
<p>data设置接收数据类型，主要由两部分组成mimeType和URI。</p>
<p>mimeType指媒体类型，比如<code>image/jpeg</code>、<code>audio/mpeg4-generic</code>和<code>video/*</code>等，可以表示图片、文本、视频等不同的媒体格式。</p>
<p>URI包含的数据比较多，结构如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content://com.example.project:200/folder/subfolder/etc</span><br><span class="line">http://www.baidu.com:80/search/info</span><br></pre></td></tr></table></figure>
<p>data的匹配规则</p>
<p>data是非必须的，可以不设置。但是如果在定义了data，那么Intent中也必须设置可匹配的data。URI有默认值file和content，如果设置了URI，则默认值就失效，mimeType没用默认值，并且可以不设置。data的匹配意味着mimeType和URI同时匹配。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Intent</code>有显示和隐式两种，显示的内容不多，显示主要用于应用内，而隐式<code>Intent</code>比较灵活，内容也比较多</p>
<p>对于隐式Intent而言，必不可少的是action，因为默认的category会添加。</p>
<p>如果定义了data，不管mimeType是否设置，Intent中都必须设置uri，因为uri有默认值。</p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://blog.csdn.net/qq_26287435/article/details/98620772">https://blog.csdn.net/qq_26287435/article/details/98620772</a></li>
<li><a href="https://blog.csdn.net/xiao__gui/article/details/11392987">https://blog.csdn.net/xiao__gui/article/details/11392987</a></li>
<li><a href="https://developer.android.com/guide/components/intents-filters?hl=zh-cn">https://developer.android.com/guide/components/intents-filters?hl=zh-cn</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Andorid编程权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类中的特殊成员函数</title>
    <url>/2024/09/20/C++/C++%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="C-类中的特殊成员函数"><a href="#C-类中的特殊成员函数" class="headerlink" title="C++类中的特殊成员函数"></a>C++类中的特殊成员函数</h1><p>C++类中存在一些特殊的成员函数，编译器通常会自动为我们生成这些函数。然而，在某些情况下，编译器可能不会自动创建这些函数，因此我们需要了解这些函数的生成规则，并做好记录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/C++类中的特殊成员函数.jpeg" alt="画板"><br><span id="more"></span></p>
<ol>
<li>默认构造函数。仅当类<strong>不存在用户声明的构造函数时</strong>才自动生成。也就是啥构造函数都没定义，编译器才会自动生成。</li>
<li>析构函数。编译器总是会被自动生成，除非你自定义了它。</li>
<li>拷贝构造函数。<ol>
<li>拷贝构造和拷贝赋值之间是独立的互不干扰，自定义了拷贝赋值运算符，编译器还是会帮我们生成拷贝构造函数（理论上定义了一个拷贝操作，另外一个也应该定义的，目前好像不定义编译还是会生成，但是会生成警告）。定义了一个拷贝操作，另外一个也应该定义的，目前好像不定义编译还是会生成，但是会生成警告）。定义的，目前好像不定义编译还是会生成，但是会生成警告）。不定义编译还是会生成，但是会生成警告）。</li>
<li>拷贝和移动之间是互斥的，自定义了<strong>移动操作（移动构造函数或移动赋值运算符）</strong>，编译器就不会为你生成拷贝构造函数和拷贝赋值运算符（编译器通过给拷贝操作加上delete来保证）。</li>
<li>析构函数<strong>不会影响</strong>拷贝操作，自定义了析构函数，编译器还是会为我们生成拷贝构造函数。（理论上按照big_three理论，自定义了析构函数，拷贝操作应该也自定义了，毕竟需要自己进行资源释放，那资源的拷贝也应该需要特殊处理，好像编译器会生成警告）</li>
</ol>
</li>
<li>拷贝赋值运算符。<ol>
<li>拷贝构造和拷贝赋值之间是独立的互不干扰，自定义了拷贝构造函数，编译器还是会帮我们生成拷贝赋值运算符（理论上定义了一个拷贝操作，另外一个也应该定义的，目前好像不定义编译还是会生成，但是会生成警告）。定义了一个拷贝操作，另外一个也应该定义的，目前好像不定义编译还是会生成，但是会生成警告）。定义的，目前好像不定义编译还是会生成，但是会生成警告）。</li>
<li>拷贝和移动之间是互斥的，自定义了<strong>移动操作（移动构造函数或移动赋值运算符）</strong>，编译器就不会为我们生成拷贝构造函数和拷贝赋值运算符（编译器通过给拷贝操作加上delete来保证）。</li>
<li>析构函数<strong>不会影响</strong>拷贝操作，自定义了析构函数，编译器还是会为我们生成拷贝赋值运算符。</li>
</ol>
</li>
<li>移动构造函数。<ol>
<li>移动操作之间不是独立的，自定义了移动赋值运算符，编译器就不会为我们自动生成移动构造函数。理由：如果你给类声明了，比如，一个移动构造函数，就表明对于移动操作应怎样实现，与编译器应生成的默认逐成员移动有些区别。如果逐成员移动构造有些问题，那么逐成员移动赋值同样也可能有问题。所以声明移动构造函数阻止移动赋值运算符的生成，声明移动赋值运算符同样阻止编译器生成移动构造函数。</li>
<li>移动和拷贝动作互斥，自定义了任何拷贝操作（拷贝构造活拷贝赋值运算符），编译器就不会为我们生成移动构造或者移动赋值。理由：如果声明拷贝操作（构造或者赋值）就暗示着平常拷贝对象的方法（逐成员拷贝）不适用于该类，编译器会明白如果逐成员拷贝对拷贝操作来说不合适，逐成员移动也可能对移动操作来说不合适。</li>
<li>析构函数<strong>会影响</strong>移动操作，自定义了析构函数，编译器还是会为我们生成移动构造函数。</li>
</ol>
</li>
<li>移动赋值运算符。<ol>
<li>移动操作之间不是独立的，自定义了移动构造，编译器就不会为我们自动生成移动赋值运算符。理由同上</li>
<li>移动和拷贝动作互斥，自定义了任何拷贝操作（拷贝构造活拷贝赋值运算符），编译器就不会为我们生成移动构造或者移动赋值。理由同上</li>
<li>析构函数<strong>会影响</strong>移动操作，自定义了析构函数，编译器还是会为我们生成移动构造函数。</li>
</ol>
</li>
</ol>
<p>注意没有“成员函数模版阻止编译器生成特殊成员函数”的规则。这意味着如果Widget是这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">//从任何东西构造Widget</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> T&amp; rhs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">//从任何东西赋值给Widget</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> T&amp; rhs);</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>编译器仍会生成移动和拷贝操作（假设正常生成它们的条件满足），即使可以模板实例化产出拷贝构造和拷贝赋值运算符的函数签名</p>
<p>除此之外，现代C++还有一个三/五法则，也是对这方面的总结，感兴趣可以去了解一下。<br>参考：</p>
<p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-170</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>decltype类型推导</title>
    <url>/2024/09/01/C++/decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<h1 id="decltype类型推导"><a href="#decltype类型推导" class="headerlink" title="decltype类型推导"></a>decltype类型推导</h1><p><code>decltype</code>可以推导出变量或者表达式的类型，比如<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; y = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用decltype获取变量的类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(x) a = <span class="number">10</span>; <span class="comment">// a的类型为int</span></span><br><span class="line">    <span class="keyword">decltype</span>(y) b = x; <span class="comment">// b的类型为const int&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用decltype获取表达式的类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(x + a) c = x + a; <span class="comment">// c的类型为int</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><span id="more"></span><br>平时自己使用<code>decltype</code>最多的时候是和lambda进行配合，推导lambda的类型<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用lambda表达式定义比较器，按元素的绝对值从小到大排序</span></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">abs</span>(a) &lt; std::<span class="built_in">abs</span>(b);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在std::set中使用自定义的比较器</span></span><br><span class="line">    <span class="function">std::set&lt;<span class="type">int</span>, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">mySet</span><span class="params">(cmp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一些元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">-5</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">-2</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排序后的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><p>学习之后发现<code>decltype</code>主要作用是和<code>auto</code>一起对<strong>函数模板返回值类型</strong>进行推导<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数模板，返回两个参数的和（C++14）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"> <span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">add</span><span class="params">(T a, U b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="auto和decltype的区别"><a href="#auto和decltype的区别" class="headerlink" title="auto和decltype的区别"></a>auto和decltype的区别</h3><p>这里只说auto和decltype推导函数模板返回值类型的区别</p>
<ul>
<li>auto推导返回值类型，走的是模板类型推导的一套规则，推导过程中引用性会被忽略</li>
<li>decltype推导可以保留引用特性</li>
</ul>
<p>（书中例子）比如：现在需要一个函数，一个形参为容器，一个形参为索引值，这个函数支持使用方括号的方式（也就是使用“<code>[]</code>”）访问容器中指定索引值的数据，然后在返回索引操作的结果前执行认证用户操作。<br>使用auto<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//C++14版本，</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];                                <span class="comment">//从c[i]中推导返回类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用auto进行推导的话，编译器使用的是模板类型推导的规则，容器<code>[]</code>返回类型为<code>T&amp;</code>，<code>T&amp;</code>进行推导时引用性被忽略，最终返回值类型被推导为<code>T</code>。<br>这样的话，下面这种类型代码就编译不过，有点和容器<code>[]</code>使用相悖<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">…</span><br><span class="line"><span class="built_in">authAndAccess</span>(d, <span class="number">5</span>) = <span class="number">10</span>;               <span class="comment">//认证用户，返回d[5]，</span></span><br><span class="line">                                        <span class="comment">//然后把10赋值给它</span></span><br><span class="line">                                        <span class="comment">//无法通过编译器！</span></span><br></pre></td></tr></table></figure><br>但是如果使用decltype进行推导，可以保留初始化表达式的所有属性，所以返回值类型被推导为<code>T&amp;</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//C++14版本，</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>当然目前authAndAccess 还不是最完美的，因为authAndAccess目前没有办法接受右值，下面的调用方式明显就不能使用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::deque&lt;std::string&gt; <span class="title">makeStringDeque</span><span class="params">()</span></span>;      <span class="comment">//工厂函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从makeStringDeque中获得第五个元素的拷贝并返回</span></span><br><span class="line"><span class="keyword">auto</span> s = <span class="built_in">authAndAccess</span>(<span class="built_in">makeStringDeque</span>(), <span class="number">5</span>);</span><br></pre></td></tr></table></figure><br>所以最完美的authAndAccess编写方式<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">//最终的C++14版本</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><p>decltype会将表达式推导为引用，所以对于表达式<code>(x)</code>，就会出现下面的奇葩情形<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) 	<span class="comment">//int 类型</span></span><br><span class="line"><span class="keyword">decltype</span>((x))	<span class="comment">//int&amp;类型</span></span><br></pre></td></tr></table></figure><br>从而出现这种情况<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">return</span> x;                            <span class="comment">//decltype(x）是int，所以f1返回int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (x);                          <span class="comment">//decltype((x))是int&amp;，所以f2返回int&amp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这种情况需要注意</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>auto类型推导</title>
    <url>/2024/08/26/C++/auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<h1 id="auto类型推导"><a href="#auto类型推导" class="headerlink" title="auto类型推导"></a>auto类型推导</h1><h2 id="推导规则"><a href="#推导规则" class="headerlink" title="推导规则"></a>推导规则</h2><p>auto类型推导和模板类型大致相同，分为三种类型<br><span id="more"></span></p>
<ul>
<li><p>类型说明符是一个指针或引用但不是通用引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                </span><br><span class="line"><span class="keyword">auto</span> &amp; rx=x;             <span class="comment">//rx是非通用引用，rx推导为int &amp;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>情景二：类型说明符一个通用引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x;  <span class="comment">//x是int左值，</span></span><br><span class="line">                    <span class="comment">//所以uref1类型为int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = <span class="number">27</span>;	<span class="comment">//27是int右值，</span></span><br><span class="line">                    <span class="comment">//所以uref3类型为int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>情景三：类型说明符既不是指针也不是引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = <span class="number">27</span>;    <span class="comment">//y 推导为int </span></span><br></pre></td></tr></table></figure>
<p>vs2022代码运行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line">	<span class="keyword">auto</span>&amp; rx = x;             <span class="comment">//rx是非通用引用，rx推导为int &amp;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;rx = &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(rx)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">auto</span>&amp;&amp; uref1 = x;         <span class="comment">//x是int左值，所以uref1类型为int&amp;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;uref1 = &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(uref1)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">auto</span>&amp;&amp; uref2 = <span class="number">27</span>;	    <span class="comment">//27是int右值，所以uref3类型为int&amp;&amp;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;uref2 = &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(uref2)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">auto</span> y = <span class="number">27</span>;            <span class="comment">//y 推导为int </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;y = &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(y)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/auto类型推导.png" alt="1723387016585.png"><br>这部分内容可以去查看 <a href="https://bugcat.top/2024/08/10/C++/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/">模板类型推导的总结</a></p>
<h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p><code>auto</code>和 模板推导不同的地方的地方是： auto类型推导假定花括号表示<code>std::initializer_list</code>，而模板类型推导不会这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;;         <span class="comment">//x的类型是std::initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;            <span class="comment">//带有与x的声明等价的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;                <span class="comment">//形参声明的模板</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;);               <span class="comment">//错误！不能推导出T</span></span><br></pre></td></tr></table></figure>
<p>此外，C++14还允许auto 推导函数返回值，lambda函数也允许在形参声明中使用<code>auto</code>，不过虽然用了auto关键字，但是底层还是<strong>模板类型推导</strong>的那一套规则在工作，所以也不能推导出 “花括号表示<code>std::initializer_list</code>”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createInitList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;         <span class="comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> resetV = </span><br><span class="line">    [&amp;v](<span class="type">const</span> <span class="keyword">auto</span>&amp; newValue)&#123; v = newValue; &#125;;        <span class="comment">//C++14</span></span><br><span class="line"><span class="built_in">resetV</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);            <span class="comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>forward</title>
    <url>/2024/10/20/C++/forward/</url>
    <content><![CDATA[<p> C++中的<code>std::forward</code>函数是一个非常有用的工具，主要用于在泛型编程中完美转发（perfect forwarding）参数。在C++中，完美转发是指将函数模板中接收到的参数以<strong>原始形式（左值或右值）转发给另一个函数</strong>，保持参数的值类别（左值或右值）不变。<br><span id="more"></span><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                        <span class="comment">//C++14；仍然在std命名空间</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;T&gt;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设有一个函数f：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …                                   <span class="comment">//做些工作</span></span><br><span class="line">    <span class="built_in">someFunc</span>(std::forward&lt;T&gt;(fParam));  <span class="comment">//转发fParam到someFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="假设传入是左值"><a href="#假设传入是左值" class="headerlink" title="假设传入是左值"></a>假设传入是左值</h2><p>传入到<code>f</code>的实参是<code>Widget</code>的左值类型。<code>T</code>被推导为<code>Widget&amp;</code>，然后调用<code>std::forward</code>将实例化为<code>std::forward&lt;Widget&amp;&gt;</code>。<code>Widget&amp;</code>带入到上面的<code>std::forward</code>的实现中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;Widget&amp;&gt;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终forward转化为返回一个左值引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当左值实参被传入到函数模板<code>f</code>时，<code>std::forward</code>被实例化为接受和返回左值引用。内部的转换不做任何事，因为<code>param</code>的类型已经是<code>Widget&amp;</code>，所以转换没有影响。左值实参传入<code>std::forward</code>会返回左值引用。通过定义，左值引用就是左值，因此将左值传递给<code>std::forward</code>会返回左值，就像期待的那样</p>
<h2 id="假设传入是右值"><a href="#假设传入是右值" class="headerlink" title="假设传入是右值"></a>假设传入是右值</h2><p>传递给<code>f</code>的实参是一个<code>Widget</code>的右值。在这个例子中，<code>f</code>的类型参数<code>T</code>的推导类型就是<code>Widget</code>。<code>f</code>内部的<code>std::forward</code>调用因此为<code>std::forward&lt;Widget&gt;</code>，<code>std::forward</code>实现中把<code>T</code>换为<code>Widget</code>得到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;Widget&gt;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终转化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>从函数返回的右值引用可以被定义为右值</strong>，最终结果是，传递给<code>f</code>的右值参数将作为右值转发给<code>someFunc</code>，正是想要的结果。</p>
<p><strong>从函数返回的右值引用可以被定义为右值的理解</strong>：</p>
<p>如果不加forward，传入右值，fParam推导类型是Widget&amp;&amp;，最终直接传入someFunc，它是有名字（fParam）的，所以是一个左值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …                                   <span class="comment">//做些工作</span></span><br><span class="line">    <span class="built_in">someFunc</span>(fParam);  <span class="comment">//转发fParam到someFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加了forward后，forward返回一个Widget&amp;&amp;类型，返回是有个匿名变量，它是一个右值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …                                   <span class="comment">//做些工作</span></span><br><span class="line">    <span class="built_in">someFunc</span>(std::forward&lt;T&gt;(fParam));  <span class="comment">//转发fParam到someFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>move</title>
    <url>/2024/10/20/C++/move/</url>
    <content><![CDATA[<p><code>std::move</code>执行到右值的无条件的转换，但就自身而言，它不移动任何东西</p>
<p>内部的实现类似这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ol>
<li><code>remove_reference&lt;T&gt;::type</code>对<code>T</code>去除引用</li>
<li><code>using ReturnType = typename remove_reference&lt;T&gt;::type&amp;&amp;</code>，使得<code>ReturnType</code>是一个右值引用</li>
<li><code>static_cast&lt;ReturnType&gt;(param)</code> 将param转化为右值引用</li>
</ol>
<p>类似使用C++14版本更简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span>          <span class="comment">//C++14，仍然在std命名空间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="type">remove_referece_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>push_back和emplace_back</title>
    <url>/2024/10/20/C++/push-back%E5%92%8Cemplace-back/</url>
    <content><![CDATA[<p>modern C++中提到使用考虑使用置入代替插入，个人理解就是使用考虑使用<code>emplace_back</code>代替<code>push_back</code>操作，那么这两者之间究竟有什么区别，想探究一下<br><span id="more"></span><br>首先这两个函数的定义是不一样的</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p><code>push_back</code>是有两个函数的（重载），一个接受左值一个接受右值，并且接受右值后进行了<code>move</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">_CONSTEXPR20 <span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> _Ty&amp; _Val)</span> </span>&#123; <span class="comment">// insert element at end, provide strong guarantee</span></span><br><span class="line">    _Emplace_one_at_back(_Val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">_CONSTEXPR20 <span class="type">void</span> <span class="title">push_back</span><span class="params">(_Ty&amp;&amp; _Val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert by moving into element at end, provide strong guarantee</span></span><br><span class="line">    _Emplace_one_at_back(_STD <span class="built_in">move</span>(_Val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>emplace_back</code>是只有一个函数，是一个模板函数，参数是一个通用引用并且是变长参数，然后进行了完美转发<code>forward</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Valty&gt;</span><br><span class="line">    <span class="function">_CONSTEXPR20 <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">emplace_back</span><span class="params">(_Valty&amp;&amp;... _Val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// insert by perfectly forwarding into element at end, provide strong guarantee</span></span><br><span class="line">       <span class="comment">// 完美转发直接将参数传入内部</span></span><br><span class="line">        _Ty&amp; _Result = _Emplace_one_at_back(_STD forward&lt;_Valty&gt;(_Val)...);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _HAS_CXX17</span></span><br><span class="line">        <span class="keyword">return</span> _Result;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv</span></span></span><br><span class="line">        (<span class="type">void</span>) _Result;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _HAS_CXX17</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此外，<code>push_back</code>和<code>emplace_back</code>都使用了_Emplace_one_at_back进行插入</p>
<h2 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h2><h3 id="性能上"><a href="#性能上" class="headerlink" title="性能上"></a>性能上</h3><p>先说结论：</p>
<p><strong>理论上来说，<code>emplace_back</code>比<code>push_back</code>效率更高。emplace_back能够在<code>vector</code>内部构建元素，从而减少拷贝或者移动操作</strong></p>
<p>这句话怎么理解呢，举个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs;        <span class="comment">//std::string的容器</span></span><br><span class="line">vs.<span class="built_in">push_back</span>(<span class="string">&quot;xyzzy&quot;</span>);              <span class="comment">//添加字符串字面量</span></span><br></pre></td></tr></table></figure>
<p>通过上面的源码我们可以看到<code>push_back</code>接受的参数是一个<code>T</code>的元素，但是这里传入的是字面量，所以在这里会通过字面量创建出一个临时变量（隐式转换），等价于下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vs.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(<span class="string">&quot;xyzzy&quot;</span>)); <span class="comment">//创建临时std::string，把它传给push_back</span></span><br></pre></td></tr></table></figure>
<p>综上vs的<code>push_back</code>总共有三个操作</p>
<ol>
<li>一个<code>std::string</code>的临时对象从字面量“<code>xyzzy</code>”被创建。这个对象没有名字，我们可以称为<code>temp</code>。<code>temp</code>的构造是第一次<code>std::string</code>构造。因为是临时变量，所以<code>temp</code>是右值。</li>
<li><code>temp</code>被传递给<code>push_back</code>的右值重载函数，绑定到右值引用形参<code>_Val</code>。在<code>std::vector</code>的内存中一个<code>_Val</code>的副本被创建。这次构造——也是第二次构造——在<code>std::vector</code>内部真正创建一个对象。</li>
<li>在<code>push_back</code>返回之后，<code>temp</code>立刻被销毁，调用了一次<code>std::string</code>的析构函数。</li>
</ol>
<p>当我们使用<code>emplace_back</code>时，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="string">&quot;xyzzy&quot;</span>);           <span class="comment">//直接用“xyzzy”在vs内构造std::string</span></span><br></pre></td></tr></table></figure>
<p><code>emplace_back</code>使用完美转发将”xyzzy”传入了vector内部（就是前面<code>_Ty&amp; _Result = _Emplace_one_at_back(_STD forward&lt;_Valty&gt;(_Val)...);</code>），直接在内部的数组的末尾<strong>构建</strong>元素插入，减少了临时变量的产生，提高了效率。</p>
<h3 id="接受参数上"><a href="#接受参数上" class="headerlink" title="接受参数上"></a>接受参数上</h3><p><code>emplace_back</code>使用完美转发，因此只要你没有遇到完美转发的限制（完美转发也会失败，在这里不多讲解），就可以传递任何实参以及组合到<code>emplace_back</code>。</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>);           <span class="comment">//插入由50个“x”组成的一个std::string</span></span><br><span class="line">vs.<span class="built_in">push_back</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>);				<span class="comment">// error</span></span><br><span class="line">vs.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>))  <span class="comment">// fine</span></span><br></pre></td></tr></table></figure>
<p>再比如下面这种情况，临时变量都不给你转化，只能用emplace_back传入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> a)</span> :m_a(a) &#123;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;A&gt; aVec;</span><br><span class="line">aVec.<span class="built_in">push_back</span>(<span class="number">1</span>);		<span class="comment">// error  </span></span><br><span class="line">aVec.<span class="built_in">emplace_back</span>(<span class="number">1</span>);	<span class="comment">// fine</span></span><br></pre></td></tr></table></figure>
<p>所以写起来<code>emplace_back</code>肯定是更加舒服的，少写好多字母（理论上减少出错）。</p>
<h2 id="代码实验"><a href="#代码实验" class="headerlink" title="代码实验"></a>代码实验</h2><h3 id="实验一（emplace-back高效性）"><a href="#实验一（emplace-back高效性）" class="headerlink" title="实验一（emplace_back高效性）"></a>实验一（emplace_back高效性）</h3><p>使用push_back</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BaseClass</span>(<span class="type">const</span> std::string name) : <span class="built_in">name_</span>(name)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">BaseClass</span>(<span class="type">const</span> BaseClass&amp; b) :<span class="built_in">name_</span>(b.name_)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; copy constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BaseClass</span>(BaseClass&amp;&amp; b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 此处只是演示，并未进行真正移动</span></span><br><span class="line">		name_ = b.name_;</span><br><span class="line">		b.name_ = b.name_ + <span class="string">&quot; have move&quot;</span>;</span><br><span class="line">		std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; move constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">BaseClass</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;BaseClass&gt; bcVec;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;--------------------------------push_back :&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	bcVec.<span class="built_in">push_back</span>(<span class="built_in">BaseClass</span>(<span class="string">&quot;push_back_obj&quot;</span>));</span><br><span class="line">  <span class="comment">// push_back：</span></span><br><span class="line">  <span class="comment">//    (1) 调用 有参构造函数 BaseClass (const std::string name) 创建临时对象；</span></span><br><span class="line">  <span class="comment">//    (2）调用 移动构造函数 BaseClass(BaseClass&amp;&amp; b) 到vector中；</span></span><br><span class="line">  <span class="comment">//    (3) 调用     析构函数               销毁临时对象；</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;--------------------------------destruct:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//   (4) vector进行析构，调用析构函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果符合预期</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/push_back_obj.png" alt=""></p>
<p>使用emplace_back</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;BaseClass&gt; bcVec;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;--------------------------------emplace_back :&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	bcVec.<span class="built_in">emplace_back</span>(<span class="string">&quot;emplace_back_obj&quot;</span>);</span><br><span class="line">    <span class="comment">// (1) 在vector中直接调用构造函数创建元素</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;--------------------------------destruct:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// (2) vector进行析构，调用析构函数 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/emplace_back_obj.png" alt=""></p>
<p>可以看得出来emplace_back少临时变量的<strong>构造、移动、销毁</strong>操作，效率要高一些</p>
<h3 id="实验二（两者都传入右值）"><a href="#实验二（两者都传入右值）" class="headerlink" title="实验二（两者都传入右值）"></a>实验二（两者都传入右值）</h3><p>如果传入右值，push_back 和 emplace_back效率相同，都会有临时变量产生的<strong>构造、移动、销毁</strong>操作。</p>
<p>push_back传入右值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------push_back rvalue:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">bcVec.<span class="built_in">push_back</span>(<span class="built_in">BaseClass</span>(<span class="string">&quot;push_back_rvalue&quot;</span>));</span><br><span class="line">  <span class="comment">// push_back：</span></span><br><span class="line">  <span class="comment">//    (1) 调用 有参构造函数 BaseClass (const std::string name) 创建临时对象；</span></span><br><span class="line">  <span class="comment">//    (2）调用 移动构造函数 BaseClass(BaseClass&amp;&amp; b) 到vector中；</span></span><br><span class="line">  <span class="comment">//    (3) 调用     析构函数               销毁临时对象；</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;--------------------------------destruct:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">//   (4) vector进行析构，调用析构函数 </span></span><br></pre></td></tr></table></figure>
<p>上面已经展示过了，这里就不多解释了。</p>
<p>emplace_back传入右值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;BaseClass&gt; bcVec;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;--------------------------------emplace_back rvalue:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	bcVec.<span class="built_in">emplace_back</span>(<span class="built_in">BaseClass</span>(<span class="string">&quot;emplace_back_rvalue&quot;</span>));</span><br><span class="line">  <span class="comment">//    (1) 调用 有参构造函数 BaseClass (const std::string name) 创建临时对象；</span></span><br><span class="line">  <span class="comment">//    (2）调用 移动构造函数 BaseClass(BaseClass&amp;&amp; b) 到vector中；</span></span><br><span class="line">  <span class="comment">//    (3) 调用     析构函数               销毁临时对象；</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;--------------------------------destruct:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">//   (4) vector进行析构，调用析构函数 </span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果，可以看出效率没有提高</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/emplace_back_rvalue.png" alt=""></p>
<h3 id="实验三（两者都传入左值）"><a href="#实验三（两者都传入左值）" class="headerlink" title="实验三（两者都传入左值）"></a>实验三（两者都传入左值）</h3><p>如果传入右值，push_back 和 emplace_back效率相同，两者都会调用拷贝构造函数</p>
<p>push_back传入左值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;BaseClass&gt; bcVec;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;--------------------------------push_back lvalue:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//  (1) 调用 有参构造函数 BaseClass (const std::string name) 创建obj对象；</span></span><br><span class="line">	<span class="function">BaseClass <span class="title">obj</span><span class="params">(<span class="string">&quot;obj&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//  (2) 调用 拷贝构造函数；</span></span><br><span class="line">	bcVec.<span class="built_in">push_back</span>(obj);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;--------------------------------destruct:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//  (3) obj被析构，调用BaseClass的析构函数</span></span><br><span class="line"><span class="comment">//  (4) vector被析构，其中的元素调用BaseClass的析构函数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/push_back_lvalue.png" alt=""></p>
<p>emplace_back传入左值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;BaseClass&gt; bcVec;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;--------------------------------emplace_back lvalue:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//  (1) 调用 有参构造函数 BaseClass (const std::string name) 创建obj对象；</span></span><br><span class="line">	<span class="function">BaseClass <span class="title">obj</span><span class="params">(<span class="string">&quot;obj&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//  (2) 调用 拷贝构造函数；</span></span><br><span class="line">	bcVec.<span class="built_in">emplace_back</span>(obj);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;--------------------------------destruct:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//  (3) obj被析构，调用BaseClass的析构函数</span></span><br><span class="line"><span class="comment">//  (4) vector被析构，其中的元素调用BaseClass的析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/emplace_back_lvalue.png" alt=""></p>
<p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/183861524">C++姿势点: push_back和emplace_back</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>static、extern和inline</title>
    <url>/2023/08/05/C++/static%E3%80%81extern%E5%92%8Cinline/</url>
    <content><![CDATA[<h1 id="static、extern和inline"><a href="#static、extern和inline" class="headerlink" title="static、extern和inline"></a>static、extern和inline</h1><p>在实习写C++的时候遇到static、extern和inline相关的概念和使用，记录一下<br><span id="more"></span></p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><code>static</code>关键字作用很多，这里主要说明<code>static</code>变量。<code>static</code>变量生命周期是整个程序，可见性是文件可见(这些都是很基础的知识)<br>但是需要注意的是假如我们在头文件中定义了一个<code>static</code>变量（这里假设为<code>staticVar</code>），那么包含这个头文件的文件都会有这样一个变量<code>staticVar</code>不会发生冲突。这个特性有时候有用，<strong>但是绝大多数情况还是没有用的，而且会浪费空间，不建议使用</strong>。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件A.h </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源文件B.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span> <span class="comment">// B.cpp中包含一个 staticVar</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源文件C.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span> <span class="comment">// C.cpp中包含一个 staticVar</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p><code>extern</code>关键字在C++中用来声明全局变量，它用来告诉编译器，这个变量在其他文件中定义的，以避免重复定义。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源文件 A.cpp</span></span><br><span class="line"><span class="type">int</span> globalVariable = <span class="number">10</span>; <span class="comment">// 定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源文件 B.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> globalVariable; <span class="comment">// 声明全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用全局变量</span></span><br><span class="line">  globalVariable = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有的时候我们可以在头文件中使用<code>extern</code>来<strong>声明</strong>一个变量，在某个源文件中进行定义，然后其他包含这个头文件的源文件就都有这个变量的声明，它们共享一份内容。</p>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p><code>inline</code>关键字修饰函数，用于向编译器提供函数内联的建议，但是我没有想到<code>inline</code>关键字可以解决跨模块（动态库）的使用函数的问题。<br>比如我有一个动态库A（A.dll）和一个动态库B（B.dll）,动态库B使用了A里面的函数，但是B在链接的时候A还没有编译，这个时候可以将A里面的函数加上<code>inline</code>进行修饰，就不会报符号找不到的问题。<br>底层来看是因为<code>inline</code>关键字修饰的函数，在调用的时候会进行展开，这样就不会查找这个符号，但是这个特性确实有时候可以解决这样类似的编译问题。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>优先使用enum class</title>
    <url>/2024/10/03/C++/%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8enum%20class/</url>
    <content><![CDATA[<p>C++中存在<code>enum</code>和<code>enum class</code>两种，现代C++更加建议使用<code>enum class</code>这种。理由主要有三点：</p>
<ol>
<li><p><code>enum class</code>作用域更小，可以减少命名空间污染。<code>enum</code>定义后，其中的枚举类作用域是整个<code>enum</code>所在空间，可能对其他部分产生影响。比如</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; black, white, red &#125;;   <span class="comment">//black, white, red在</span></span><br><span class="line">                                    <span class="comment">//Color所在的作用域</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;                 <span class="comment">//错误! white早已在这个作用</span></span><br><span class="line">                                    <span class="comment">//域中声明</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>enum</code>会发隐式转换，但是<code>enum class</code>不会发生</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; black, white, red &#125;;       <span class="comment">//未限域enum</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::<span class="type">size_t</span>&gt;                <span class="comment">//func返回x的质因子</span></span><br><span class="line">  <span class="built_in">primeFactors</span>(std::<span class="type">size_t</span> x);</span><br><span class="line"></span><br><span class="line">Color c = red;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>) &#123;                         <span class="comment">// Color与double比较 (!)</span></span><br><span class="line">    <span class="keyword">auto</span> factors =                      <span class="comment">// 计算一个Color的质因子(!)</span></span><br><span class="line">      <span class="built_in">primeFactors</span>(c);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; black, white, red &#125;; <span class="comment">//Color现在是限域enum</span></span><br><span class="line"></span><br><span class="line">Color c = Color::red;                   <span class="comment">//和之前一样，只是</span></span><br><span class="line">...                                     <span class="comment">//多了一个域修饰符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>) &#123;                         <span class="comment">//错误！不能比较</span></span><br><span class="line">                                        <span class="comment">//Color和double</span></span><br><span class="line">    <span class="keyword">auto</span> factors =                      <span class="comment">//错误！不能向参数为std::size_t</span></span><br><span class="line">      <span class="built_in">primeFactors</span>(c);                  <span class="comment">//的函数传递Color参数</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>enum class</code><font style="color:rgb(0, 0, 0);">可以被前置声明。前置声明某些情况下可以减少编译依赖。</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>;         <span class="comment">//错误！</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>;   <span class="comment">//没问题</span></span><br></pre></td></tr></table></figure>
<h2 id="enum-class使用"><a href="#enum-class使用" class="headerlink" title="enum class使用"></a><code>enum class</code>使用</h2><ol>
<li>第一项进行赋值。建议对枚举第一项赋值0，这样可以帮助明确各个枚举项值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    black=<span class="number">0</span>,</span><br><span class="line">    white,</span><br><span class="line">    red</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>整加count。这个是方便类似<code>vector&lt;int&gt; a(1,Color::count)</code>情况</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    black=<span class="number">0</span>,</span><br><span class="line">    white,</span><br><span class="line">    red,</span><br><span class="line">    count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>模板类型推导</title>
    <url>/2024/08/10/C++/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<h1 id="模板类型推导"><a href="#模板类型推导" class="headerlink" title="模板类型推导"></a>模板类型推导</h1><p>写了这么久C++都没思考过模板推导的相关内容，这次学习Effective Modern C++记录一下<br>已知模板函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(expr);                        <span class="comment">//使用表达式调用f</span></span><br></pre></td></tr></table></figure><br>在编译期间，编译器使用<code>expr</code>进行两个类型推导：一个是针对<code>T</code>的，另一个是针对<code>ParamType</code>的。这两个类型通常是不同的，因为<code>ParamType</code>包含一些修饰，比如<code>const</code>和引用修饰符<br>如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;         <span class="comment">//ParamType是const T&amp;</span></span><br></pre></td></tr></table></figure><br>所以根据<code>ParamType</code>的类型存在三种情况：<br><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导分类.jpeg" alt=""><br><span id="more"></span></p>
<h2 id="ParamType是指针或者引用（非通用引用）"><a href="#ParamType是指针或者引用（非通用引用）" class="headerlink" title="ParamType是指针或者引用（非通用引用）"></a>ParamType是指针或者引用（非通用引用）</h2><p>规则：</p>
<ol>
<li><strong>如果</strong><code>expr</code><strong>的类型是一个引用，忽略引用部分</strong></li>
<li><p>然后<code>expr</code>的类型与<code>ParamType</code>进行模式匹配来决定<code>T</code></p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;               <span class="comment">//param是一个引用</span></span><br><span class="line"><span class="built_in">f</span>(expr);  </span><br></pre></td></tr></table></figure>
<p>在这里<code>ParamType</code>是<code>T&amp;</code>也就是引用类型，并且param一定是个引用，但是得看是const &amp;还是非const &amp;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">27</span>;                       <span class="comment">//x是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx=x;                 <span class="comment">//cx是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx=x;                <span class="comment">//rx是指向作为const int的x的引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>int x 和 f(x)</code>推导出T是int，param的类型是int&amp;。这个很好理解，因为本来就是T&amp;，生成的模板函数肯定也是带引用的，int就推出int</p>
</li>
<li><code>const int cx 和 f(x)</code>推导出T是const int，param的类型是int&amp;。这个也好理解和合理，因为用户向f传入const对象时就是想对象保持不可改变性，编译器自然也要满足这种需求，所以也带const</li>
<li><code>const int&amp; rx 和 f(x)</code>推导出T是const int，param的类型是const int&amp;。这个符合第一点要求，引用部分被忽略，忽略后结果和2相同</li>
</ol>
<p>测试：<br>在vs2022上写代码使用boost库里面的type_id_with_cvr进行测试<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示T</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T =     &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示param类型</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;param = &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">27</span>;                       <span class="comment">//x是int</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> cx = x;                 <span class="comment">//cx是const int</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; rx = x;                <span class="comment">//rx是指向作为const int的x的引用</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是int&amp;</span></span><br><span class="line">	<span class="built_in">f</span>(cx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line">	<span class="built_in">f</span>(rx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导运行结果1.png" alt="1723219601030.png"><br>此外，如果ParamType是<code>const T&amp;</code>时，情况会有一些不同，但是情况和上面类似，不细讲<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;         <span class="comment">//param现在是reference-to-const</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                     <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;               <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;              <span class="comment">//如之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T是int，param的类型是const int&amp;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>引用是另类的指针，理解上面引用后，指针也好理解，只要注意const会保持就行<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;               <span class="comment">//param现在是指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                     <span class="comment">//同之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *px = &amp;x;             <span class="comment">//px是指向作为const int的x的指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&amp;x);                          <span class="comment">//T是int，param的类型是int*</span></span><br><span class="line"><span class="built_in">f</span>(px);                          <span class="comment">//T是const int，param的类型是const int*</span></span><br></pre></td></tr></table></figure><br>vs2022 上运行结果<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示T</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T =     &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示param类型</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;param = &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">27</span>;                       <span class="comment">//x是int</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> cx = x;                 <span class="comment">//cx是const int</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; rx = x;                <span class="comment">//rx是指向作为const int的x的引用</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是int&amp;</span></span><br><span class="line">	<span class="built_in">f</span>(cx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line">	<span class="built_in">f</span>(rx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导运行结果2.png" alt="1723220710506.png"></p>
<h2 id="ParamType是通用引用"><a href="#ParamType是通用引用" class="headerlink" title="ParamType是通用引用"></a>ParamType是通用引用</h2><p>通用引用是universal Reference翻译过来的，也有叫万能引用的，形式上和右值引用一样（&amp;&amp;），第一次接触这玩意还是实习的时候师兄跟我讲的，后面就回去了解了一下。这里默认大伙已经了解左值右值哈。<br>规则：</p>
<ol>
<li>如果<code>expr</code>是左值，<code>T</code>和<code>ParamType</code>都会被推导为左值引用。需要注意的是<strong>右值引用</strong>也是左值（T唯一一种被推导为引用的情况）</li>
<li><p>如果<code>expr</code>是右值，就有点类似上面的内容（右值版推导）</p>
<ol>
<li>如果<code>expr</code>的类型是一个引用，忽略引用部分</li>
<li>然后<code>expr</code>的类型与<code>ParamType</code>进行模式匹配来决定<code>T</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;              <span class="comment">//param现在是一个通用引用类型</span></span><br><span class="line"><span class="built_in">f</span>(expr)</span><br></pre></td></tr></table></figure>
这里ParamType是T&amp;&amp; ，param最终一定是个引用，但是得看是左值引用&amp; 还是右值&amp;&amp;<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">27</span>;                       <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx=x;                 <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; rx=cx;              <span class="comment">//如之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//x是左值，所以T是int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//cx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//rx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(x));                <span class="comment">// 右值引用也是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);                          <span class="comment">//27是右值，所以T是int，</span></span><br><span class="line">                                <span class="comment">//param类型就是int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><code>int x 和 f(x)</code>推导出T是int &amp;，param的类型是int&amp;。模板函数应该是这样void f(int&amp; &amp;&amp; param)，，然后通过引用折叠变成void(int&amp; param)  </p>
</li>
<li><code>const int cx 和 f(x)</code>推导出T是const int&amp;，param的类型是int&amp;。同上,不过加了const。</li>
<li><code>const int&amp; rx 和 f(x)</code>推导出T是const int&amp;，param的类型是const int&amp;。同上</li>
<li><code>27 和 f(27)</code>推导出T是int，param的类型是int&amp;&amp;。模板函数是这样void(int&amp;&amp; param)，使得f可以接受右值进行传入</li>
</ol>
<p>说实话这个通用引用还挺奇妙，最终f可以接受所有值进行传入。<br>代码和运行结果<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示T</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T =     &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示param类型</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;param = &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">27</span>;                       <span class="comment">//如之前一样</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> cx = x;                 <span class="comment">//如之前一样</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; rx = cx;              <span class="comment">//如之前一样</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">f</span>(x);                           <span class="comment">//x是左值，所以T是int&amp;，</span></span><br><span class="line">                                        <span class="comment">//param类型也是int&amp;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">f</span>(cx);                          <span class="comment">//cx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                    <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">f</span>(rx);                          <span class="comment">//rx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                    <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">f</span>(std::<span class="built_in">move</span>(x));                <span class="comment">// 右值引用也是左值，所以T是const int&amp;，</span></span><br><span class="line">                                    <span class="comment">//param类型也是int&amp;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">f</span>(<span class="number">27</span>);                          <span class="comment">//27是右值，所以T是int，</span></span><br><span class="line">                                    <span class="comment">//param类型就是int&amp;&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导运行结果3.png" alt="1723258751479.png"></p>
<h2 id="ParamType既不是指针也不是引用"><a href="#ParamType既不是指针也不是引用" class="headerlink" title="ParamType既不是指针也不是引用"></a>ParamType既不是指针也不是引用</h2><p>大白话值传递<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;                <span class="comment">//以传值的方式处理param</span></span><br><span class="line"><span class="built_in">f</span>(expr)</span><br></pre></td></tr></table></figure><br>规则：</p>
<ol>
<li>和之前一样，如果<code>expr</code>的类型是一个引用，忽略这个引用部分</li>
<li>如果忽略<code>expr</code>的引用性（reference-ness）之后，<code>expr</code>是一个<code>const</code>，那就再忽略<code>const</code>。如果它是<code>volatile</code>，也忽略<code>volatile</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                       <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;                 <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = cx;              <span class="comment">//如之前一样</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* px = &amp;x;             <span class="comment">//px是指向作为const int的x的指针</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> px1 = &amp;x;             </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> px2 = &amp;x;      </span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(&amp;x);                          <span class="comment">//T和param的类型都是int*</span></span><br><span class="line"><span class="built_in">f</span>(px);                          <span class="comment">//T和param的类型都是cosnt int*</span></span><br><span class="line"><span class="built_in">f</span>(px1);                         <span class="comment">//T和param的类型都是 int*</span></span><br><span class="line"><span class="built_in">f</span>(px2);                         <span class="comment">//T和param的类型都是cosnt int*</span></span><br></pre></td></tr></table></figure>
指针可能有些不一样，const <em>指针传进去，推导出来还是const </em>，但是 *const传进去const特性会被忽略，也就是说指针是可以更改指向的。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示T</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T =     &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示param类型</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;param = &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">27</span>;                       <span class="comment">//如之前一样</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> cx = x;                 <span class="comment">//如之前一样</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; rx = cx;              <span class="comment">//如之前一样</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>* px = &amp;x;             <span class="comment">//px是指向作为const int的x的指针</span></span><br><span class="line">	<span class="type">int</span>* <span class="type">const</span> px1 = &amp;x;             </span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> px2 = &amp;x;      </span><br><span class="line"></span><br><span class="line">	<span class="built_in">f</span>(x);                           <span class="comment">//T和param的类型都是int</span></span><br><span class="line">	<span class="built_in">f</span>(cx);                          <span class="comment">//T和param的类型都是int</span></span><br><span class="line">	<span class="built_in">f</span>(&amp;x);                          <span class="comment">//T和param的类型都是int*</span></span><br><span class="line">	<span class="built_in">f</span>(px);                          <span class="comment">//T和param的类型都是cosnt int*</span></span><br><span class="line">	<span class="built_in">f</span>(px1);                         <span class="comment">//T和param的类型都是 int*</span></span><br><span class="line">	<span class="built_in">f</span>(px2);                         <span class="comment">//T和param的类型都是cosnt int*</span></span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导运行结果4.png" alt="1723264877921.png"><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>存在一些特列，记录一下<h3 id="数组实参"><a href="#数组实参" class="headerlink" title="数组实参"></a>数组实参</h3>一般来说，数组传参时是退化为指针，推导的时候也应该影响不大<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;                <span class="comment">//以传值的方式处理param</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>;     <span class="comment">//name的类型是const char[13]</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptrToName = name;          <span class="comment">//数组退化为指针</span></span><br><span class="line"><span class="built_in">f</span>(name);								<span class="comment">//name是一个数组，但是T被推导为const char*</span></span><br><span class="line"><span class="built_in">f</span>(ptrToName);</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导运行结果5.png" alt="1723267302280.png"><br>但是在ParamType作为引用时，就可以有指向数组的引用了，并且可以获得数组的大小<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;                       <span class="comment">//传引用形参的模板</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>;     <span class="comment">//name的类型是const char[13]</span></span><br><span class="line"><span class="built_in">f</span>(name);                        <span class="comment">//name是一个数组，但是T被推导为const char (&amp;)[13]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示T</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T =     &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示param类型</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;param = &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>;     <span class="comment">//name的类型是const char[13]</span></span><br><span class="line">	<span class="built_in">f</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/模板类型推导运行结果6.png" alt="1723297363366.png"><br>应用：<br>编译器就可以获得数组大小，不过sizeof好像也可以<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在编译期间返回一个数组大小的常量值（//数组形参没有名字，</span></span><br><span class="line"><span class="comment">//因为我们只关心数组的大小）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;                     <span class="comment">//关于</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> <span class="keyword">noexcept</span>      <span class="comment">//constexpr</span></span></span><br><span class="line"><span class="function"></span>&#123;                                                       <span class="comment">//和noexcept</span></span><br><span class="line">    <span class="keyword">return</span> N;                                           <span class="comment">//的信息</span></span><br><span class="line">&#125;                                                       <span class="comment">//请看下面</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> keyVals[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">35</span> &#125;;             <span class="comment">//keyVals有七个元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mappedVals[<span class="built_in">arraySize</span>(keyVals)];                     <span class="comment">//mappedVals也有七个</span></span><br></pre></td></tr></table></figure>
<h3 id="函数实参"><a href="#函数实参" class="headerlink" title="函数实参"></a>函数实参</h3>函数和数组类似，都会退化为指针<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;         <span class="comment">//someFunc是一个函数，</span></span><br><span class="line">                                    <span class="comment">//类型是void(int, double)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;                   <span class="comment">//传值给f1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T &amp; param)</span></span>;                 <span class="comment">//传引用给f2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(someFunc);                       <span class="comment">//param被推导为指向函数的指针，</span></span><br><span class="line">                                    <span class="comment">//类型是void(*)(int, double)</span></span><br><span class="line"><span class="built_in">f2</span>(someFunc);                       <span class="comment">//param被推导为指向函数的引用，</span></span><br><span class="line">                                    <span class="comment">//类型是void(&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Linux定时器</title>
    <url>/2022/08/29/Linux/Linux%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Linux定时器"><a href="#Linux定时器" class="headerlink" title="Linux定时器"></a>Linux定时器</h1><p>学习《Linux高性能服务器编程》第十一章定时器，里面介绍了各种网络程序中的定时事件，为了印象深刻一些，多动手多实践，所以记下这个笔记。这一篇主要记录Linux中SIGALRM信号触发的定时器。</p>
<span id="more"></span>
<h2 id="SIGALRM信号"><a href="#SIGALRM信号" class="headerlink" title="SIGALRM信号"></a>SIGALRM信号</h2><p>由于<code>alarm</code>和<code>setitimer</code>函数设置的实时闹钟一旦超时，将触发<code>SIGALRM</code>信号。因此，我们可以利用该信号的信号处理函数来处理定时任务。但是，如果要处理多个定时任务，我们就需要不断地触发<code>SIGALRM</code>信号，并在其信号处理函数中执行到期的任务。</p>
<p>一般而言，<code>SIGALRM</code>信号按照固定的频率生成，即由<code>alarm</code>或<code>setitimer</code>函数设置的定时周期<code>T</code>保持不变。如果某个定时任务的超时时间不是<code>T</code>的整数倍，那么它实际被执行的时间和预期的时间将略有偏差。因此定时周期<code>T</code>反映了定时的精度。</p>
<h3 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>
<p><code>alarm</code>定时发送 <code>SIGALRM</code>给当前进程（需要注意的是<code>alarm</code>调用只会引起一次调用）。</p>
<p><code>seconds</code>参数表示经过<code>seconds</code>秒数后发送<code>SIGALRM</code>给目前的进程</p>
<p><code>alarm</code>返回上次定时剩余时间。</p>
<p>如果设置<code>alarm(0)</code>则表示取消闹钟</p>
<p>我们举个小例子，结合前面的信号一起写下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_alarm</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    alarm(<span class="number">3</span>);                   <span class="comment">// 3秒后发送信号</span></span><br><span class="line">    signal(SIGALRM, sig_alarm); <span class="comment">//设置信号对应的处理函数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------------\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220829204127701.png" alt="image-20220829204127701"></p>
<h3 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h3><p><code>setitimer</code>相比<code>alarm</code>，提供了更为精细的参数选择</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getitimer</span><span class="params">(<span class="type">int</span> which, <span class="keyword">struct</span> itimerval *curr_value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br></pre></td></tr></table></figure>
<p><code>which</code>指计时器采用那种类型的计时方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ITIMER_REAL</code></td>
<td>以系统真实的时间来计算，它送出<code>SIGALRM</code>信号。</td>
</tr>
<tr>
<td><code>ITIMER_VIRTUAL</code></td>
<td>以该进程用户空间下花费的时间来计算，它送出<code>SIGVTALRM</code>信号。</td>
</tr>
<tr>
<td><code>ITIMER_PROF</code></td>
<td>以该进程在用户空间下和内核下所费的时间来计算，它送出<code>SIGPROF</code>信号。</td>
</tr>
</tbody>
</table>
</div>
<p><code>new_value</code>和<code>old_value</code>都是<code>itimerval</code>类型的结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">/* Interval for periodic timer */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">/* Time until next expiration */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">   <span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">   <span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>timeval</code>结构体中成员很简单，<code>tv_sec</code>设置秒，<code>tv_usec</code>设置微妙。</p>
<p><code>itimerval</code>结构体中成员<code>it_interval</code>为计时间隔，<code>it_value</code>为延时时长。比如：我想3s后，以每次5s的时间间隔打印hello world，那么就需要设置<code>it_value</code>为3s，设置<code>it_interval</code>为5s（3s后第一次打印，此后每次以5s为间隔打印）。</p>
<p>其中的<code>new_value</code>参数用来对计时器进行设置。</p>
<p><code>old_value</code>参数，通常用不上，设置为NULL，它是用来存储上一次<code>setitimer</code>调用时设置的new_value值。</p>
<p>函数调用成功返回0，失败返回-1，并且设置<code>errno</code>。</p>
<p><strong>假如it_value为0是不会触发信号的，所以要能触发信号，it_value得大于0；如果it_interval为0，只会延时，不会定时（也就是说只会触发一次信号)。</strong></p>
<p>下面就写一个延时3s后，以5s为间隔打印hello world</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_alarm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, sig_alarm); <span class="comment">//注册SIGALRM信号的捕捉处理函数。</span></span><br><span class="line"></span><br><span class="line">    it.it_value.tv_sec = <span class="number">3</span>; <span class="comment">//设置延时3s</span></span><br><span class="line">    it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    it.it_interval.tv_sec = <span class="number">5</span>; <span class="comment">//设置时间间隔5s</span></span><br><span class="line">    it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setitimer(ITIMER_REAL, &amp;it, &amp;oldit) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------------\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220829212215274.png" alt="image-20220829212215274"></p>
<h2 id="socket选项SO-RCVTIMEO和SO-SNDTIMEO"><a href="#socket选项SO-RCVTIMEO和SO-SNDTIMEO" class="headerlink" title="socket选项SO_RCVTIMEO和SO_SNDTIMEO"></a>socket选项SO_RCVTIMEO和SO_SNDTIMEO</h2><p><code>socket</code>选项<code>SO_RCVTIMEO</code>和<code>SO_SNDTIMEO</code>，它们分别用来设置<code>socket</code>接收数据超时时间和发送数据超时时间。因此，这两个选项仅对与数据接收和发送相关的<code>socket</code>专用系统调用( socket专用的系统调用指的是5.2～5.11节介绍的那些socketAPI)有效，这些系统调用包括<code>send</code>、<code>sendmsg</code>、<code>recv</code>、<code>recvmsg</code>、<code>accept</code>和 <code>connect</code>。将选项SO_RCVTIMEO和SO_SNDTIMEO对这些系统调用的影响总结于表中（来源Linux高性能服务器编程）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220830110132529.png" alt="image-20220830110132529"></p>
<p>这里举书上的代码例子，比较简单 明了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timeout_connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">int</span> port, <span class="type">int</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    timeout.tv_sec = time;</span><br><span class="line">    timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(timeout);</span><br><span class="line">    ret = setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, len);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINPROGRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;connecting timeout\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error occur when connecting to server\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = timeout_connect(ip, port, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统日志rsyslogd</title>
    <url>/2022/08/21/Linux/Linux%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97rsyslogd/</url>
    <content><![CDATA[<h1 id="Linux系统日志rsyslogd"><a href="#Linux系统日志rsyslogd" class="headerlink" title="Linux系统日志rsyslogd"></a>Linux系统日志rsyslogd</h1><h3 id="Linux系统日志"><a href="#Linux系统日志" class="headerlink" title="Linux系统日志"></a>Linux系统日志</h3><p>Linux上使用<code>rsyslogd</code>守护进程接收<strong>用户进程</strong>输出的日志和接收<strong>内核</strong>日志。</p>
<p>用户进程是通过<code>syslogd</code>函数生成系统日志。该函数将日志输出到一个UNIX本地域socket类型(AF_UNIX）的文件<code>/dev/log</code>中，<code>rsyslogd</code>则监听该文件以获取用户进程的输出。</p>
<p>内核日志是如何进行管理的，在这里我们不进行关系。</p>
<p><code>rsyslogd</code>守护进程在接收到<strong>用户进程</strong>或<strong>内核输入</strong>的日志后，会把它们输出至某些特定的日志文件。默认情况下，调试信息会保存至<code>/var/log/debug</code>文件，普通信息保存至<code>/var/log/messages</code>文件，内核消息则保存至<code>/var/log/kern.log</code>文件。</p>
<p>不过，日志信息具体如何分发，可以在<code>rsyslogd</code>的配置文件中设置。<code>rsyslogd</code>的主配置文件是<code>/etc/rsyslog.conf</code>，其中主要可以设置的项包括:内核日志输入路径，是否接收UDP日志及其监听端口（默认是514，见<code>/etc/services</code>文件)，是否接收TCP日志及其监听端口，日志文件的权限，包含哪些子配置文件(比如 <code>/etc/rsyslog.d/*.conf</code>)。<code>rsyslogd</code>的子配置文件则指定各类日志的目标存储文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220818105707879.png" alt="image-20220818105707879"></p>
<span id="more"></span>
<p><code>rsyslogd</code>系统日志功能比较复杂，有facility、priority、action等概念。还有Input模块、Filetr模块、Output模块等模块内容，目前还未弄清楚相关的知识。</p>
<p>查看了一下<code>/etc/rsyslog.conf</code>的配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/rsyslog.conf configuration file <span class="keyword">for</span> rsyslog</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># For more information install rsyslog-doc and see</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/usr/share/doc/rsyslog-doc/html/configuration/index.html</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Default logging rules can be found in /etc/rsyslog.d/50-default.conf</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### MODULES ####</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################</span></span></span><br><span class="line"></span><br><span class="line">module(load=&quot;imuxsock&quot;) # provides support for local system logging</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">module(load=<span class="string">&quot;immark&quot;</span>)  <span class="comment"># provides --MARK-- message capability</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides UDP syslog reception</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">module(load=<span class="string">&quot;imudp&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">input(<span class="built_in">type</span>=<span class="string">&quot;imudp&quot;</span> port=<span class="string">&quot;514&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides TCP syslog reception</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">module(load=<span class="string">&quot;imtcp&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">input(<span class="built_in">type</span>=<span class="string">&quot;imtcp&quot;</span> port=<span class="string">&quot;514&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides kernel logging support and <span class="built_in">enable</span> non-kernel klog messages</span></span><br><span class="line">module(load=&quot;imklog&quot; permitnonkernelfacility=&quot;on&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### GLOBAL DIRECTIVES ####</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Use traditional timestamp format.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">To <span class="built_in">enable</span> high precision timestamps, comment out the following line.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$ActionFileDefaultTemplate</span> RSYSLOG_TraditionalFileFormat</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Filter duplicated messages</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">RepeatedMsgReduction on</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Set the default permissions for all log files.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$FileOwner</span> syslog</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FileGroup adm</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FileCreateMode 0640</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DirCreateMode 0755</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Umask 0022</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PrivDropToUser syslog</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PrivDropToGroup syslog</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Where to place spool and state files</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$WorkDirectory</span> /var/spool/rsyslog</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Include all config files in /etc/rsyslog.d/</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到模块<code>module(load=&quot;imuxsock&quot;)</code>，这是一个输入模块</p>
<p>然后看到默认规则在<code>/etc/rsyslog.d/50-default.conf</code>，查看一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> Default rules <span class="keyword">for</span> rsyslog.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#                       For more information see rsyslog.conf(5) and /etc/rsyslog.conf</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># First some standard log files.  Log by facility.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">auth,authpriv.*                 /var/log/auth.log</span></span><br><span class="line">*.*;auth,authpriv.none          -/var/log/syslog</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cron.*                         /var/log/cron.log</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">daemon.*                       -/var/log/daemon.log</span></span><br><span class="line">kern.*                          -/var/log/kern.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lpr.*                          -/var/log/lpr.log</span></span><br><span class="line">mail.*                          -/var/log/mail.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">user.*                         -/var/log/user.log</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Logging for the mail system.  Split it up so that</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">it is easy to write scripts to parse these files.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#mail.info                      -/var/log/mail.info</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mail.warn                      -/var/log/mail.warn</span></span><br><span class="line">mail.err                        /var/log/mail.err</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Some &quot;catch-all&quot; log files.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">*.=debug;\</span></span><br><span class="line"><span class="language-bash"><span class="comment">#       auth,authpriv.none;\</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       news.none;mail.none     -/var/log/debug</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">*.=info;*.=notice;*.=warn;\</span></span><br><span class="line"><span class="language-bash"><span class="comment">#       auth,authpriv.none;\</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       cron,daemon.none;\</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       mail,news.none          -/var/log/messages</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Emergencies are sent to everybody logged in.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">*.emerg                         :omusrmsg:*</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># I like to have messages displayed on the console, but only on a virtual</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">console I usually leave idle.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#daemon,mail.*;\</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       news.=crit;news.=err;news.=notice;\</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       *.=debug;*.=info;\</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       *.=notice;*.=warn       /dev/tty8</span></span></span><br></pre></td></tr></table></figure>
<p>其中<code>auth</code>这种就是facility（设施），<code>mail.err</code>这种就是priority（等级），而这种设置日志记录的位置就是action</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.*;auth,authpriv.none          -/var/log/syslog</span><br></pre></td></tr></table></figure>
<p>从上面这一个action可以看出普通的日志（<code>&quot;.&quot;</code>），设置日志记录位置是<code>/var/log/syslog</code>，前面<code>-</code>表示异步写入</p>
<p>我们使用<code>logger</code>命令测试一下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">logger -i -t <span class="string">&quot;my_test&quot;</span> <span class="string">&quot;test_log&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用vim查看<code>/var/log/syslog</code>可以看到我们的<code>logger</code>的结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220818172612033.png" alt="image-20220818172612033"></p>
<p><code>rsyslogd</code>的内容比较多，后续再补。</p>
<h3 id="syslog函数"><a href="#syslog函数" class="headerlink" title="syslog函数"></a>syslog函数</h3><p>应用程序使用<code>syslog</code>函数和<code>rsyslogd</code>守护进程进行通讯。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> option, <span class="type">int</span> facility)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><code>openlog</code>用于改变<code>syslog</code>默认的输出方式，进行日志结构化</p>
<p><code>ident</code>参数指定的字符串将被添加到日志消息的日期和时间之后，它通常被设置为程序的名字。</p>
<p><code>option</code>参数对后续<code>syslog</code>调用的行为进行配置，它可取下列的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_PID		0x01	<span class="comment">/* log the pid with each message */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_CONS	0x02	<span class="comment">/* log on the console if errors in sending */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_ODELAY	0x04	<span class="comment">/* delay open until first syslog() (default) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_NDELAY	0x08	<span class="comment">/* don&#x27;t delay open */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_NOWAIT	0x10	<span class="comment">/* don&#x27;t wait for console forks: DEPRECATED */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_PERROR	0x20	<span class="comment">/* log to stderr as well */</span></span></span><br></pre></td></tr></table></figure>
<p><code>facility</code>参数可以修改<code>syslog</code>函数中的默认设施值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* facility codes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_KERN	(0&lt;&lt;3)	<span class="comment">/* kernel messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_USER	(1&lt;&lt;3)	<span class="comment">/* random user-level messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_MAIL	(2&lt;&lt;3)	<span class="comment">/* mail system */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_DAEMON	(3&lt;&lt;3)	<span class="comment">/* system daemons */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_AUTH	(4&lt;&lt;3)	<span class="comment">/* security/authorization messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_SYSLOG	(5&lt;&lt;3)	<span class="comment">/* messages generated internally by syslogd */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LPR		(6&lt;&lt;3)	<span class="comment">/* line printer subsystem */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_NEWS	(7&lt;&lt;3)	<span class="comment">/* network news subsystem */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_UUCP	(8&lt;&lt;3)	<span class="comment">/* UUCP subsystem */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_CRON	(9&lt;&lt;3)	<span class="comment">/* clock daemon */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_AUTHPRIV	(10&lt;&lt;3)	<span class="comment">/* security/authorization messages (private) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_FTP		(11&lt;&lt;3)	<span class="comment">/* ftp daemon */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* other codes through 15 reserved for system use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL0	(16&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL1	(17&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL2	(18&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL3	(19&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL4	(20&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL5	(21&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL6	(22&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL7	(23&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br></pre></td></tr></table></figure>
<p><code>syslog</code>用于输出日志。</p>
<p><code>priority</code>参数是<strong>设施值和日志级别</strong>的按位与，默认是<code>LOG_USER</code>。日志级别有下面几个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_EMERG	0	<span class="comment">/* system is unusable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_ALERT	1	<span class="comment">/* action must be taken immediately */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_CRIT	2	<span class="comment">/* critical conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_ERR		3	<span class="comment">/* error conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_WARNING	4	<span class="comment">/* warning conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_NOTICE	5	<span class="comment">/* normal but significant condition */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_INFO	6	<span class="comment">/* informational */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_DEBUG	7	<span class="comment">/* debug-level messages */</span></span></span><br></pre></td></tr></table></figure>
<p>第二个参数<code>message</code>和第三个参数<code>...</code>来结构化输出。</p>
<p><code>closelog</code>用于关闭日志</p>
<p>小例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    openlog(argv[<span class="number">0</span>], LOG_CONS | LOG_PID, LOG_USER);</span><br><span class="line">    syslog(LOG_DEBUG, <span class="string">&quot;This is a syslog test message generated by program &#x27;%s&#x27;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    closelog();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220818183131617.png" alt="image-20220818183131617"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络中小知识点</title>
    <url>/2022/08/05/Linux/Linux%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="Linux网络中小知识点"><a href="#Linux网络中小知识点" class="headerlink" title="Linux网络中小知识点"></a>Linux网络中小知识点</h1><p>记录一下Linux网络当中一些零碎的小知识点。</p>
<span id="more"></span>
<h2 id="1-通过-etc-services查看应用层网络协议"><a href="#1-通过-etc-services查看应用层网络协议" class="headerlink" title="1.通过/etc/services查看应用层网络协议"></a>1.通过<code>/etc/services</code>查看应用层网络协议</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/services</span><br></pre></td></tr></table></figure>
<p>可以看到</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220805144714394.png" alt="image-20220805144714394"></p>
<p>从里面我们可以看到很多<strong>应用层协议</strong>使用的是什么<strong>传输层协议</strong>以及常用的端口。比如<code>ssh</code>使用2号端口，并且使用tcp协议进行通讯。</p>
<h2 id="2-通过-etc-resolv-conf查看存放DNS服务器的IP地址"><a href="#2-通过-etc-resolv-conf查看存放DNS服务器的IP地址" class="headerlink" title="2.通过/etc/resolv.conf查看存放DNS服务器的IP地址"></a>2.通过<code>/etc/resolv.conf</code>查看存放DNS服务器的IP地址</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux//image-20220805171434655.png" alt="image-20220805171434655"></p>
<h2 id="3-通过-proc-sys-net-ipv4-tcp-tw-reuse来设置"><a href="#3-通过-proc-sys-net-ipv4-tcp-tw-reuse来设置" class="headerlink" title="3.通过/proc/sys/net/ipv4/tcp_tw_reuse来设置"></a>3.通过<code>/proc/sys/net/ipv4/tcp_tw_reuse</code>来设置</h2><p>我们也可以通过修改内核参数<code>/proc/sys/net/ipv4/tcp_tw_reuse</code>来快速回收被关闭的socket，从而使得TCP连接根本就不进入TIME_WAIT状态，进而允许应用程序立即重用本地的socket地址。</p>
<p><img src="新建文件夹/image-20220813173711574.png" alt="image-20220813173711574"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>dup和dup2函数</title>
    <url>/2022/08/19/Linux/dup%E5%92%8Cdup2%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="dup和dup2函数"><a href="#dup和dup2函数" class="headerlink" title="dup和dup2函数"></a>dup和dup2函数</h1><p><code>dup</code>和<code>dup2</code>用于复制文件描述符，通常用于重定向。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure>
<p><code>dup</code>函数创建一个新的文件描述符，该新文件描述符和原有文件描述符<code>oldfd</code>指向相同的文件、管道或者网络连接。并且dup返回的文件描述符总是取系统当前可用的最小整数值。</p>
<p><code>dup2</code>和<code>dup</code>类似，不过它将返回第一个不小于<code>newfd</code>的整数值的文件描述符，并且<code>newfd</code>这个文件描述符也将会指向<code>oldfd</code>指向的文件，原来的<code>newfd</code>指向的文件将会被关闭（除非<code>newfd</code>和<code>oldfd</code>相同）。</p>
<p><code>dup</code>和<code>dup2</code>系统调用失败时返回-1并设置<code>errno</code>，成功就返回新的文件描述符。</p>
<p><strong>注意：</strong>通过dup和dup2创建的文件描述符并<strong>不继承原文件描述符的属性</strong>，比如close-on-exec和non-blocking 等</p>
<span id="more"></span>
<p><code>dup</code>简单，输入<code>oldfd</code>直接返回复制的文件描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;text.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    assert(fd != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd = %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd2 = dup(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd2 = %d\n&quot;</span>, fd2);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">    write(fd, str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;world\n&quot;</span>;</span><br><span class="line">    write(fd2, str2, <span class="keyword">sizeof</span>(str2));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220815171158327.png" alt="image-20220815171158327"></p>
<p><code>dup2</code>感觉复杂一些，其实<code>dup2</code>忽略第二个参数，功能是和<code>dup</code>一样的，除此之外<code>dup2</code>加了一个将返回第一个不小于<code>newfd</code>的整数值的文件描述符的功能，并且<code>newfd</code>也将指向<code>oldfd</code>指向的文件。</p>
<p>下面的代码调用<code>dup2</code>，文件描述符fd2原来指向”text2.txt”文件的，调用<code>dup2</code>后，fd2改为指向”text.txt”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220815173243219.png" alt="image-20220815173243219"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;text.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;text2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    assert(fd1 != <span class="number">-1</span>);</span><br><span class="line">    assert(fd2 != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1 = %d, fd2 = %d\n&quot;</span>, fd1, fd2);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd3 = dup2(fd1, fd2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1 = %d,fd2 = %d,fd3 = %d\n&quot;</span>, fd1, fd2, fd3);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">    write(fd1, str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;world\n&quot;</span>;</span><br><span class="line">    write(fd2, str2, <span class="keyword">sizeof</span>(str2));</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot; hello world\n&quot;</span>;</span><br><span class="line">    write(fd3, str2, <span class="keyword">sizeof</span>(str2));</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    close(fd3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220815173321291.png" alt="image-20220815173321291"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>UID、EUID、GID和EGID</title>
    <url>/2022/08/21/Linux/UID%E3%80%81EUID%E3%80%81GID%E5%92%8CEGID/</url>
    <content><![CDATA[<h1 id="UID、EUID、GID和EGID"><a href="#UID、EUID、GID和EGID" class="headerlink" title="UID、EUID、GID和EGID"></a>UID、EUID、GID和EGID</h1><p>Linux中id真是太多了进程有pid，然后用户还有UID这种，真是有点绕。</p>
<p>在Linux当中一个进程（程序）拥有四个ID:真实用户<code>UID</code>、有效用户<code>EUID</code>、真实组<code>GID</code>和有效组<code>EGID</code>。</p>
<p>这里以真实用户<code>UID</code>和有效用户<code>EUID</code>为例，真实组<code>GID</code>和有效组<code>EGID</code>道理是相同的。</p>
<p><code>EUID</code>存在的目的是<strong>方便资源访问</strong>:它使得运行程序的用户拥有该程序的有效用户的权限（太过官方这种说法感觉）。<code>EUID</code>确定进程对某些资源和文件的访问权限。在大多数情况下，进程的<code>UID</code>和<code>EUID</code>是一样的，但是对于一些程序如<code>su</code>、<code>passwd</code>这种<code>set-user-id</code>程序，它们有可能是不相同的。对于<code>set-user-id</code>程序而言，程序的<code>EUID</code>会变成<strong>程序的所有者</strong>的<code>UID</code>，也就是说程序执行时，是以<strong>程序的所有者身份</strong>进行运行的。</p>
<span id="more"></span>
<p>以<code>passwd</code>为例。<code>passwd</code>允许用户修改自己的登录密码，这个<strong>程序的所有者</strong>是<code>root</code>，<code>passwd</code>权限中有<code>s</code>，表明这是一个<code>set-user-id</code>程序。<code>passwd</code>命令需要修改<code>/etc/shadow</code>文件，对于<code>/etc/shadow</code>文件，普通用户是不可写（只有读权限）的，那么用户怎么能够通过<code>passwd</code>修改自己的密码呢，<code>set-user-id</code>程序的标志<code>s</code>就起到了作用，它在程序运行时将<code>EUID</code>会变成<strong>程序的所有者</strong>的<code>UID</code>，那么程序有效的用户就会变成<strong>程序的所有者</strong>，在这里是<code>root</code>用户，理所当然的可以进行<code>/etc/shadow</code>文件的修改。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819104851240.png" alt="image-20220819104851240"></p>
<p>再比如<code>su</code>程序允许任何用户都可以使用它来修改自己的账户信息，但修改账户时程序不得不访问文件<code>/etc/passwd</code>文件，而访问该文件是需要<code>root</code>权限的。那么以<strong>普通用户身份</strong>启动的<code>su</code>程序如何能访问<code>/etc/passwd</code>文件呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819130924743.png" alt="image-20220819130924743"></p>
<p><code>su</code>程序的所有者是<code>root</code>，并且它被设置了<code>set-user-id</code>标志。和上面<code>passwd</code>一样，<code>set-user-id</code>标志表示任何普通用户运行<code>su</code>程序时，其有效用户就是该程序的<strong>所有者</strong><code>root</code>。</p>
<p>获取和设置真实用户<code>UID</code>、有效用户<code>EUID</code>、真实组<code>GID</code>和有效组<code>EGID</code>的函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">geteuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getegid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">seteuid</span><span class="params">(<span class="type">uid_t</span> euid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setegid</span><span class="params">(<span class="type">gid_t</span> egid)</span>;</span><br></pre></td></tr></table></figure>
<p>为了测试上面所说，我们先创建一个普通用户<code>bugcat</code>，目前已经有普通用户<code>ubuntu</code>。</p>
<p>可以看到<code>bugcat</code>的uid是<code>1002</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819140826977.png" alt="image-20220819140826977"></p>
<p>我们写下读取程序<code>uid</code>和<code>euid</code>的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uid_t</span> uid = getuid();</span><br><span class="line">    <span class="type">uid_t</span> euid = geteuid();</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;userid is %d, effective userid is: %d\n&quot;</span>, uid, euid );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将其编译一下，然后查看查看文件属性，再运行程序，可以看到<code>uid</code>和<code>euid</code>输出相同，表示<strong>真实用户</strong>和<strong>有效用户</strong>都是<code>ubuntu</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819141010532.png" alt="image-20220819141010532"></p>
<p>接着再将程序的所有者改为<code>root</code>，再加上<code>s</code>权限，再运行程序，可以看到<code>uid</code>和<code>euid</code>输出不相同，表示<strong>真实用户</strong>是<code>ubuntu</code>，<strong>有效用户</strong>是<code>root</code>（符合<code>set-user-id</code>程序特点）</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819141209028.png" alt="image-20220819141209028"></p>
<p>然后将程序的所有者改为<code>bugcat</code>（s权限不知道为啥自动取消了），再加上<code>s</code>权限，再运行程序，可以看到<code>uid</code>和<code>euid</code>输出不相同，表示<strong>真实用户</strong>是<code>ubuntu</code>，<strong>有效用户</strong>是<code>bugcat</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819141405860.png" alt="image-20220819141405860"></p>
<p>最后我们去掉<code>s</code>权限，运行程序，可以看到<code>uid</code>和<code>euid</code>输出相同，表示<strong>真实用户</strong>和<strong>有效用户</strong>都是<code>ubuntu</code>，也从反面说明<code>s</code>权限的作用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819142209993.png" alt="image-20220819142209993"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>fcntl函数</title>
    <url>/2022/08/19/Linux/fcntl%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h1><p><code>fcntl</code>函数提供了对文件描述符的各种控制操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure>
<p><code>fd</code>参数是被操作的文件描述符，<code>cmd</code>参数指定执行何种类型的操作。根据操作类型的不同，该函数可能还需要第三个可选参数 <code>arg</code>。<code>fcntl</code>函数支持的常用操作及其参数如下表所示。</p>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816114524640.png" alt="image-20220816114524640"></p>
<p><code>fcntl</code>函数成功时的返回值如表中最后一列所示，失败则返回-1并设置<code>errno</code>。</p>
<p>在网络编程中，<code>fcntl</code>函数通常用来将一个文件描述符设置为非阻塞的。</p>
<p>比如：终端文件默认是阻塞读的，这里用 fcntl 将其更改为非阻塞读</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TRY <span class="string">&quot;try again\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> flags, n;</span><br><span class="line"></span><br><span class="line">    flags = fcntl(STDIN_FILENO, F_GETFL); <span class="comment">//获取stdin属性信息</span></span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="type">int</span> ret = fcntl(STDIN_FILENO, F_SETFL, flags);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n = read(STDIN_FILENO, buf, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EAGAIN)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;read /dev/tty&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            write(STDOUT_FILENO, MSG_TRY, <span class="built_in">strlen</span>(MSG_TRY));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816115555375.png" alt="image-20220816115555375"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>sendfile函数</title>
    <url>/2022/08/19/Linux/sendfile%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="sendfile函数"><a href="#sendfile函数" class="headerlink" title="sendfile函数"></a>sendfile函数</h1><p><code>sendfile</code>函数在两个文件描述符之间直接传递数据（完全在内核中操作)，从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。<code>sendfile</code>函数的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<p><code>out_fd</code>参数是待写入内容的文件描述符</p>
<p><code>in_fd</code>参数是待读取内容的文件描述符</p>
<p><code>offset</code>参数是指从读入文件流的哪个位置开始读，如果为空，则使用读入文件流默认的起始位置</p>
<p><code>count</code>参数指定在文件描述符<code>in_fd</code>和<code>out_fd</code>之间传输的字节数</p>
<p><code>sendfile</code>成功时返回传输的字节数，失败则返回-1并设置<code>errno</code>。</p>
<p>该函数的man手册明确指出，<code>in_fd</code>必须是一个支持类似<code>mmap</code>函数的文件描述符，即它必须指向真实的文件，不能是socket和管道。而<code>out_fd</code>则必须是一个socket。由此可见，<code>sendfile</code>几乎是专门为在网络上传输文件而设计的。</p>
<span id="more"></span>
<p>用了一个书上的例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number filename\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file_name = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> filefd = open(file_name, O_RDONLY);</span><br><span class="line">    assert(filefd &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">    fstat(filefd, &amp;stat_buf);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(sock, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = accept(sock, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);</span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sendfile(connfd, filefd, <span class="literal">NULL</span>, stat_buf.st_size);</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220815185556863.png" alt="image-20220815185556863"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>readv函数和writev函数</title>
    <url>/2022/08/19/Linux/readv%E5%87%BD%E6%95%B0%E5%92%8Cwritev%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="readv函数和writev函数"><a href="#readv函数和writev函数" class="headerlink" title="readv函数和writev函数"></a>readv函数和writev函数</h1><p><code>readv</code>函数将数据从文件描述符读到分散的内存块中，即分散读; </p>
<p><code>writev</code>函数则将多块分散的内存数据一并写人文件描述符中，即集中写。它们的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br></pre></td></tr></table></figure>
<p><code>fd</code>被操作的目标文件描述符。</p>
<p><code>iov</code>是<code>iovec</code>类型的数组，在<code>recvmsg</code>和<code>sendmsg</code>中接触过。</p>
<p><code>iovcnt</code>是<code>iov</code>数组的长度。</p>
<span id="more"></span>
<p><code>iovec</code>结构体封装了一块内存的起始位置和长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span>                    <span class="comment">/* Scatter/gather array items */</span></span><br><span class="line">   <span class="type">void</span>  *iov_base;              <span class="comment">/* Starting address */</span></span><br><span class="line">   <span class="type">size_t</span> iov_len;               <span class="comment">/* Number of bytes to transfer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>readv</code>和 <code>writev</code>在成功时返回读出/写入<code>fd</code>的字节数，失败则返回-1并设置errno。</p>
<p><code>readv</code>和<code>writev</code>是个非常有用的函数。比如：当Web服务器解析完一个HTTP请求之后，如果目标文档存在且客户具有读取该文档的权限，那么它就需要发送一个HTTP应答来传输该文档。这个HTTP应答包含1个状态行、多个头部字段、1个空行和文档的内容。其中，前3部分的内容可能被Web服务器放置在一块内存中，而文档的内容则通常被读入到另外一块单独的内存中（通过read函数或mmap函数)。我们并不需要把这两部分内容拼接到一起再发送，而是可以使用writev函数将它们同时写出。</p>
<p>举一个man手册上<code>writev</code>函数的例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str0 = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">    <span class="type">char</span> *str1 = <span class="string">&quot;world\n&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    <span class="type">ssize_t</span> nwritten;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = str0;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(str0);</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = str1;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">strlen</span>(str1);</span><br><span class="line"></span><br><span class="line">    nwritten = writev(STDOUT_FILENO, iov, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220815180645424.png" alt="image-20220815180645424"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>splice函数</title>
    <url>/2022/08/19/Linux/splice%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="splice函数"><a href="#splice函数" class="headerlink" title="splice函数"></a>splice函数</h1><p><code>splice</code>用于在两个文件描述符之间移动数据，是零拷贝操作。看了<code>man</code>手册，发现这个<code>splice</code>函数跟pipe管道关系不浅。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816100155851.png" alt="image-20220816100155851"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span> *off_in, <span class="type">int</span> fd_out, <span class="type">loff_t</span> *off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p><code>fd_in</code>参数是待输人数据的文件描述符。如果<code>fd_in</code>是一个管道文件描述符，那么 <code>off_in</code>参数必须被设置为NULL。如果<code>fd_in</code>不是一个管道文件描述符（比如 socket)，那么<code>off_in</code>表示从输入数据流的何处开始读取数据。此时，若<code>off_in</code>被设置为NULL，则表示从输入数据流的当前偏移位置读入；若<code>off_in</code>不为NULL，则它将指出具体的偏移位置。</p>
<p><code>fd_out/off_out</code>参数的含义与<code>fd_in/off_in</code>相同，不过用于输出数据流。</p>
<p><code>len</code>参数指定移动数据的长度</p>
<p><code>flags</code>参数则控制数据如何移动，它可以被设置为下表中的某些值的按位或。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816100934412.png" alt="image-20220816100934412"></p>
<span id="more"></span>
<p>使用<code>splice</code>函数时，<code>fd_in</code>和<code>fd_out</code>必须至少有一个是管道文件描述符。</p>
<p><code>splice</code>函数调用成功时返回移动字节的数量。它可能返回0，表示没有数据需要移动，这发生在从管道中读取数据（<code>fd_in</code>是管道文件描述符）而该管道没有被写入任何数据时。<code>splice</code>函数失败时返回-1并设置<code>errno</code>。常见的<code>errno</code>如下表所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816101918940.png" alt="image-20220816101918940"></p>
<p>下面用了一个书中的例子，实现一个零拷贝的回射服务器，它将客户端发送的信息通过<code>splice</code>从<code>pipefd[1]</code>写入管道，再使用<code>splice</code>从<code>pipefd[0]</code>向客户端写东西，从而实现零拷贝的回射服务器（整个过程没有使用<code>read</code>或者<code>write</code>操作）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(sock, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = accept(sock, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);</span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line">        ret = pipe(pipefd);</span><br><span class="line">        ret = splice(connfd, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line">        ret = splice(pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, connfd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816102919876.png" alt="image-20220816102919876"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump进行ARP抓包</title>
    <url>/2022/08/05/Linux/tcpdump%E8%BF%9B%E8%A1%8CARP%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="tcpdump进行ARP抓包"><a href="#tcpdump进行ARP抓包" class="headerlink" title="tcpdump进行ARP抓包"></a>tcpdump进行ARP抓包</h1><p>在学习《Linux高性能服务器编程》中，看到作者对ARP使用<code>tcpdump</code>进行抓包，所以本着实践出真知、多看多练的道理，也进行抓包，顺带记录一下。</p>
<p>ARP协议的功能是实现网络层地址到任意物理地址的转换，简单理解ARP能够实现从<strong>IP地址</strong>转化为<strong>MAC地址</strong>的转化。</p>
<span id="more"></span>
<h2 id="arp命令"><a href="#arp命令" class="headerlink" title="arp命令"></a>arp命令</h2><p>Linux当中ARP 模块维护一个硬件地址到协议地址映射的缓存，可以通过<code>arp</code>命令或者<code>/proc/net/arp</code>文件查看。</p>
<p>使用<code>arp -a</code>查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux//image-20220805152235326.png" alt="image-20220805152235326"></p>
<p>使用<code>/proc/net/arp</code>查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux//image-20220805152319586.png" alt="image-20220805152319586"></p>
<p>我们也可以使用<code>arp</code>命令对缓存进行操作。</p>
<p>将<code>10.0.4.6</code>这个ip对应的MAC地址进行删除</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">arp -d 10.0.4.6</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220805152619382.png" alt="image-20220805152619382"></p>
<h2 id="tcpdump进行ARP抓包-1"><a href="#tcpdump进行ARP抓包-1" class="headerlink" title="tcpdump进行ARP抓包"></a>tcpdump进行ARP抓包</h2><p>上面arp命令是在云服务器上使用的，在使用tcpdump进行抓包时总是出现一些问题，感觉比不上物理机，所以专门找了个装Ubuntu的物理机进行了抓包测试。其中本机的ip：172.27.27.202，抓包抓的是ping 172.27.27.205的包。</p>
<p>实验过程：</p>
<p>一个窗口输入<code>tcpdump</code>命令—-&gt;另一个窗口输入ping命令—-&gt;<code>tcpdump</code>命令窗口获得数据包</p>
<p>输入抓包的<code>tcpdump</code>命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> tcpdump -ent -c 2 arp</span><br></pre></td></tr></table></figure>
<p>命令的参数介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-e 在每列倾倒资料上显示连接层级的文件头；</span><br><span class="line">-n 不把主机的网络地址转换成名字；</span><br><span class="line">-t 在每列倾倒资料上不显示时间戳记；</span><br><span class="line">-c 抓包的数目</span><br><span class="line">arp 表示只抓arp协议的包</span><br></pre></td></tr></table></figure>
<p>最终抓到的包的结果如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220805154805611.png" alt="image-20220805154805611"></p>
<p>总共抓到2个包，一个请求包一个应答包。</p>
<p>第一个数据包中，ARP通讯的源端的物理地址为<code>d4:5d:64:d0:4c:5d</code>（本机）,目的端的物理地址是<code>ff:ff:ff:ff:ff:ff</code>，这是以太网的<strong>广播</strong>地址，说明ARP开始是通过广播来询问的。数值<code>0x86</code>是以太网帧头部的类型字段的值，它表示是数据是ARP协议。<code>length 42</code>表示该<strong>以太网帧</strong>的长度是42字节（实际上是46字节，tcpdump没有统计以太网帧的末尾4字节的CRC字段）。<code>length 28</code>表示以太网帧的<strong>数据部分长度</strong>为28字节。<code>Request</code>表示这是ARP请求，<code>who-has 172.27.27.205 tell 172.27.27.202</code>就是很直白的”谁有<code>172.27.27.205</code>的MAC地址，请告诉<code>172.27.27.202</code></p>
<p>第二个数据包中，ARP通讯的源端的物理地址为<code>d2:07:ca:1b:75:58</code>,目的端的物理地址是<code>d4:5d:64:d0:4c:5d</code>。<code>length 60</code>表示该<strong>以太网帧</strong>的长度是60字节（实际上是64字节，tcpdump没有统计以太网帧的末尾4字节的CRC字段）。<code>length 46</code>表示以太网帧的<strong>数据部分长度</strong>为46字节（说明ARP应答被填充字节了）。<code>Reply</code>表示这是ARP应答。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>书上说ARP请求的报文为<strong>28</strong>字节，它属于以太网帧的数据部分，以太网帧的以太网头部+CRC校验的尾部一共<strong>18</strong>字节，所以一个携带ARP报文的以太网帧至少为<strong>46</strong>字节，但是由于实现要求<strong>以太网帧数据部分</strong>的长度至少要<strong>46</strong>字节，ARP报文此时会填充一些字节，也就是说一个携带ARP报文的以太网帧至少为<strong>60</strong>字节。这里以太网帧的大小和第二个数据包，也就是ARP应答数据相吻合。</p>
<p>但是第一个数据包ARP请求数据包则不符合设定，它只写了自己ARP请求的报文大小，并未进行字节填充，这里有一些不太理解。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220805165516292.png" alt="image-20220805165516292"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump进行DNS抓包</title>
    <url>/2022/08/05/Linux/tcpdump%E8%BF%9B%E8%A1%8CDNS%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="tcpdump进行DNS抓包"><a href="#tcpdump进行DNS抓包" class="headerlink" title="tcpdump进行DNS抓包"></a>tcpdump进行DNS抓包</h1><p>在学习《Linux高性能服务器编程》中，看到作者对DNS使用<code>tcpdump</code>进行抓包，所以本着实践出真知、多看多练的道理，也进行抓包，顺带记录一下。</p>
<p>我们先用<code>host</code>命令查询一下百度域名的IP地址</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">host -t A www.baidu.com</span><br></pre></td></tr></table></figure>
<p>其中<code>-t A</code>是指 查询你A类型的地址，不过我也没有弄清楚这个<code>A</code>是什么类型</p>
<p>查询结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220805191657175.png" alt="image-20220805191657175"></p>
<p>www.baidu.com是www.a.shifen.com的别名。www.a.shifen.com有两个地址112.80.248.75和112.80.248.76</p>
<span id="more"></span>
<p>使用tcpdump进行抓包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> tcpdump -i eth0 -nt -c 10  port domain</span><br></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-i 指定抓包的网卡</span><br><span class="line">-n 不把主机的网络地址转换成名字</span><br><span class="line">-t 在每列倾倒资料上不显示时间戳记</span><br><span class="line">-c 指定抓包的数量</span><br><span class="line">port domain表示只抓取使用domain（域名）服务的数据包</span><br></pre></td></tr></table></figure>
<p>最终抓取的有用结果截图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220805191641245.png" alt="image-20220805191641245"></p>
<p>总共手动两个数据包</p>
<p>第一个数据包中（DNS查询报文），从ip：10.0.4.5（本机）端口39454发向ip：183.60.83.19（DNS服务器）的53端口（DNS服务的端口），47814是DNS查询报文的标识值，因此该值也出现在DNS应答报文中。“+”表示启用递归查询标志。“A？”表示使用A类型的查询方式。“www.baidu.com”则是DNS查询问题中的查询名。“(31)”表示 DNS查询报文的长度为32字节</p>
<p>第二个数据包中（DNS应答报文），“3/0/0”表示该报文中包含3个应答资源记录、0个授权资源记录和0个额外信息记录。“CNAME www.a.shifen.com., A 112.80.248.76, A 112.80.248.75”则表示3个应答资源记录的内容。其中CNAME表示紧随其后的记录是机器的别名，A表示紧随其后的记录是ip地址。该应答报文的长度为90字节。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump进行IP抓包</title>
    <url>/2022/08/05/Linux/tcpdump%E8%BF%9B%E8%A1%8CIP%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="tcpdump进行IP抓包"><a href="#tcpdump进行IP抓包" class="headerlink" title="tcpdump进行IP抓包"></a>tcpdump进行IP抓包</h1><p>在学习《Linux高性能服务器编程》中，看到作者对IP头部使用<code>tcpdump</code>进行抓包，所以本着实践出真知、多看多练的道理，也进行抓包，顺带记录一下。</p>
<p><strong>注意这里的IP协议都是指IPv4协议。</strong></p>
<span id="more"></span>
<h2 id="IP头部结构"><a href="#IP头部结构" class="headerlink" title="IP头部结构"></a>IP头部结构</h2><p>IP协议可以说是网络通讯中最重要的协议之一，所以了解IP数据包的结构是非常有必要的。</p>
<p>IP数据报由<strong>报头</strong>和<strong>数据</strong>两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。</p>
<p>IP的<strong>头部结构</strong>如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220806113346237.png" alt="image-20220806113346237"></p>
<p>固定部分为实线部分，长度为20字节。可变长的选项部分长度最多40字节，所以IP头部最多60字节长。</p>
<p>1) 版本号</p>
<p>占 4 位，表示 IP 协议的版本。在IPv4中的值是4。</p>
<p>2) 头部长度</p>
<p>占 4 位，可表示的最大十进制数值是 15。头部长度表示IP头部有多少个32bit字（4字节），所以IP头部最长是60字节。</p>
<p>3) 服务类型（tos）</p>
<p>占 8 位，用来获得更好的服务。分为3位的优先权字段（现在以及被忽略），4位的TOS字段和1位保留字段（必须置为0）。4位的TOS字段分别表示：最小延时，最大吞吐量，最高可靠性和最小非也。其中最多有一个能置为1，应用程序根据实际需要来设置，比如ssh和telnet这样的服务就需要最小延时服务。</p>
<p>4) 总长度（totlen）</p>
<p>占16 位，表示<strong>整个数据报的长度</strong>（字节为单位），因此IP数据报的最大长度为 2^16-1=65535 字节。但是由于MTU的限制，长度超过MTU的数据报会被分片，所以实际传输IP数据报的长度远远没有达到最大值。</p>
<p>5) 标识（identification）</p>
<p>占 16 位。IP 协议在存储器中维持一个计数器。每产生一个数据报，计数器就加 1，并将此值赋给标识字段，其初始值由系统随机生成。当数据报的长度超过网络的 MTU，而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。具有相同的标识字段值的分片报文会被重组成原来的数据报。</p>
<p>6) 标志（flag）</p>
<p>占 3 位。第一位保留，其值为 0。第二位称为 DF（不分片），表示是否允许分片。取值为 0 时，表示允许分片；取值为 1 时，表示不允许分片。第三位称为 MF（更多分片），表示是否还有分片正在传输，设置为 0 时，表示没有更多分片需要发送，或数据报没有分片，比如：在分片的数据报中最后一个分片将这位设置位0，其他分片都要把它置为1。</p>
<p>7) 片偏移（offsetfrag）</p>
<p>占 13 位。当报文被分片后，该字段标记该分片在原报文中的相对位置。片偏移以 8 个字节为偏移单位。所以，除了最后一个分片，其他分片的偏移值都是 8 字节（64 位）的整数倍。由于这个原因，每个IP分片的数据部分的长度必须是8的整数倍（最后一个分片除外）。</p>
<p>8) 生存时间（TTL）</p>
<p>占 8 位，表示数据报在网络中的寿命。该字段由发出数据报的源主机设置。其目的是防止无法交付的数据报无限制地在网络中传输，从而消耗网络资源。</p>
<p>路由器在转发数据报之前，先把 TTL 值减 1。若 TTL 值减少到 0，则丢弃这个数据报，不再转发。因此，TTL 指明数据报在网络中最多可经过多少个路由器。TTL 的最大数值为 255。若把 TTL 的初始值设为 1，则表示这个数据报只能在本局域网中传送。 </p>
<p>9) 协议</p>
<p>占 8 位，表示该数据报文所携带的数据所使用的协议类型。该字段可以方便目的主机的 IP 层知道按照什么协议来处理数据部分。不同的协议有专门不同的协议号。</p>
<p>例如，TCP 的协议号为 6，UDP 的协议号为 17，ICMP 的协议号为 1。</p>
<p>10) 头部检验和（checksum）</p>
<p>用于校验数据报的首部，占 16 位。数据报每经过一个路由器，首部的字段都可能发生变化（如TTL），所以需要重新校验。而数据部分不发生变化，所以不用重新生成校验值。</p>
<p>11) 源地址</p>
<p>表示数据报的源 IP 地址，占 32 位。</p>
<p>12) 目的地址</p>
<p>表示数据报的目的 IP 地址，占 32 位。该字段用于校验发送是否正确。</p>
<p>13) 可选字段</p>
<p>该字段用于一些可选的报头设置，主要用于测试、调试和安全的目的。这些选项包括严格源路由（数据报必须经过指定的路由）、网际时间戳（经过每个路由器时的时间戳记录）和安全限制。</p>
<p>14) 填充</p>
<p>由于可选字段中的长度不是固定的，使用若干个 0 填充该字段，可以保证整个报头的长度是 32 位的整数倍。</p>
<h2 id="使用tcpdump观察IPv4头部结构"><a href="#使用tcpdump观察IPv4头部结构" class="headerlink" title="使用tcpdump观察IPv4头部结构"></a>使用tcpdump观察IPv4头部结构</h2><p>我们抓取本地回路上的数据包，通过<code>telnet 127.0.0.1</code>配合<code>tcpdump</code>进行抓包</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220806142812432.png" alt="image-20220806142812432"></p>
<p>抓包命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> tcpdump -ntx -i lo -c 1</span><br></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-n 不把主机的网络地址转换成名字</span><br><span class="line">-t 在每列倾倒资料上不显示时间戳记</span><br><span class="line">-x 用十六进制字码列出数据包资料</span><br><span class="line">-i 抓取指定网卡的包</span><br><span class="line">-c 抓取包的个数</span><br></pre></td></tr></table></figure>
<p>最终抓包结果如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220805223608148.png" alt="image-20220805223608148"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP 127.0.0.1.52904 &gt; 127.0.0.1.23: Flags [S], seq 1003093548, win 65495, options [mss 65495,sackOK,TS val 3642507651 ecr 0,nop,wscale 7], length 0</span><br><span class="line">	0x0000:  4510 003c af8c 4000 4006 8d1d 7f00 0001</span><br><span class="line">	0x0010:  7f00 0001 cea8 0017 3bc9 fe2c 0000 0000</span><br><span class="line">	0x0020:  a002 ffd7 fe30 0000 0204 ffd7 0402 080a</span><br><span class="line">	0x0030:  d91c 4183 0000 0000 0103 0307</span><br></pre></td></tr></table></figure>
<p>因为我们是<code>telnet 127.0.0.1</code>所以我们源地址和目标地址都是<code>127.0.0.1</code>只不过一个是客户端端口<code>52904</code>到目标端口<code>23</code>（telnet端口）。</p>
<p>“Flag”、“seq”、“win”和“options”都是TCP头部信息（telnet使用的是TCP协议），所以在这里不是我们的重点。</p>
<p><code>length</code>表示应用程序数据的长度（并不是IP数据部分）。这里数据包共包含<strong>60字节</strong>，其中<strong>前20字节是IP头部，后40字节是TCP头部</strong>，不包含应用程序数据（length值为0）。</p>
<p>接下来我们重点关注IP头部的数据，截取一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000:  4510 003c af8c 4000 4006 8d1d 7f00 0001</span><br><span class="line">0x0010:  7f00 0001</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>十六进制数</th>
<th>十进制数</th>
<th>IP头部信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x4</td>
<td>4</td>
<td>IP版本号</td>
</tr>
<tr>
<td>0x5</td>
<td>5</td>
<td>头部长度为5个32位（20字节）</td>
</tr>
<tr>
<td>0x10</td>
<td></td>
<td>TOS选项中最小延时服务被开启</td>
</tr>
<tr>
<td>0x003c</td>
<td>60</td>
<td>数据包总长度，60字节</td>
</tr>
<tr>
<td>0xaf8c</td>
<td></td>
<td>数据报标识</td>
</tr>
<tr>
<td>0x4</td>
<td></td>
<td>3位标志，设置禁止分片</td>
</tr>
<tr>
<td>0x000</td>
<td>0</td>
<td>分片偏移</td>
</tr>
<tr>
<td>0x40</td>
<td>64</td>
<td>TTL被设为64</td>
</tr>
<tr>
<td>0x06</td>
<td>6</td>
<td>协议字段为6，表示上层协议是TCP协议</td>
</tr>
<tr>
<td>0x8d1d</td>
<td></td>
<td>IP头部校验和</td>
</tr>
<tr>
<td>0x7f00 0001</td>
<td></td>
<td>源端IP地址127.0.0.1</td>
</tr>
<tr>
<td>0x7f00 0001</td>
<td></td>
<td>目的端IP地址127.0.0.1</td>
</tr>
</tbody>
</table>
</div>
<h2 id="IP分片抓包"><a href="#IP分片抓包" class="headerlink" title="IP分片抓包"></a>IP分片抓包</h2><p>上面抓包并没有进行分片，所以为了了解分片，还需要进行抓包，查看分片情况。</p>
<p>这次使用ping命令配合<code>tcpdump</code>进行抓包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ping baidu.com -s 1473</span><br></pre></td></tr></table></figure>
<p>因为以太网帧MTU是1500字节，因此它所携带的IP数据报的<strong>数据部分</strong>最多1480字节（IP头部占20字节），然还因为ping使用的是ICMP协议，ICMP头部占8字节，所以ICMP数据部分最多占1472字节。</p>
<p>我们使用ping命令发送1473个字节，那么这个IP数据报自然而然的会进行分片。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220806153303334.png" alt="image-20220806153303334"></p>
<p>然还使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> tcpdump -ntx -i eth0  icmp &gt; a.txt</span><br></pre></td></tr></table></figure>
<p>将抓的包的内容放到文件<code>a.txt</code>当中。</p>
<p>然后去除其中有用的部分如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP 10.0.4.5 &gt; 110.242.68.66: ICMP echo request, id 25, seq 1, length 1480</span><br><span class="line">	0x0000:  4500 05dc a74e 2000 4001 ec99 0a00 0405</span><br><span class="line">	0x0010:  6ef2 4442 0800 2d22 0019 0001 4df3 ed62</span><br><span class="line">	0x0020:  0000 0000 7e4a 0400 0000 0000 1011 1213</span><br><span class="line">	0x0030:  1415 1617 1819 1a1b 1c1d 1e1f 2021 2223</span><br><span class="line">	...(数据太多不进行全部展示)</span><br><span class="line">	</span><br><span class="line">IP 10.0.4.5 &gt; 110.242.68.66: ip-proto-1</span><br><span class="line">	0x0000:  4500 0015 a74e 00b9 4001 11a8 0a00 0405</span><br><span class="line">	0x0010:  6ef2 4442 c0</span><br></pre></td></tr></table></figure>
<p>可以看到</p>
<p><strong>第一个包的IP头部</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP 10.0.4.5 &gt; 110.242.68.66: ICMP echo request, id 25, seq 1, length 1480</span><br><span class="line">	0x0000:  4500 05dc a74e 2000 4001 ec99 0a00 0405</span><br><span class="line">	0x0010:  6ef2 4442 </span><br></pre></td></tr></table></figure>
<p>其中<code>0x05dc</code>代表IP数据报的总长度为1500字节</p>
<p>其中<code>0X2000</code>是3位标志字段和13位分片偏移。它的二进制为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0010 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p>标志位第三位（MF）为1，表示有分片。因为是一个分片包所以偏移为0</p>
<p><strong>第二个 包的IP头部</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP 10.0.4.5 &gt; 110.242.68.66: ip-proto-1</span><br><span class="line">	0x0000:  4500 0015 a74e 00b9 4001 11a8 0a00 0405</span><br><span class="line">	0x0010:  6ef2 4442 </span><br></pre></td></tr></table></figure>
<p>其中<code>0x0015</code>代表IP数据报的总长度为21字节</p>
<p>其中<code>0X00b9</code>是3位标志字段和13位分片偏移。它的二进制为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 1011 1001</span><br></pre></td></tr></table></figure>
<p>前三位标志位都为0，表示这是最后一个分片包，<code>0xb9</code>十进制是271，然后再乘以8等于1480，即偏移是1480字节，也和前面介绍的片偏移内容吻合。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>tee函数</title>
    <url>/2022/08/19/Linux/tee%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="tee函数"><a href="#tee函数" class="headerlink" title="tee函数"></a>tee函数</h1><p><code>tee</code>函数在两个管道描述符之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据仍然可以用于后续操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">tee</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">int</span> fd_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p><code>fd_in</code>和<code>fd_out</code>是文件描述符，但是必须是管道文件描述符</p>
<p><code>len</code>参数指定移动数据的长度</p>
<p><code>flags</code>参数则控制数据如何移动，它可以被设置为下表中的某些值的按位或，它的参数其实和<code>splice</code>函数相同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816100934412.png" alt="image-20220816100934412"></p>
<p><code>tee</code>函数成功时返回在两个文件描述符之间复制的数据数量（字节数)。返回0表示没有复制任何数据。<code>tee</code>失败时返回-1并设置<code>errno</code>。</p>
<span id="more"></span>
<p>书中代码利用<code>tee</code>函数和<code>splice</code>函数，实现了Linux 下<code>tee</code>程序（同时输出数据到终端和文件的程序，不要和<code>tee</code>函数混淆）的基本功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> filefd = open(argv[<span class="number">1</span>], O_CREAT | O_WRONLY | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">	assert(filefd &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pipefd_stdout[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> ret = pipe(pipefd_stdout);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pipefd_file[<span class="number">2</span>];</span><br><span class="line">	ret = pipe(pipefd_file);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// close( STDIN_FILENO );</span></span><br><span class="line">	<span class="comment">//  dup2( pipefd_stdout[1], STDIN_FILENO );</span></span><br><span class="line">	<span class="comment">// write( pipefd_stdout[1], &quot;abc\n&quot;, 4 );</span></span><br><span class="line">	ret = splice(STDIN_FILENO, <span class="literal">NULL</span>, pipefd_stdout[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	ret = tee(pipefd_stdout[<span class="number">0</span>], pipefd_file[<span class="number">1</span>], <span class="number">32768</span>, SPLICE_F_NONBLOCK);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	ret = splice(pipefd_file[<span class="number">0</span>], <span class="literal">NULL</span>, filefd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	ret = splice(pipefd_stdout[<span class="number">0</span>], <span class="literal">NULL</span>, STDOUT_FILENO, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	close(filefd);</span><br><span class="line">	close(pipefd_stdout[<span class="number">0</span>]);</span><br><span class="line">	close(pipefd_stdout[<span class="number">1</span>]);</span><br><span class="line">	close(pipefd_file[<span class="number">0</span>]);</span><br><span class="line">	close(pipefd_file[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816111052593.png" alt="image-20220816111052593"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>信号</title>
    <url>/2022/08/22/Linux/%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>学习《Linux高性能服务器编程》第十章信号，为了印象深刻一些，多动手多实践，所以记下这个笔记。这一篇主要记录Linux中</p>
<p>Linux信号概述、信号集、信号函数和一些疑惑。</p>
<span id="more"></span>
<h2 id="Linux信号概述"><a href="#Linux信号概述" class="headerlink" title="Linux信号概述"></a>Linux信号概述</h2><h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><p>Linux 下，一个进程给其他进程发送信号的API是<code>kill</code>函数。其定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数把信号<code>sig</code>发送给目标进程；目标进程<code>pid</code>参数指定，其可能的取值以及含义如表所展示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220822113352089.png" alt="image-20220822113352089"></p>
<p><code>Linux</code>当中信号都大于0，如果<code>sig</code>取值为0，则<code>kill</code>函数不发送任何信号。这种方法可以用来检测目标进程或进程组是否存在，但是这种方法是不可靠的（这种方法不是原子操作）。</p>
<p>该函数成功时返回0，失败则返回-1并设置<code>errno</code>。几种可能的<code>errno</code>如表所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220822114203553.png" alt="image-20220822114203553"></p>
<h3 id="信号处理方式"><a href="#信号处理方式" class="headerlink" title="信号处理方式"></a>信号处理方式</h3><p>在目标进程收到信息时，需要定义一个接收函数来处理。信号处理函数的原则如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Type of a signal handler.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">__sighandler_t</span>)</span> <span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>信号处理函数只带有一个整型参数，该参数用来指示信号类型。信号处理函数应该是<strong>可重入</strong>的，否则很容易引发一些竞态条件。所以在信号处理函数中<strong>严禁</strong>调用一些不安全的函数。</p>
<p>除了用户自己定义信号处理函数之外，Linux当中还定义了信息号的两种其他处理方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	SIG_DFL	 ((__sighandler_t)  0)	<span class="comment">/* Default action.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SIG_IGN	 ((__sighandler_t)  1)	<span class="comment">/* Ignore signal.  */</span></span></span><br></pre></td></tr></table></figure>
<p><code>SIG_IGN</code>表示忽略目标信号，<code>SIG_DFL</code>表示使用信号默认处理方式。信号默认处理方式有如下几种:结束进程（Term)、忽略信号(Ign)、结束进程并生成核心转储文件(Core)、暂停进程（Stop)，以及继续进程（Cont)。</p>
<h3 id="Linux信号"><a href="#Linux信号" class="headerlink" title="Linux信号"></a>Linux信号</h3><p>在linux上，可以使用<code>kill -l</code>命令看到所有的信号，但是我们并不关心这些所有的信号，只用重点关心<code>SIGHUP</code>、<code>SIGPIPE</code>、<code>SIGURG</code>、<code>SIGALRM</code>、<code>SIGCHLD</code>等几个信号即可。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>信号</th>
<th>起源</th>
<th>默认行为</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SIGHUP</code></td>
<td>POSIX</td>
<td>Term</td>
<td>控制终端挂起</td>
</tr>
<tr>
<td><code>SIGPIPE</code></td>
<td>POSIX</td>
<td>Term</td>
<td>往读端被关闭的管道或者socket连接中些数据</td>
</tr>
<tr>
<td><code>SIGURG</code></td>
<td>4.2BSD</td>
<td>Ign</td>
<td>socket连接上接收到紧急数据</td>
</tr>
<tr>
<td><code>SIGALRM</code></td>
<td>POSIX</td>
<td>Term</td>
<td>由alarm 或setitimer设置的实时闹钟超时引起</td>
</tr>
<tr>
<td><code>SIGCHLD</code></td>
<td>POSIX</td>
<td>Ign</td>
<td>子进程状态发生变化（退出或者暂停)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><h3 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h3><p>信号集<code>sigset_t</code>的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __val[_SIGSET_NWORDS];</span><br><span class="line">&#125; <span class="type">__sigset_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>由该定义可见，<code>sigset_t</code>实际上是一个长整型数组，数组的每个元素的每个位表示一个信号（虽然不知道为啥定义多个元素）。这种定义方式和文件描述符集<code>fd_set</code>类似。<code>Linux</code>提供了如下一组函数来设置、修改、删除和查询信号集:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;						<span class="comment">/* 清空信号集 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;						<span class="comment">/* 在信号集中设置所有的信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;			<span class="comment">/* 将信号signum添加到信号集中 */</span>	</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;			<span class="comment">/* 将信号signum从到信号集中删除 */</span>	</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;	<span class="comment">/* 测试信号signum是否在信号集中 */</span>	</span><br></pre></td></tr></table></figure>
<h3 id="进程掩码"><a href="#进程掩码" class="headerlink" title="进程掩码"></a>进程掩码</h3><p>内核会为每个进程维护一个信号掩码，即一组信号，并将<strong>阻塞</strong>其针对该进程的传递。如果将遭<strong>阻塞</strong>的信号发给某进程，那么对该信号的传递将延后，直至从进程信号掩码中移除该信号，从而解除阻塞为止。（信号掩码实际属于线程属性，在多线程进程中，每个线程都可使用 pthread_sigmask() 函数来独立检查和修改其信号掩码。）</p>
<p>下面的函数可以用于设置或查看进程的信号掩码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Prototype for the glibc wrapper function */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure>
<p><code>set</code>参数指定新的信号掩码</p>
<p><code>oldset</code>参数输出原来的信号掩码（不过不为NULL）</p>
<p>如果<code>set</code>参数不为NULL，则<code>how</code>参数指定设置进程信号掩码的方式，其可选值如表所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220825111927286.png" alt="image-20220825111927286"></p>
<p>如果<code>set</code>为 NULL，则进程信号掩码不变，此时我们仍然可以利用<code>oldset</code>参数来获得进程当前的信号掩码。</p>
<p><code>sigprocmask</code>成功时返回0，失败则返回-1并设置<code>errno</code>。</p>
<h3 id="被挂起的信号"><a href="#被挂起的信号" class="headerlink" title="被挂起的信号"></a>被挂起的信号</h3><p>设置进程信号掩码后，被屏蔽的信号将不能被进程接收。如果给进程发送一个被屏蔽的信号，则操作系统将该信号设置为进程的一个<strong>被挂起的信号</strong>。如果我们取消对被挂起信号的屏蔽，则它能立即被进程接收到。如下函数可以获得进程当前被挂起的信号集:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><code>set</code>用于保存被挂起的信号集。</p>
<p><code>sigpending</code>成功时返回0，失败则返回-1并设置<code>errno</code>。</p>
<p>进程<strong>多次</strong>接收到同一个被挂起的信号,<code>sigpending</code>函数也只能反映一次。并且，当我们再次使用<code>sigprocmask</code><strong>使能</strong>该挂起的信号时，该信号的处理函数也只被触发一次。</p>
<p>信号集这几个函数<strong>举例</strong>：</p>
<p>我们以<code>SIGINT</code>和<code>SIGQUIT</code>为例，就是键盘上按下（Ctrl+C）和（Ctrl+\）为例。</p>
<p>通过<code>sigprocmask</code>设置这两个信号被挂起，然后分别按下（Ctrl+C）和（Ctrl+\），再通过<code>sigpending</code>查看那些进程被挂起（这个进程可以通过<code>kill</code>杀死）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220825181937952.png" alt="image-20220825181937952"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printset</span><span class="params">(<span class="type">sigset_t</span> *ped)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((sigismember(ped, i) == <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>, oldset, ped;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oldset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程信号掩码:&quot;</span>);</span><br><span class="line">    printset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sigpending(&amp;ped); <span class="comment">//获取信号集</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;被挂起的信号掩码:&quot;</span>);</span><br><span class="line">        printset(&amp;ped);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220825215756905.png" alt="image-20220825215756905"></p>
<h2 id="信号函数"><a href="#信号函数" class="headerlink" title="信号函数"></a>信号函数</h2><p>处理或者说捕捉信号的函数有<code>signal</code>和<code>sigaction</code></p>
<h3 id="signal系统调用"><a href="#signal系统调用" class="headerlink" title="signal系统调用"></a>signal系统调用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>
<p><code>signum</code>参数指出要捕获的信号类型。</p>
<p><code>handler</code>参数是<code>sighandler_t</code>类型的函数指针，用于指定信号<code>signum</code>的处理函数。</p>
<p><code>signal</code>函数成功时返回一个函数指针，该函数指针的类型也是<code>sighandler_t</code>。这个返回值是前一次调用<code>signal</code>函数时传入的函数指针，或者是信号<code>signum</code>对应的默认处理函数指针<code>SIG_DEF</code>（如果是第一次调用<code>signal</code>的话)。</p>
<p><code>signal</code>系统调用出错时返回<code>SIG_ERR</code>，并设置<code>errno</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	SIG_ERR	 ((__sighandler_t) -1)	<span class="comment">/* Error return.  */</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_sig</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hi, SIGINT, how do you do !\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置SIGINT信号（ctrl+C）对应的事件</span></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, do_sig) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---------------------\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220825182345010.png" alt="image-20220825182345010"></p>
<p>可以看的按下<code>ctrl+c</code>之后是杀不死这个进程的，但是可以通过“ctrl+\”或者关闭shell或者通过kill命令进行杀死。</p>
<h3 id="sigaction系统函数"><a href="#sigaction系统函数" class="headerlink" title="sigaction系统函数"></a>sigaction系统函数</h3><p>设置信号处理函数更为健壮的方法如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure>
<p><code>signum</code>参数指出要捕获的信号类型</p>
<p><code>act</code>参数指定新的信号处理方式</p>
<p><code>oldact</code>参数输出信号之前处理的方式（如果不为NULL的话）。</p>
<p><code>act</code>和<code>oldact</code>都是<code>sigaction</code>结构体类型的指针，<code>sigaction</code>结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">   <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">   <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">   <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">   <span class="type">int</span>        sa_flags;</span><br><span class="line">   <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体中的<code>sa_handler</code>成员指定信号处理函数。</p>
<p><code>sa_mask</code>成员设置进程的信号掩码(确切地说是在进程原有信号掩码的基础上<strong>增加</strong>信号掩码)，以指定哪些信号<strong>不能</strong>发送给本进程。<code>sa_mask</code>是信号集<code>sigset_t</code>(<code>_sigset_t</code>的同义词）类型，该类型指定一组信号。</p>
<p><code>sa_flags</code>成员用于设置程序收到信号时的行为，其可选值如表所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220824165327097.png" alt="image-20220824165327097"></p>
<p><code>sa_restorer</code>成员已经过时，最好不要使用。</p>
<p><code>sigaction</code>成功时返回0，失败则返回-1并设置<code>errno</code>。</p>
<p><code>sigaction</code>中有信号集，所以最好配合信号集函数一起使用。</p>
<p>简单是使用例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*自定义的信号捕捉函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_int</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;catch signal SIGINT\n&quot;</span>); <span class="comment">//单次打印</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">	act.sa_handler = sig_int;</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask); <span class="comment">//不屏蔽任何信号</span></span><br><span class="line"></span><br><span class="line">	sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;---------------------\n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220826155323696.png" alt="image-20220826155323696"></p>
<h2 id="一些疑惑"><a href="#一些疑惑" class="headerlink" title="一些疑惑"></a>一些疑惑</h2><p>第一个疑惑是进程在处理一个信号的过程中，能接收另一个信号吗？</p>
<p>答案是可以的，下面的代码接收了两个<code>SIGINT</code>和<code>SIGQUIT</code>两个信号，在按下（Ctrl+C）后立刻按下（Ctrl+\），都能进行输出，说明进程在处理一个信号的过程中，能接收另一个信号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*自定义的信号捕捉函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_int</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;catch signal SIGINT\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>); <span class="comment">//模拟信号处理函数执行很长时间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end of SIGINT handler\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_quit</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;catch signal SIGQUIT\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>); <span class="comment">//模拟信号处理函数执行很长时间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end of SIGQUIT handler\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act1</span>, <span class="title">act2</span>;</span></span><br><span class="line"></span><br><span class="line">    act1.sa_handler = sig_int;</span><br><span class="line">    sigemptyset(&amp;act1.sa_mask); <span class="comment">//不屏蔽任何信号</span></span><br><span class="line">    act1.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    act2.sa_handler = sig_quit;</span><br><span class="line">    sigemptyset(&amp;act2.sa_mask); <span class="comment">//不屏蔽任何信号</span></span><br><span class="line">    act2.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sigaction(SIGINT, &amp;act1, <span class="literal">NULL</span>);  <span class="comment">//注册信号处理函数</span></span><br><span class="line">    sigaction(SIGQUIT, &amp;act2, <span class="literal">NULL</span>); <span class="comment">//注册信号处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---------------------\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220826161922094.png" alt="image-20220826161922094"></p>
<p>第二个疑惑是信号在处理一个信号的过程中，会阻塞（挂起）这个信号吗？</p>
<p>个人感觉是阻塞了这个信号的。也就是第1个信号在处理的过程中，收到再多这个信号也是不会进行处理的，知道第2个信号处理完毕，后面的第2到n个信号当作一次信号进行处理（这里的信号指相同一种信息）。</p>
<p>我们以<code>SIGINT</code>为例，当我们按下（Ctrl+C）后，<code>SIGINT</code>信号的回调函数在进行处理，处理的过程中我们疯狂的按（Ctrl+C），最终后续的<code>SIGINT</code>信息只当作一次信息进行处理了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*自定义的信号捕捉函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_int</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;catch signal SIGINT\n&quot;</span>);</span><br><span class="line">	sleep(<span class="number">5</span>); <span class="comment">//模拟信号处理函数执行很长时间</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;end of SIGINT handler\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">	act.sa_handler = sig_int;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask); <span class="comment">//不屏蔽任何信号</span></span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>); <span class="comment">//注册信号处理函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;---------------------\n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220826163813060.png" alt="image-20220826163813060"></p>
<p>第三个疑惑是信号被屏蔽之后，我们多次发送该信号，信号被挂起了，再“解挂”或者叫取消屏蔽情况会如何？</p>
<p>实际情况是，取消屏蔽后只会执行一次信号处理，后续的信号处理和普通信号处理相同。</p>
<p>我们以<code>SIGINT</code>为例，先屏蔽<code>SIGINT</code>这个信息，在此期间我们不停的发信息，后续取消屏蔽后，信号的回调函数被处理了一次。再后续的信息处理和普通信号类似。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*自定义的信号捕捉函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_int</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;catch signal SIGINT\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">	act.sa_handler = sig_int;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask); <span class="comment">//不屏蔽任何信号</span></span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>); <span class="comment">//注册信号处理函数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">sigset_t</span> <span class="built_in">set</span>, oldset, ped;</span><br><span class="line">	sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">	sigaddset(&amp;<span class="built_in">set</span>, SIGINT); <span class="comment">// 将SIGINT进行屏蔽</span></span><br><span class="line">	sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oldset);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-----begin sleep 10s--\n&quot;</span>);</span><br><span class="line">	sleep(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-----end sleep 10s--\n&quot;</span>);</span><br><span class="line">	sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, &amp;oldset);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;---------------------\n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220826165823734.png" alt="image-20220826165823734"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>改变工作目录和根目录</title>
    <url>/2022/08/21/Linux/%E6%94%B9%E5%8F%98%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E6%A0%B9%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h1 id="改变工作目录和根目录"><a href="#改变工作目录和根目录" class="headerlink" title="改变工作目录和根目录"></a>改变工作目录和根目录</h1><p>进程有工作目录和根目录。</p>
<p>工作目录：进程在哪个路径下被运行起来哪个路径就是进程的工作目录(Current Woring Directory, CWD)</p>
<p>根目录：就是”/“</p>
<p>工作目录和根目录可以通过<code>/proc/PID/cwd</code>和<code>/proc/PID/root</code>进行查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220821175748810.png" alt="image-20220821175748810"></p>
<span id="more"></span>
<p>工作目录和根目录都可以进行更改，获取进程当前工作目录和改变进程工作目录的函数分别是:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>
<p><code>buf</code>参数指向的内存用于存储进程当前工作目录的绝对路径名，其大小由<code>size</code>参数指定。</p>
<p>如果当前工作目录的绝对路径的长度（再加上一个空结束字符“\0”)超过了<code>size</code>，则<code>getcwd</code>将返回<code>NULL</code>，并设置<code>errno</code>为<code>ERANGE</code>。</p>
<p>如果<code>buf</code>为<code>NULL</code>并且<code>size</code>非0，则<code>getcwd</code>可能在内部使用<code>malloc</code>动态分配内存，并将进程的当前工作目录存储在其中。如果是这种情况，则我们必须自己来释放<code>getcwd</code>在内部创建的这块内存。</p>
<p><code>getcwd</code>函数成功时返回一个指向目标存储区（<code>buf</code>指向的缓存区或是<code>getcwd</code>在内部动态创建的缓存区）的指针，失败则返回<code>NULL</code>并设置<code>errno</code>。</p>
<p><code>chdir</code>函数的<code>path</code>参数指定要切换到的目标目录。它成功时返回0，失败时返回-1并设置<code>errno</code>。</p>
<p>改变进程根目录可以使用<code>chroot</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chroot</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>
<p><code>path</code>参数指定要切换到的目标根目录。它成功时返回0，失败时返回-1并设置<code>errno</code>。</p>
<p><code>chroot</code><strong>并不改变</strong>进程的当前工作目录。</p>
<p>改变进程的根目录之后，程序可能无法访问类似<code>/dev</code>的文件（和目录)，因为这些文件（和目录〉并非处于新的根目录之下。不过好在调用<code>chroot</code>之后，进程原先打开的文件描述符依然生效，所以我们可以利用这些早先打开的文件描述符来访问调用<code>chroot</code>之后不能直接访问的文件（和目录)，尤其是一些日志文件。此外，只有<strong>特权进</strong>程才能改变根目录。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间关系</title>
    <url>/2022/08/21/Linux/%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h1><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>Linux下每个进程都隶属于一个进程组，因此它们除了PID信息外，还有进程组ID(<code>PGID</code>)。我们可以用如下函数来获取指定进程<code>PGID</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数成功时返回进程pid所属进程组的<code>PGID</code>，失败则返回-1并设置<code>errno</code>。</p>
<p>每个进程组都有一个首领进程，其<code>PGID</code>和<code>PID</code>相同。进程组将一直存在，直到其中所有进程都退出，或者加入到其他进程组。下面的函数用于设置<code>PGID</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数将<code>PID</code>为<code>pid</code>的进程的<code>PGID</code>设置为<code>pgid</code>。</p>
<p>如果<code>pid</code>和 <code>pgid</code>相同，则由<code>pid</code>指定的进程将被设置为进程组首领；</p>
<p>如果<code>pid</code>为0，则表示设置当前进程的<code>PGID</code>为<code>pgid</code>；</p>
<p>如果<code>pgid</code>为0，则使用<code>pid</code>作为目标<code>PGID</code>。</p>
<p><code>setpgid</code>函数成功时返回0，失败则返回-1并设置<code>errno</code>.</p>
<p>一个进程只能设置<strong>自己</strong>或者<strong>其子进程</strong>的<code>PGID</code>。并且，当子进程调用<code>exec</code>系列函数后，我们也不能再在父进程中对它设置<code>PGID</code>。</p>
<span id="more"></span>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>一些有关联的进程组将形成一个会话(session)。下面的函数用于创建一个会话:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>该进程不能由<strong>进程组的首领</strong>进程进行调用，会报错。</p>
<p>对于非进程组首领的进程，调用该函数不仅创建新会话，还会：</p>
<ul>
<li>调用进程成为会话的首领，此时该进程是新会话的唯一成员。</li>
<li>新建一个进程组，其<code>PGID</code>就是调用进程的<code>PID</code>，调用进程成为该组的首领。</li>
<li>调用进程将失去终端</li>
</ul>
<p>该函数成功时返回新的进程组的<code>PGID</code>，失败则返回-1并设置<code>errno</code>。</p>
<p>Linux进程并未提供所谓<strong>会话ID (SID）</strong>的概念，但Linux系统认为它等于<strong>会话首领</strong>所在的<strong>进程组的PGID</strong>，并提供了如下函数来读取<code>SID</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用ps命令查看进程之间的关系"><a href="#使用ps命令查看进程之间的关系" class="headerlink" title="使用ps命令查看进程之间的关系"></a>使用ps命令查看进程之间的关系</h3><p>在终端输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -o pid,ppid,pgid,sid,comm | less</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220821164503929.png" alt="image-20220821164503929"></p>
<p>它们之间的关系如下图</p>
<p>从单独的进程角度看，zsh是ps和less的父进程</p>
<p>从组的角度看，zsh是一个组（组里面只有zsh，所以zsh是进程组首领），ps和less是一个组（ps是进程组首领）</p>
<p>从会话的角度看，会话里面有两个关联的进程组，其实zsh是会话的首领</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220821165830395.png" alt="image-20220821165830395"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>系统监测工具</title>
    <url>/2022/09/29/Linux/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="系统检测工具"><a href="#系统检测工具" class="headerlink" title="系统检测工具"></a>系统检测工具</h1><p>学习《Linux高性能服务器编程》第十七章多线程编程，里面介绍了各种Linux中提供给开发人员调试和测评的服务器程序，为了印象深刻一些，多动手多实践，所以记下这个笔记。</p>
<span id="more"></span>
<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p><code>tcpdump</code>是一款经典的网络抓包工具。<code>tcpdump</code>给使用者提供了大量的选项，用以过滤数据包或者定制输出格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	-n,使用IP地址表示主机，而不是主机名;使用数字表示端口号，而不是服务名称。</span><br><span class="line">-i,指定要监听的网卡接口。“-i any”表示抓取所有网卡接口上的数据包。</span><br><span class="line">-v,输出一个稍微详细的信息，例如，显示IP数据包中的TTL和TOS信息。</span><br><span class="line">-t,不打印时间戳。</span><br><span class="line">-e,显示以太网帧头部信息。</span><br><span class="line">-c,近抓取指定数量的数据包。</span><br><span class="line">-x,以十六进制数显示数据包的内容，但不显示包中以太网帧的头部信息。</span><br><span class="line">-X,与-x选项类似，不过还打印每个十六进制字节对应的ASCII字符。</span><br><span class="line">-XX,与-X相同，不过还打印以太网帧的头部信息。</span><br><span class="line">-s,设置抓包时的抓取长度。</span><br><span class="line">-S,以绝对值来显示TCP报文段的序号，而不是相对值。</span><br><span class="line">-w,以绝对值来显示TCP报文段的序号，而不是相对值。</span><br><span class="line">-r,从文件读取数据包信息并显示之。</span><br></pre></td></tr></table></figure>
<p>除了使用选项外，<code>tcpdump</code>还支持用表达式来进一步过滤数据包。<code>tcpdump</code>表达式的操作数分为3种：类型(type)、方向(dir)和协议(proto)</p>
<ul>
<li><p>类型，解释其后面紧跟着的参数的含义。<code>tcpdump</code>支持的类型包括host、net、port和portrange。它们分别指定主机名（或IP地址)，用CIDR方法表示的网络地址，端口号以及端口范围。比如，要抓取整个1.2.3.0/255.255.255.0网络上的数据包，可以使用如下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump net 1.2.3.0/24</span><br></pre></td></tr></table></figure>
</li>
<li><p>方向，src指定数据包的发送端，dst指定数据包的目的端。比如要抓取进人端口13579的数据包，可以使用如下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tecpdump dst port 13579 </span><br></pre></td></tr></table></figure>
</li>
<li><p>协议，指定目标协议。比如要抓取所有ICMP数据包，可以使用如下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump icmp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当然，我们还可以使用逻辑操作符来组织上述操作数以创建更复杂的表达式。<code>tcpdump</code>支持的逻辑操作符和编程语言中的逻辑操作符完全相同，包括and(或者&amp;&amp;)、or(或者ll)、not(或者!)。比如要抓取主机 ernest-laptop和所有非 Kongming20 的主机之间交换的IP数据包，可以使用如下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump ip host ernest-laptop and not Kongming20</span><br></pre></td></tr></table></figure>
<p>如果表达式比较复杂，那么我们可以使用括号将它们分组。不过在使用括号时，我们要么使用反斜杠“\”对它转义，要么用单引号“ ”将其括住，以避免它被shell所解释。比如要抓取来自主机10.0.2.4，目标端口是3389或22的数据包，可以使用如下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tepdump &#x27;src 10.o.2.4 and (dst port 3389 or 22) &#x27;</span><br></pre></td></tr></table></figure>
<p>此外，tcpdump还允许直接使用数据包中的部分协议字段的内容来过滤数据包。比如，仅抓取TCP同步报文段，可使用如下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump &#x27;tcp[13]&amp;2 != 0&#x27;</span><br></pre></td></tr></table></figure>
<p>这是因为TCP头部的第14个字节的第2个位正是同步标志。该命令也可以表示为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump &#x27;tcp[tcpflags] &amp; tcp-syn != 0 &#x27;</span><br></pre></td></tr></table></figure>
<p>最后，tcpdump的具体输出格式除了与选项有关外，还与协议有关。可以查询man手册进行学习。</p>
<h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><p><code>lsof</code>(list open file）是一个列出当前系统打开的文件描述符的工具。通过它我们可以了解感兴趣的进程打开了哪些文件描述符，或者我们感兴趣的文件描述符被哪些进程打开了。</p>
<p><code>lsof</code>命令常用的选项包括:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-i 显示socket文件描述符。</span><br><span class="line">lsof -i[46] [protocol] [@hostname|ipaddr] [:service|port]</span><br></pre></td></tr></table></figure>
<p>其中，4表示IPv4协议，6表示IPv6协议；protocol指定传输层协议，可以是TCP或者UDP ； hostname指定主机名；ipaddr指定主机的IP地址; service指定服务名；port指定端口号。比如，要显示所有连接到主机192.168.1.108的 ssh服务的socket文件描述符，可以使用命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsof -i@192.168.1.108:22</span><br></pre></td></tr></table></figure>
<p>如果-i选项后不指定任何参数，则<code>lsof</code>命令将显示所有socket文件描述符。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20221001174639842.png" alt="image-20221001174639842"></p>
<p>除此之外，还有其他参数，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-u 显示指定用户启动的所有进程打开的所有文件描述符。</span><br><span class="line">-c 显示指定的命令打开的所有文件描述符。比如要查看websrv程序打开了哪些文件描述符，可以使用如下命令:lsof -c websrv</span><br><span class="line">-p，显示指定进程打开的所有文件描述符。</span><br><span class="line">-t，仅显示打开了目标文件描述符的进程的PID。</span><br></pre></td></tr></table></figure>
<h2 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h2><p><code>nc</code> (netcat〉命令短小精干、功能强大，有着“瑞士军刀”的美誉。它主要被用来快速构建网络连接。我们可以让它以服务器方式运行，监听某个端口并接收客户连接，因此它可用来调试客户端程序。我们也可以使之以客户端方式运行，向服务器发起连接并收发数据，因此它可以用来调试服务器程序，此时它有点像telnet程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-i 设置数据包传送的时间间隔。</span><br><span class="line">-l 以服务器方式运行，监听指定的端口。nc命令默认以客户端方式运行。</span><br><span class="line">-k 重复接受并处理某个端口上的所有连接，必须与-l选项一起使用。</span><br><span class="line">-n 使用IP地址表示主机，而不是主机名﹔使用数字表示端口号，而不是服务名称。</span><br><span class="line">-p 当nc命令以客户端方式运行时，强制其使用指定的端口号。</span><br><span class="line">-s 设置本地主机发送出的数据包的IP地址。</span><br><span class="line">-C 将CR和LF两个字符作为行结束符。</span><br><span class="line">-U 使用UNIX本地域协议通信。</span><br><span class="line">-u 使用UDP协议。nc命令默认使用的传输层协议是TCP协议。</span><br><span class="line">-w 如果nc客户端在指定的时间内未检测到任何输入，则退出。</span><br><span class="line">-X 当nc客户端和代理服务器通信时，该选项指定它们之间使用的通信协议。目前nc支持的代理协议包括“4”(SOCKS v.4)，“5”(SOCKs v.5）和“connect”(HTTPS proxy)。nc 默认使用的代理协议是SOCKs v.5。</span><br><span class="line">-x 指定目标代理服务器的IP地址和端口号。比如，要从 Kongming20连接到ernest-laptop上的 squid代理服务器，并通过它来访问www.baidu.com 的 Web服务，可以使用如下命令: nc -x ernest-laptop：1080 -X connect www.baidu.com</span><br><span class="line">-z 扫描目标机器上的某个或某些服务是否开启（端口扫描)。比如，要扫描机器ernest-laptop上端口号在20 ～ 50之间的服务，可以使用如下命令:</span><br><span class="line">nc -z ernest-laptop 20-50</span><br></pre></td></tr></table></figure>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>netstat是一个功能很强大的网络信息统计工具。它可以打印本地网卡接口上的全部连接、路由表信息、网卡接口信息等。我们主要利用的是上述功能中的第一个，即显示TCP连接及其状态信息。毕竞，要获得路由表信息和网卡接口信息，我们可以使用输出内容更丰富的route和 ifconfig命令。</p>
<p>nctstat命令常用的选项包括:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-n 使用IP地址表示主机，而不是主机名;使用数字表示端口号，而不是服务名称。</span><br><span class="line">-a 显示结果中也包含监听socket。</span><br><span class="line">-t 仅显示TCP连接。</span><br><span class="line">-r 显示路由信息。</span><br><span class="line">-i 显示网卡接口的数据流量</span><br><span class="line">-c 每隔1s输出一次</span><br><span class="line">-o 显示socket定时器（比如保活定时器）的信息</span><br><span class="line">-p 显示socket所属的进程的PID和名字</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题美化</title>
    <url>/2021/05/22/%E5%85%B6%E4%BB%96/next%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Next主题美化"><a href="#Next主题美化" class="headerlink" title="Next主题美化"></a>Next主题美化</h1><p>最近使用hexo的next主题在github上搭建了一个博客，但是发现这个next主题并不完全是自己想要的，所以还需要美(zhe)化（ten）一下。主要折腾了三个方面：</p>
<ul>
<li>鼠标点击特效</li>
<li>个性化回到顶部</li>
<li>打字特效</li>
<li>上传文件中带有READ.md</li>
</ul>
<span id="more"></span>
<h2 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h2><p>添加鼠标点击礼花特效🎉，效果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/鼠标点击礼花特效.gif" alt="鼠标点击礼花特效"></p>
<p>在<code>themes\next\source\js\cursor\</code>目录下 创建<strong>fireworks.js</strong>，具体<strong>fireworks.js</strong>的内容可以点击👉<a href="https://github.com/bugcat9/hexo-theme-next/blob/master/source/js/cursor/fireworks.js">fireworks.js</a>进行查看(不展示因为实在是太长了)</p>
<p>然后在主题自定义布局文件<code>themes\next\layout\_custom\custom.swig</code>中添加以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;# 鼠标点击特效 #&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.<span class="property">cursor_effect</span> == <span class="string">&quot;fireworks&quot;</span> %&#125;</span><br><span class="line">  &lt;script <span class="keyword">async</span> src=<span class="string">&quot;/js/cursor/fireworks.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <strong>custom.swig</strong> 文件不存在，需要手动在<code>themes\next\layout\_custom</code>下创建并在<code>themes\next\layout\_layout.swig</code>布局页面中 <strong>body</strong> 末尾引入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> ...</span><br><span class="line"> &#123;%- if theme.pjax %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;pjax&quot;</span>&gt;</span></span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line">  &#123;% include &#x27;_third-party/math/index.swig&#x27; %&#125;</span><br><span class="line">  &#123;% include &#x27;_third-party/quicklink.swig&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;&#123;- next_inject(&#x27;bodyEnd&#x27;) &#125;&#125;</span><br><span class="line">  &#123;%- if theme.pjax %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line">  &#123;% include &#x27;_custom/custom.swig&#x27; %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>记住是在<strong>layout</strong>文件夹下创建对应的<strong>custom.swig</strong> 文件，别创建错了。</p>
<p>最后在主题配置文件<code>themes\next\_config.yml</code>中添加以下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mouse click effect: fireworks | explosion | love | text</span></span><br><span class="line"><span class="attr">cursor_effect:</span> <span class="string">fireworks</span></span><br></pre></td></tr></table></figure>
<p>当然点击特效还有其他的，可以参考：<a href="http://yearito.cn/posts/hexo-theme-beautify.html">http://yearito.cn/posts/hexo-theme-beautify.html</a></p>
<h2 id="个性化回到顶部"><a href="#个性化回到顶部" class="headerlink" title="个性化回到顶部"></a>个性化回到顶部</h2><p>个性化回到顶端是我自己比较喜欢的，也是从上面那个参考那里借鉴的（读书人的事，怎么能咳咳，扯远了），是一个小猫然后点击可以回到顶端，效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/个性化back2top.gif" alt="个性化back2top"></p>
<p>首先，下载该图片，点击👉<a href="https://github.com/bugcat9/hexo-theme-next/blob/master/source/images/scroll.png">小猫图片</a></p>
<p>然后在<code>themes\next\source\css\_common\components\back-to-top.styl</code>里面<strong>添加</strong>(不是覆盖)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//自定义回到顶部样式</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">900px</span>) &#123;</span><br><span class="line"><span class="selector-class">.back-to-top</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70px</span>;  //图片素材宽度</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">900px</span>;  //图片素材高度</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">900px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: unset;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">5s</span> ease-in-out;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;/images/scroll.png&quot;</span>);</span><br><span class="line">  <span class="attribute">position</span>: fixed</span><br><span class="line">  //隐藏箭头图标</span><br><span class="line">  &gt; i &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;<span class="selector-class">.back-to-top-on</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: unset;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100vh</span> &lt; (<span class="number">900px</span> + <span class="number">200px</span>) ? <span class="built_in">calc</span>( <span class="number">100vh</span> - <span class="number">900px</span> - <span class="number">200px</span> ) : <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>在主题配置文件<code>themes\next\_config.yml</code>中打开<strong>back2top</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="打字特效"><a href="#打字特效" class="headerlink" title="打字特效"></a>打字特效</h2><p>如果你开评论的话，可以考虑加入这个特效，感觉还挺炫酷。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/打字特效.gif" alt="打字特效"></p>
<p>首先，点击<a href="https://github.com/bugcat9/hexo-theme-next/blob/master/source/js/activate-power-mode.min.js">activate-power-mode.min.js</a>下载相应的脚本，并置于 <code>themes\next\source\js\</code> 目录下。</p>
<p>在主题自定义布局文件<code>themes\next\layout\_custom\custom.swig</code>中添加以下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;# 打字特效 #&#125;</span><br><span class="line">&#123;% if theme.typing_effect %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/activate-power-mode.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    POWERMODE.colorful = </span><span class="template-variable">&#123;&#123; <span class="name">theme.typing_effect.colorful</span> &#125;&#125;</span><span class="language-xml">;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    POWERMODE.shake = </span><span class="template-variable">&#123;&#123; <span class="name">theme.typing_effect.shake</span> &#125;&#125;</span><span class="language-xml">;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    document.body.addEventListener(&#x27;input&#x27;, POWERMODE);</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">  </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入,这个上面说过了，就不多说了。</p>
<p>在主题配置文件<code>themes\next\_config.yml</code>中添加以下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># typing effect</span></span><br><span class="line"><span class="attr">typing_effect:</span></span><br><span class="line">  <span class="attr">colorful:</span> <span class="literal">true</span>  <span class="comment"># 礼花特效</span></span><br><span class="line">  <span class="attr">shake:</span> <span class="literal">false</span>  <span class="comment"># 震动特效</span></span><br></pre></td></tr></table></figure>
<h2 id="上传文件中带有README-md"><a href="#上传文件中带有README-md" class="headerlink" title="上传文件中带有README.md"></a>上传文件中带有README.md</h2><p>我们知道hexo上传的文件当中只有css、js、html等文件，如果我们在根目录的source文件夹下添加README.md，又会变成html。这对于我这样的强迫症太难受。</p>
<p>解决方法是在根目录下(注意是根目录下，不是主题next目录下)的<strong>_config.yml</strong>的<code>skip_render</code>前面加上<code>README.md</code>，如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">README.md</span></span><br></pre></td></tr></table></figure>
<p>然后再使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>最终可以看到</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20210522214004389.png" alt="展示"></p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>next主题的优化就告辞段落，目前我的需求基本满足了，如果有大佬想了解更多更深度的，可以参考：<a href="http://yearito.cn/posts/hexo-theme-beautify.html">http://yearito.cn/posts/hexo-theme-beautify.html</a></p>
<p>不过他的这个有点中有一个问题，就是custom.styl不存在了，这个可以参考这个issue：</p>
<p><a href="https://github.com/theme-next/hexo-theme-next/issues/982">https://github.com/theme-next/hexo-theme-next/issues/982</a></p>
<p>目前感觉自己折腾了一年的博客，从hexo到直接存在github上再到jekyll，最后又回到hexo，真实生命不息折腾不止，博客选择就到此结束吧。</p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="http://yearito.cn/posts/hexo-theme-beautify.html">http://yearito.cn/posts/hexo-theme-beautify.html</a></li>
<li><a href="https://github.com/theme-next/hexo-theme-next/issues/982">https://github.com/theme-next/hexo-theme-next/issues/982</a></li>
<li><a href="https://www.zhihu.com/question/23934523">https://www.zhihu.com/question/23934523</a></li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>python使用opencv提取光流</title>
    <url>/2022/07/22/%E5%85%B6%E4%BB%96/python%E4%BD%BF%E7%94%A8opencv%E6%8F%90%E5%8F%96%E5%85%89%E6%B5%81/</url>
    <content><![CDATA[<h1 id="python使用opencv提取光流"><a href="#python使用opencv提取光流" class="headerlink" title="python使用opencv提取光流"></a>python使用opencv提取光流</h1><p>光流flow特征中包含了一个视频当中运动相关的信息，在视频动作定位当中光流特征使用的比较多，所以记录一下提取光流特征的方法。</p>
<p>使用的方法是TVL1方法，最终提取的光流图片还可以配合I3D模型进行特征的提取。光流的计算先需要将视频一帧一帧提取出来，然后再通过连续两帧之间的差异进行计算。</p>
<span id="more"></span>
<h2 id="提取帧"><a href="#提取帧" class="headerlink" title="提取帧"></a>提取帧</h2><p>提取视频的帧的算法如下：</p>
<p>其中<code>video_list.txt</code>中写的是视频的名字，也就是告诉程序需要将那些视频提取帧:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220726212052926.png" alt="image-20220726212052926"></p>
<p><code>videos</code>中存放视频，与<code>video_list.txt</code>中写的视频名字对应</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220726212224852.png" alt="image-20220726212224852"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">video_root = <span class="string">&#x27;video_list.txt&#x27;</span></span><br><span class="line">root = <span class="string">&#x27;videos&#x27;</span></span><br><span class="line">out_root = <span class="string">&#x27;frames&#x27;</span></span><br><span class="line">suffix = <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_image</span>(<span class="params">root, vid_name, num, image</span>):</span><br><span class="line">    file_name = os.path.join(root, vid_name, <span class="built_in">str</span>(num) + suffix)</span><br><span class="line">    <span class="comment"># print(file_name)</span></span><br><span class="line">    cv2.imwrite(file_name, image)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">vid_path, preffix</span>):</span><br><span class="line">    videoCapture = cv2.VideoCapture(vid_path)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        success, frame = videoCapture.read()</span><br><span class="line">        <span class="keyword">if</span> success:</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            save_image(out_root, preffix, i, frame)</span><br><span class="line">            <span class="comment"># print(&#x27;save image vid name: &#x27;, file_name, &#x27;; frame num: &#x27;, i)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(out_root):</span><br><span class="line">        os.mkdir(out_root)</span><br><span class="line">    <span class="comment"># path_list = os.listdir(root)</span></span><br><span class="line">    path_list = []</span><br><span class="line">    <span class="comment">#### 读取txt中视频信息 ####</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(video_root, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">id</span>, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f):</span><br><span class="line">            video_name = line.strip().split()</span><br><span class="line">            path_list.append(video_name[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    pool = multiprocessing.Pool(processes=<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> path_list:</span><br><span class="line">        path = os.path.join(root, file_name)</span><br><span class="line">        preffix = file_name.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        dir_name = os.path.join(out_root, preffix)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir_name):</span><br><span class="line">            os.mkdir(dir_name)</span><br><span class="line"></span><br><span class="line">        pool.apply_async(process, args=(path, preffix))</span><br><span class="line">        <span class="comment"># process(path,preffix)</span></span><br><span class="line"></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finish!!!!!!!!!!!!!!!!!!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行完这个程序就能将需要提取的视频帧放在<code>frames</code>对应的目录下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220726212537411.png" alt="image-20220726212537411"></p>
<h2 id="提取flow光流"><a href="#提取flow光流" class="headerlink" title="提取flow光流"></a>提取flow光流</h2><p>提取光流使用了opencv模块，主要通过上面提取的视频帧进行计算，光流计算使用cpu资源比较多，所以会计算很长时间。</p>
<p>光流提取的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment">###### 使用frames帧进行 flow光流计算</span></span><br><span class="line">video_root = <span class="string">&#x27;video_list.txt&#x27;</span></span><br><span class="line">root = <span class="string">&#x27;frames&#x27;</span></span><br><span class="line">out_root = <span class="string">&#x27;flow&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_for_frames</span>(<span class="params">video_path</span>):</span><br><span class="line">    <span class="comment"># print(video_path)</span></span><br><span class="line">    frames = glob.glob(os.path.join(video_path, <span class="string">&#x27;*.jpg&#x27;</span>))</span><br><span class="line">    frames.sort()</span><br><span class="line"></span><br><span class="line">    flow = []</span><br><span class="line">    prev = cv2.imread(frames[<span class="number">0</span>])</span><br><span class="line">    prev = cv2.cvtColor(prev, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="keyword">for</span> i, frame_curr <span class="keyword">in</span> <span class="built_in">enumerate</span>(frames[<span class="number">1</span>:]):</span><br><span class="line">        curr = cv2.imread(frame_curr)</span><br><span class="line">        curr = cv2.cvtColor(curr, cv2.COLOR_BGR2GRAY)</span><br><span class="line">        tmp_flow = compute_TVL1(prev, curr)</span><br><span class="line">        flow.append(tmp_flow)</span><br><span class="line">        prev = curr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_TVL1</span>(<span class="params">prev, curr, bound=<span class="number">15</span></span>):</span><br><span class="line">    TVL1 = cv2.optflow.DualTVL1OpticalFlow_create()</span><br><span class="line">    flow = TVL1.calc(prev, curr, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> flow.dtype == np.float32</span><br><span class="line"></span><br><span class="line">    flow = (flow + bound) * (<span class="number">255.0</span> / (<span class="number">2</span> * bound))</span><br><span class="line">    flow = np.<span class="built_in">round</span>(flow).astype(<span class="built_in">int</span>)</span><br><span class="line">    flow[flow &gt;= <span class="number">255</span>] = <span class="number">255</span></span><br><span class="line">    flow[flow &lt;= <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_flow</span>(<span class="params">video_flows, flow_path</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(flow_path):</span><br><span class="line">        os.mkdir(os.path.join(flow_path))</span><br><span class="line">    <span class="keyword">for</span> i, flow <span class="keyword">in</span> <span class="built_in">enumerate</span>(video_flows):</span><br><span class="line">        cv2.imwrite(os.path.join(flow_path, <span class="built_in">str</span>(i) + <span class="string">&#x27;_x.jpg&#x27;</span>), flow[:, :, <span class="number">0</span>])</span><br><span class="line">        cv2.imwrite(os.path.join(flow_path, <span class="built_in">str</span>(i) + <span class="string">&#x27;_y.jpg&#x27;</span>), flow[:, :, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">video_path, flow_path</span>):</span><br><span class="line">    flow = cal_for_frames(video_path)</span><br><span class="line">    save_flow(flow, flow_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_flow</span>(<span class="params">root, out_root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(out_root):</span><br><span class="line">        os.mkdir(out_root)</span><br><span class="line">    <span class="comment"># dir_list = os.listdir(root)</span></span><br><span class="line">    dir_list = []</span><br><span class="line">    <span class="comment">### 读取txt中视频信息</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(video_root, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">id</span>, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f):</span><br><span class="line">            video_name = line.strip().split()</span><br><span class="line">            preffix = video_name[<span class="number">0</span>].split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            dir_list.append(preffix)</span><br><span class="line"></span><br><span class="line">    pool = multiprocessing.Pool(processes=<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> dir_name <span class="keyword">in</span> dir_list:</span><br><span class="line">        video_path = os.path.join(root, dir_name)</span><br><span class="line">        flow_path = os.path.join(out_root, dir_name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># flow = cal_for_frames(video_path)</span></span><br><span class="line">        <span class="comment"># save_flow(flow,flow_path)</span></span><br><span class="line">        <span class="comment"># print(&#x27;save flow data: &#x27;,flow_path)</span></span><br><span class="line">        <span class="comment"># process(video_path,flow_path)</span></span><br><span class="line">        pool.apply_async(process, args=(video_path, flow_path))</span><br><span class="line"></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    extract_flow(root, out_root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finish!!!!!!!!!!!!!!!!!!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>提取光流时需要使用到<code>cv2.optflow.DualTVL1OpticalFlow_create()</code>，这玩意安装有时候会有版本问题，所以安装的opencv-python和pencv-contrib-python最好版本相同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install opencv-python==<span class="number">4.1</span><span class="number">.2</span><span class="number">.30</span></span><br><span class="line"> </span><br><span class="line">pip install opencv-contrib-python==<span class="number">4.1</span><span class="number">.2</span><span class="number">.30</span></span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>最终flow光流图和提取的帧之间如下图所示，可以看到一些梳头发的动作变化。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220726213330086.png" alt="image-20220726213330086"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记录一下光流特征提取的算法，方便自己之后进行使用。</p>
<p>代码仓库：<a href="https://github.com/bugcat9/pytorch-i3d">https://github.com/bugcat9/pytorch-i3d</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用github action实现自动化部署</title>
    <url>/2021/05/30/%E5%85%B6%E4%BB%96/hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="hexo使用github-action实现自动化部署"><a href="#hexo使用github-action实现自动化部署" class="headerlink" title="hexo使用github action实现自动化部署"></a>hexo使用github action实现自动化部署</h1><p>最近将hexo博客进行了美化，为了更“折腾”一点，决定实现一下hexo对应的自动化部署，毕竟网上的资料对应的也有不少，学习一下。</p>
<p>我自己的需求是</p>
<ul>
<li>将hexo、hexo生成的静态文件、博客源码都放在一起（个人感觉方便管理，免得创建许多仓库），然后hexo主要就在hexo分支上</li>
<li>在hexo分支上进行自动化，实现上传文件后自动部署。</li>
</ul>
<p>查看博客点击👉<a href="https://bugcat9.github.io/">https://bugcat9.github.io/</a></p>
<p>查看博客仓库点击👉<a href="https://github.com/bugcat9/bugcat9.github.io">https://github.com/bugcat9/bugcat9.github.io</a></p>
<span id="more"></span>
<p>在这里先说明一下我的项目的分支结构，我是将项目放到了<strong><a href="https://github.com/bugcat9/bugcat9.github.io">bugcat9.github.io</a></strong>下，下面有master、gh-pages、source、hexo四个分支</p>
<ul>
<li>master，啥也不干起说明作用</li>
<li>gh-pages，放hexo生成的静态文件</li>
<li>source，存放源文件</li>
<li>hexo，存放hexo文件，并部署了自动化</li>
</ul>
<h2 id="上传hexo项目文件"><a href="#上传hexo项目文件" class="headerlink" title="上传hexo项目文件"></a>上传hexo项目文件</h2><p>🤗<strong>如果会将hexo项目安全上传到github上的可以直接跳过这步了。</strong>感觉这步写的有点啰嗦</p>
<p>一般来说一个hexo项目如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20210530203146315.png" alt="image-20210530203146315"></p>
<p>本人上传的之前是先直接删除了下面几样东西：</p>
<ul>
<li><code>.github</code>文件夹，包括根目录和<code>themes</code>里面的</li>
<li>因为<code>themes</code>里面的主题有的是<code>git clone</code>来的,所以我也给删除了<code>.git</code>文件夹</li>
</ul>
<p>然后将剩下的文件，上传到新的仓库或者某个仓库的某个分支，我是给上传到了<strong><a href="https://github.com/bugcat9/bugcat9.github.io">bugcat9.github.io</a></strong>下的hexo分支</p>
<h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>因为需要将hexo项目生成的静态文件上传到github上（跟本地上传类似），所以需要生成密钥进行上传。</p>
<p>生成命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;Hexo Deploy Key&quot; -f github-deploy-key -N &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>在windows下可以通过<code>git bash</code>生成，相信在配置git的时候应该了解过</p>
<p><code>ssh-keygen</code>命令讲解可以看的➡<a href="https://www.linuxcool.com/ssh-keygen">https://www.linuxcool.com/ssh-keygen</a></p>
<p>这会在当前目录生成两个文件：</p>
<ul>
<li>github-deploy-key —— 私钥</li>
<li>github-deploy-key.pub —— 公钥</li>
</ul>
<h2 id="配置私钥"><a href="#配置私钥" class="headerlink" title="配置私钥"></a>配置私钥</h2><p>把<strong>私钥</strong>放在hexo项目的代码仓库当中的Secrets中，这是为了配置action的时候使用，在我这里就是<strong><a href="https://github.com/bugcat9/bugcat9.github.io">bugcat9.github.io</a></strong>项目(hexo分支)</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20210530211649771.png" alt="image-20210530211649771"></p>
<p>依次点击<code>Setting</code>、<code>Secrets</code>、<code>New repository secret</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20210530211935519.png" alt="image-20210530211935519"></p>
<p>输入名字HEXO_DEPLOY_KEY，以及对应的内容，然后就可以生成Repository secrets了</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20210530212045237.png" alt="image-20210530212045237"></p>
<h2 id="配置公钥"><a href="#配置公钥" class="headerlink" title="配置公钥"></a>配置公钥</h2><p>把公钥放在需要上传静态文件的项目中，在我这里也是<strong><a href="https://github.com/bugcat9/bugcat9.github.io">bugcat9.github.io</a></strong>项目(gh-pages分支)</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20210530212318098.png" alt="image-20210530212318098"></p>
<p>依次点击<code>Setting</code>、<code>Deploy keys</code>、<code>add deploy key</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20210530212539068.png" alt="image-20210530212539068"></p>
<p>输入名字HEXO_DEPLOY_PUB ，以及对应的内容，然后记得勾选<code>Allow write access</code>,然后点击<code>Add key</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20210530212652197.png" alt="image-20210530212652197"></p>
<h2 id="配置其他内容"><a href="#配置其他内容" class="headerlink" title="配置其他内容"></a>配置其他内容</h2><p>在我这里面要配置<code>gitalk</code>的CLIENT_ID和CLIENT_SECRET的值，配置方法和配置私钥是一样的</p>
<p>CLIENT_ID：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20210531230828953.png" alt="image-20210531230828953"></p>
<p>CLIENT_SECRET：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20210531230912586.png" alt="image-20210531230912586"></p>
<p>最终</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20210531231008588.png" alt="image-20210531231008588"></p>
<h2 id="创建-Workflow"><a href="#创建-Workflow" class="headerlink" title="创建 Workflow"></a>创建 Workflow</h2><p>在 Hexo 的仓库或者hexo中创建一个新文件：<code>.github/workflows/deploy.yml</code>，文件名可以自己取，但是一定要放在 <code>.github/workflows</code> 目录中，文件的内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span></span><br><span class="line"><span class="comment"># 要触发的分支</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">if:</span> <span class="string">github.event.repository.owner.id</span> <span class="string">==</span> <span class="string">github.event.sender.id</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">        <span class="comment"># 设置对应的分支，本文这里是hexo分支</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">hexo</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;12&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 700 ~/.ssh</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          ## 设置自己邮箱和github用户名</span></span><br><span class="line"><span class="string">          git config --global user.email &quot;1767508581@qq.com&quot;</span></span><br><span class="line"><span class="string">          git config --global user.name &quot;bugcat9&quot;</span></span><br><span class="line"><span class="string">          npm install hexo-cli -g</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string"></span>      <span class="comment">### 设置gitalk,不需要可以删除掉</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">gitalk</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">CLIENT_ID:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.CLIENT_ID</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">CLIENT_SECRET:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.CLIENT_SECRET&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          sed -i &#x27;639s/123/$CLIENT_ID/&#x27; ./themes/next/_config.yml</span></span><br><span class="line"><span class="string">          sed -i &#x27;640s/123/$CLIENT_SECRET/&#x27; ./themes/next/_config.yml</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo deploy</span></span><br></pre></td></tr></table></figure>
<p> 简单来说，就是上传文件到hexo的时候，他会触发这个Workflow，然后构建ubuntu最新的环境，接着构建nodejs环境、git环境、hexo环境，再设置gitalk，最后再运行<code>hexo clean</code>、<code>hexo deploy</code>进行上传</p>
<p>但是这里存在一个问题如果我们hexo分支不在default分支，默认是触发不了的Workflow的，需要将hexo切换成default分支才能触发。切换的方法是</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20210601104734139.png" alt="image-20210601104734139"></p>
<p>然后就可以通过上传进行触发了。</p>
<p>后续的话，将master切换回default也是可以触发的。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>配置自动化部署其实不是很难，就是刚刚接触github action啥都不懂耽误了很久，在这小结一下，方便自己日后换电脑的时候使用。</p>
<p><strong>参考：</strong><a href="https://zhuanlan.zhihu.com/p/170563000">https://zhuanlan.zhihu.com/p/170563000</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>github action</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Github Action实现Android自动打包</title>
    <url>/2021/09/23/%E5%85%B6%E4%BB%96/%E4%BD%BF%E7%94%A8Github%20Action%E5%AE%9E%E7%8E%B0Android%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="使用Github-Action实现Android自动打包"><a href="#使用Github-Action实现Android自动打包" class="headerlink" title="使用Github Action实现Android自动打包"></a>使用Github Action实现Android自动打包</h1><p>Github Action是个好东西，我使用他实现了hexo自动打包上传，然后我就在想能否使用Github Action打包写好的Android代码，打包好Android的包apk，经过我在网上查找资料发现这个功能是完全可以实现的</p>
<span id="more"></span>
<h2 id="Android命令行打包"><a href="#Android命令行打包" class="headerlink" title="Android命令行打包"></a>Android命令行打包</h2><p>Android 命令行打包可以参考官方文档<a href="https://developer.android.com/studio/build/building-cmdline?hl=zh-cn#sign_cmdline">https://developer.android.com/studio/build/building-cmdline?hl=zh-cn#sign_cmdline</a></p>
<p>想在Github Action上进行打包，首先要明白如何在本地使用命令行进行打包，这样才能在在Github Action，配置对应的环境然后使用对应的命令进行打包。</p>
<p>因为我们是想要打包那种有签名的apk文件，所以得使用jks文件，现在Android打包签名使用的是jks文件。</p>
<p>首先我们需要生成jks文件，我们可以使用Android Studio进行生成</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210927194715475.png" alt="image-20210927194715475"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210923114803611.png" alt="image-20210923114803611"></p>
<p>接着为了方便，在项目的根目录下创建一个名为 <code>keystore.properties</code> 的文件。此文件应当包含签名信息，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">storePassword</span>=<span class="string">myStorePassword</span></span><br><span class="line"><span class="attr">keyPassword</span>=<span class="string">mykeyPassword</span></span><br><span class="line"><span class="attr">keyAlias</span>=<span class="string">myKeyAlias</span></span><br><span class="line"><span class="attr">storeFile</span>=<span class="string">myStoreFileLocation</span></span><br></pre></td></tr></table></figure>
<p>在模块的 <code>build.gradle</code> 文件中，在 <code>android &#123;&#125;</code> 块的前面添加用于加载 <code>keystore.properties</code> 文件的代码。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a variable called keystorePropertiesFile, and initialize it to your</span></span><br><span class="line"><span class="comment">// keystore.properties file, in the rootProject folder.</span></span><br><span class="line"><span class="keyword">def</span> keystorePropertiesFile = rootProject.file(<span class="string">&quot;keystore.properties&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize a new Properties() object called keystoreProperties.</span></span><br><span class="line"><span class="keyword">def</span> keystoreProperties = <span class="keyword">new</span> Properties()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load your keystore.properties file into the keystoreProperties object.</span></span><br><span class="line">keystoreProperties.load(<span class="keyword">new</span> FileInputStream(keystorePropertiesFile))</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改模块的 <code>build.gradle</code> 文件的 <code>signingConfigs</code> 块，以便使用此语法引用存储在 <code>keystoreProperties</code> 中的签名信息。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        config &#123;</span><br><span class="line">            keyAlias keystoreProperties[<span class="string">&#x27;keyAlias&#x27;</span>]</span><br><span class="line">            keyPassword keystoreProperties[<span class="string">&#x27;keyPassword&#x27;</span>]</span><br><span class="line">            storeFile file(keystoreProperties[<span class="string">&#x27;storeFile&#x27;</span>])</span><br><span class="line">            storePassword keystoreProperties[<span class="string">&#x27;storePassword&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            signingConfig signingConfigs.config <span class="comment">//配置签名文件</span></span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在命令行中输入命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">gradlew assembleRelease</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210927203126908.png" alt="image-20210927203126908"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210927203156145.png" alt="image-20210927203156145"></p>
<p>可以看到最终生成的release版的apk文件，说明Android命令行打包成功</p>
<h2 id="使用GitHub-Action打包"><a href="#使用GitHub-Action打包" class="headerlink" title="使用GitHub Action打包"></a>使用GitHub Action打包</h2><p>我们在项目根目录下创建.github/workflows/build_apk.yml这样的文件，它是GitHub Action的配置文件</p>
<p>需要在GitHub Action上配置环境，可以看下面的配置这样可以打包出apk</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="comment"># 设置jdk环境为1.8</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">1.8</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-java@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">java-version:</span> <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 打包release</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Gradle</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">bash</span> <span class="string">./gradlew</span> <span class="string">assembleRelease</span></span><br></pre></td></tr></table></figure>
<p>打包出apk后我们需要把apk进行上传，下面的方法是进行上传，上传之后可以在GitHub Action上看到</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#step：上传apk 到action，在右上角查看</span></span><br><span class="line"><span class="comment"># 官方文档 https://help.github.com/cn/actions/automating-your-workflow-with-github-actions/persisting-workflow-data-using-artifacts#uploading-build-and-test-artifacts</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">APK</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v2</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">app/build/outputs/apk/release/app-release.apk</span></span><br></pre></td></tr></table></figure>
<p>上传的结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210927204736195.png" alt="image-20210927204736195"></p>
<p>但是光在这里上传并不会进行release发布，所以我们接着加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建realease</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">Release</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">create_release</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/create-release@v1</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">tag_name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.ref</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">release_name:</span> <span class="string">Release</span> <span class="string">$&#123;&#123;</span> <span class="string">github.ref</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">draft:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">prerelease:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 上传apk到release</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">Release</span> <span class="string">Asset</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">upload-release-asset</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/upload-release-asset@v1</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="comment"># This pulls from the CREATE RELEASE step above, referencing it&#x27;s ID to get its outputs object, which include a `upload_url`.</span></span><br><span class="line">    <span class="comment"># See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps</span></span><br><span class="line">    <span class="attr">upload_url:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.create_release.outputs.upload_url</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">asset_path:</span> <span class="string">app/build/outputs/apk/release/app-release.apk</span></span><br><span class="line">    <span class="attr">asset_name:</span> <span class="string">App.apk</span></span><br><span class="line">    <span class="attr">asset_content_type:</span> <span class="string">application/vnd.android.package-archiv</span></span><br></pre></td></tr></table></figure>
<p>这个是上传到release上，但是这个按照教程似乎只能使用tag进行，因为这样<code>github.ref</code>才有意义</p>
<p>可以看到我们上传一个tag之后，最终效果是这样的</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210927205713787.png" alt="image-20210927205713787"></p>
<h2 id="使用secret"><a href="#使用secret" class="headerlink" title="使用secret"></a>使用secret</h2><p>上面这样做只能使用私人仓库，因为在<code>keystore.properties</code>里面写着密码和别名，如果开源别人就能下载然后用这个jks打包，这肯定不好，所以我们使用secret，在配置环境的时候使用sed更改密码。</p>
<p>在仓库的setting中我们加入<code>ALIAS</code>和<code>PASSWORD</code>两个secret，其中就是jks的别名和密码(这里我将storePassword和keyPassword设置的一样，所以只有一个密码)</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210929170814946.png" alt="image-20210929170814946"></p>
<p>更改<code>keystore.properties</code>为</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">storePassword</span>=<span class="string">123</span></span><br><span class="line"><span class="attr">keyPassword</span>=<span class="string">123</span></span><br><span class="line"><span class="attr">keyAlias</span>=<span class="string">123</span></span><br><span class="line"><span class="attr">storeFile</span>=<span class="string">../App.jks</span></span><br></pre></td></tr></table></figure>
<p>更改打包命令</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="comment"># 设置jdk环境为1.8</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">1.8</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-java@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">java-version:</span> <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 打包release</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Gradle</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ALIAS:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIAS</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          sed -i &quot;1s/123/$PASSWORD/&quot; keystore.properties</span></span><br><span class="line"><span class="string">          sed -i &quot;2s/123/$PASSWORD/&quot; keystore.properties</span></span><br><span class="line"><span class="string">          sed -i &quot;3s/123/$ALIAS/&quot; keystore.properties</span></span><br><span class="line"><span class="string">          bash ./gradlew assembleRelease</span></span><br></pre></td></tr></table></figure>
<p>这里我们使用了sed命令更改了<code>keystore.properties</code>中的数据，这样就不会泄露秘密和别名，也就达到了安全的目的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后的配置文件是这样的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Android</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发器</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="comment"># 设置jdk环境为1.8</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">1.8</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-java@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">java-version:</span> <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 打包release</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Gradle</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ALIAS:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIAS</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          sed -i &quot;1s/123/$PASSWORD/&quot; keystore.properties</span></span><br><span class="line"><span class="string">          sed -i &quot;2s/123/$PASSWORD/&quot; keystore.properties</span></span><br><span class="line"><span class="string">          sed -i &quot;3s/123/$ALIAS/&quot; keystore.properties</span></span><br><span class="line"><span class="string">          bash ./gradlew assembleRelease</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="comment">#step：上传apk 到action，在右上角查看</span></span><br><span class="line">      <span class="comment"># 官方文档 https://help.github.com/cn/actions/automating-your-workflow-with-github-actions/persisting-workflow-data-using-artifacts#uploading-build-and-test-artifacts</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">APK</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">app/build/outputs/apk/release/app-release.apk</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 创建realease</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">Release</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">create_release</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/create-release@v1</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">tag_name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.ref</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">release_name:</span> <span class="string">Release</span> <span class="string">$&#123;&#123;</span> <span class="string">github.ref</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">draft:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">prerelease:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># 上传apk到release</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">Release</span> <span class="string">Asset</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">upload-release-asset</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/upload-release-asset@v1</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># This pulls from the CREATE RELEASE step above, referencing it&#x27;s ID to get its outputs object, which include a `upload_url`.</span></span><br><span class="line">          <span class="comment"># See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps</span></span><br><span class="line">          <span class="attr">upload_url:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.create_release.outputs.upload_url</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">asset_path:</span> <span class="string">app/build/outputs/apk/release/app-release.apk</span></span><br><span class="line">          <span class="attr">asset_name:</span> <span class="string">App.apk</span></span><br><span class="line">          <span class="attr">asset_content_type:</span> <span class="string">application/vnd.android.package-archiv</span></span><br></pre></td></tr></table></figure>
<p>使用github Action进行打包发布就写到这里。</p>
<p>参考：</p>
<ul>
<li><a href="https://developer.android.google.cn/studio/build/building-cmdline?hl=ru#ReleaseMode">https://developer.android.google.cn/studio/build/building-cmdline?hl=ru#ReleaseMode</a></li>
<li><a href="https://blog.csdn.net/ZZL23333/article/details/115798615">https://blog.csdn.net/ZZL23333/article/details/115798615</a></li>
<li><a href="https://xuexuan.blog.csdn.net/article/details/103921480?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control">https://xuexuan.blog.csdn.net/article/details/103921480?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control</a></li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>github action</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑上玩GBA游戏</title>
    <url>/2022/08/26/%E5%85%B6%E4%BB%96/%E7%94%B5%E8%84%91%E4%B8%8A%E7%8E%A9GBA%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="电脑上玩GBA游戏（GBA模拟器）"><a href="#电脑上玩GBA游戏（GBA模拟器）" class="headerlink" title="电脑上玩GBA游戏（GBA模拟器）"></a>电脑上玩GBA游戏（GBA模拟器）</h1><p>最近重温了神奇宝贝系列的动画，想到小时候在GBA上玩的口袋妖怪系列游戏，想在电脑上重新玩一下，所以记录一下几个开源的GBA游戏模拟器。</p>
<h2 id="visualboyadvance-m"><a href="#visualboyadvance-m" class="headerlink" title="visualboyadvance-m"></a>visualboyadvance-m</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>仓库地址：<a href="https://github.com/visualboyadvance-m/visualboyadvance-m">https://github.com/visualboyadvance-m/visualboyadvance-m</a></p>
<p>直接去release里面下载</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220831230708171.png" alt="image-20220831230708171"></p>
<p>visualboyadvance-m-Win-64bit.zip是打包好的模拟器。</p>
<p>translations.zip是翻译文件，因为原版是英文的，我们想用中文就得下载这个</p>
<span id="more"></span>
<h3 id="配置中文"><a href="#配置中文" class="headerlink" title="配置中文"></a>配置中文</h3><p>将visualboyadvance-m-Win-64bit.zip和translations.zip都解压一下到各自的文件夹。解压之后<code>visualboyadvance-m-Win-64bit</code>文件夹下只有一个exe文件，直接运行是以英文的环境打开。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220901224146745.png" alt="image-20220901224146745"></p>
<p>所以需要配置一下中文，方便我们进行使用。我们从解压的<code>translations</code>文件夹中找到<code>zh_CN</code>文件夹</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220901224620622.png" alt="image-20220901224620622"></p>
<p>将<code>zh_CN</code>复制到<code>visualboyadvance-m.exe</code>的同级目录，然后打开就是中文的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220901224945457.png" alt="image-20220901224945457"></p>
<h3 id="打开游戏"><a href="#打开游戏" class="headerlink" title="打开游戏"></a>打开游戏</h3><p>选择“文件”-&gt;“open”</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220901231117574.png" alt="image-20220901231117574"></p>
<p>然后找到自己下载游戏资源的文件夹打开对应的文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220901231641236.png" alt="image-20220901231641236"></p>
<p>就可以快乐的玩耍了</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220903222532385.png" alt="image-20220903222532385"></p>
<p>vba可以通过<code>ctrl+G</code>快捷键实现调整滤镜，让之前像素级别的游戏画质清晰一些。</p>
<h3 id="联机"><a href="#联机" class="headerlink" title="联机"></a>联机</h3><p>vba有个令我没有想到的功能那就是联机，对你没看错这玩意还可以实现联机，也就是小时gba通过数据线连接，然后进行联机的那种功能。</p>
<p>不过这个功能似乎只能在局域网下实现，在这里我们在一台电脑上来展示这个功能。</p>
<p>首先需要把“非激活状态时暂停”这个勾选去掉，防止鼠标移出去就暂停。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220913183841775.png" alt="image-20220913183841775"></p>
<p>然后我们打开两个vba模拟器</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220913184458847.png" alt="image-20220913184458847"></p>
<p>我们打开每个模拟器的“选项”-&gt;”连接”-&gt;“开始网络连接”</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220913184959007.png" alt="image-20220913184959007"></p>
<p>会弹出如下的两个框框，我们选择一个做服务器一个做客户端，玩家选择2因为我们是两个玩家一起玩，最多4个玩家一起玩。</p>
<p>客户端中填写的服务器:127.0.0.1代表本地的地址，如果你们是局域网内可以填写服务器所在电脑的地址。</p>
<p>然后我们点击连接就可以开始联机玩耍了，尤其是星之卡比联机玩才最好玩。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220913185058478.png" alt="image-20220913185058478"></p>
<h2 id="mgba"><a href="#mgba" class="headerlink" title="mgba"></a>mgba</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p>仓库地址：<a href="https://github.com/mgba-emu/mgba">https://github.com/mgba-emu/mgba</a></p>
<p>直接去release里面下载</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220913190538794.png" alt="image-20220913190538794"></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>直接双击mGBA.exe即可。打开游戏的方式和上面的vba相同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220913190838019.png" alt="image-20220913190838019"></p>
<h3 id="调整滤镜"><a href="#调整滤镜" class="headerlink" title="调整滤镜"></a>调整滤镜</h3><p>由于画质问题有时候需要调整滤镜，但是mGBA中我目前没有找到快捷键，只能通过打开设置，然后载如新的着色器进行实现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220913191205304.png" alt="image-20220913191205304"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20220913191400752.png" alt="image-20220913191400752"></p>
]]></content>
      <categories>
        <category>GBA游戏</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>第15讲：SCRUM敏捷软件模型开发过程</title>
    <url>/2021/05/20/%E5%85%B6%E4%BB%96/%E7%AC%AC15%E8%AE%B2%EF%BC%9ASCRUM%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>重点：</p>
<p>（1）回顾和思考CMMI模型的核心思想是什么？这一模型有什么特点？适合什么样的企业和项目？<br>（2）了解学界所说的“重”过程的“重”是什么意思？ 与之相对应的“轻”过程的轻又是什么意思？<br>（3）了解敏捷软件开发过程的指导思想，了解SCRUM的基本框架。<br>（4）理解SCRUM敏捷开发模型的”三个角色“、”三个工件“、”四</p>
<p>个会议“的内容和方法。</p>
</blockquote>
<span id="more"></span>
<h2 id="一、简介："><a href="#一、简介：" class="headerlink" title="一、简介："></a>一、简介：</h2><p>思想：一切为了简单、快捷</p>
<p>简介：</p>
<p>Scrum：一种迭代开发框架，是一个轻量级的项目管理的框架。它的核心在于迭代。</p>
<ol>
<li>三个角色：产品经理、项目经理、开发团队</li>
<li>三个工件：产品订单、冲刺订单、燃尽图</li>
<li>四个会议：每日站立会、冲刺计划会、冲刺评审会、冲刺回顾会</li>
</ol>
<p>Scrum包括：1)预定义的角色；2)实践活动；3) 文档</p>
<p>Scrum角色：</p>
<ul>
<li>Scrum Master</li>
<li>产品负责人</li>
<li>开发团队</li>
</ul>
<p>Scrum 实践活动：</p>
<ul>
<li>冲刺：2到6周</li>
<li>冲刺计划会：确定做什么</li>
<li>站立会议：及时反馈</li>
</ul>
<h2 id="二、相关概念"><a href="#二、相关概念" class="headerlink" title="二、相关概念"></a>二、相关概念</h2><div class="table-container">
<table>
<thead>
<tr>
<th>名词</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sprint</td>
<td>冲刺周期，一般为2到6周时间</td>
</tr>
<tr>
<td>Sprint Planning Meeting</td>
<td>冲刺计划会</td>
</tr>
<tr>
<td>Sprint summary</td>
<td>冲刺回顾会</td>
</tr>
<tr>
<td>User Story</td>
<td>用户的外在业务需求，如查询余额。也就是小目标</td>
</tr>
<tr>
<td>Task</td>
<td>由User Story拆分成的具体开发任务</td>
</tr>
<tr>
<td>Backlog</td>
<td>需求列表，可以看成小目标的清单。分为<strong>Sprint Backlog</strong>和<strong>Product Backlog</strong></td>
</tr>
<tr>
<td>Product Backlog</td>
<td>产品 订单</td>
</tr>
<tr>
<td>Sprint Backlog</td>
<td>冲刺订单</td>
</tr>
<tr>
<td>Daily meeting</td>
<td>每天的站会，用于监控项目进度</td>
</tr>
<tr>
<td>Sprint Review meeting</td>
<td>冲刺评审会议，让团队成员演示成果</td>
</tr>
<tr>
<td>Sprint burn down</td>
<td>冲刺燃尽图，说白了就是记录当前周期的需求完成情况</td>
</tr>
<tr>
<td>Rlease</td>
<td>开发周期完成，项目发布新的可用版本</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/敏捷开发/敏捷开发1.png" alt="敏捷开发1"></p>
<h2 id="三、Scrum-Team"><a href="#三、Scrum-Team" class="headerlink" title="三、Scrum Team"></a>三、Scrum Team</h2><p>Scrum团队由所有对最终发布的产品做出贡献的人组成</p>
<p>“SCRUM Master”角色：相当于项目经理,维护过程和任务</p>
<p>团队包括：</p>
<ul>
<li>Scrum主管(Scrum Master)</li>
<li>产品负责人(Product Owner)，代表利益所有者</li>
<li>开发人员 (Developer)</li>
<li>测试人员(Tester)</li>
<li>文档工程师(Documentation Member)</li>
<li>……</li>
</ul>
<p>其中开发人员、测试人员、文档工程师属于开发团队。经典团队拥有5~9人，团队成员有较好的自我组织和管理。</p>
<h3 id="1-Scrum主管"><a href="#1-Scrum主管" class="headerlink" title="1.Scrum主管"></a>1.Scrum主管</h3><p>Scrum主管在实际项目中称为项目经理，主要工作：去除那些影响团队交付冲刺目标的障碍。Scrum主管并非团队的领导（由于他们是自我组织的），而是负责屏蔽外界对开发团队的干扰。Scrum主管确保Scrum过程按照初衷使用。Scrum主管是规则的执行者。</p>
<h3 id="2-产品负责人"><a href="#2-产品负责人" class="headerlink" title="2.产品负责人"></a>2.产品负责人</h3><p>产品负责人又称产品经理，代表客户的意愿，保证Scrum团队在做从业务角度来说正确的事情。</p>
<p>产品负责人的工作：</p>
<ul>
<li>编写用户故事</li>
<li>排出优先级</li>
<li>形成产品订单</li>
</ul>
<h3 id="3-开发团队"><a href="#3-开发团队" class="headerlink" title="3.开发团队"></a>3.开发团队</h3><p>开发团队是负责开发并交付产品的团队。团队规模要小，组成大致为5至9名具有跨职能技能的人（设计者，开发者等）,实践中，2~9人均可，但超过7人会导致沟通成本上升，最好团队成员技能水平大致相同。</p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/敏捷开发/敏捷开发2.png" alt="敏捷开发2"></p>
<h3 id="4-参与者"><a href="#4-参与者" class="headerlink" title="4.参与者"></a>4.参与者</h3><p>参与者包括用户和利益相关者，他们并不是实际Scrum过程的一部分，但是必须考虑他们。利益所有者（客户，提供商）是影响项目成功的人，但只直接参与冲刺评审过程。</p>
<h2 id="四、Scrum-活动"><a href="#四、Scrum-活动" class="headerlink" title="四、Scrum 活动"></a>四、Scrum 活动</h2><h3 id="1-Sprints"><a href="#1-Sprints" class="headerlink" title="1.Sprints"></a>1.Sprints</h3><p>Scrum项目周期以一组迭代周期“sprints”组成。典型的迭代周期为2~4周或者最多一个自然月，产品的设计、开发、测试全部都在一个迭代内完成。</p>
<h3 id="2-Sprint-Planning-Meeting-（冲刺计划会）"><a href="#2-Sprint-Planning-Meeting-（冲刺计划会）" class="headerlink" title="2.Sprint Planning Meeting （冲刺计划会）"></a>2.Sprint Planning Meeting （冲刺计划会）</h3><p>冲刺计划会主要是确定冲刺目标，简单程数这个迭代将要完成什么</p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/敏捷开发/敏捷开发3.png" alt="敏捷开发3" style="zoom:80%;" /></p>
<h3 id="3-Daily-Stand-Meeting"><a href="#3-Daily-Stand-Meeting" class="headerlink" title="3.Daily Stand Meeting"></a>3.Daily Stand Meeting</h3><p>每天站立会议是一个每天都会开的，时间为15分钟左右的会议，特点是所有人都站着开会。其中所有相关的人都会被邀请，但是只有Scrum master，Product Owner，团队成员能够在会上发言，这样避免了无关的讨论，可以提高效率。</p>
<p>其中团队成员需要回答3个问题：</p>
<ul>
<li>昨天你做了什么</li>
<li>今天你将要做什么</li>
<li>你有需要帮助的地方吗</li>
</ul>
<h3 id="4-冲刺评审会"><a href="#4-冲刺评审会" class="headerlink" title="4.冲刺评审会"></a>4.冲刺评审会</h3><p>在冲刺评审会上，团队需要演示所完成的迭代工作，典型的做法是使用演示形式展示新功能或者底层架构实现，整个团队和关注产品的人都要需要参加。</p>
<h3 id="5-冲刺回顾会"><a href="#5-冲刺回顾会" class="headerlink" title="5.冲刺回顾会"></a>5.冲刺回顾会</h3><p>周期性 回顾，总结工作中的禁言和教训，时间大概为15到30分钟左右。在每个迭代结束时开始做，整个团队都需要参加，包括客户也可能需要参加。</p>
<h2 id="五、Scrum-的文档-工件"><a href="#五、Scrum-的文档-工件" class="headerlink" title="五、Scrum 的文档 (工件)"></a>五、<strong>Scrum</strong> <strong>的文档</strong> (工件)</h2><h3 id="1-product-backlog-（产品订单"><a href="#1-product-backlog-（产品订单" class="headerlink" title="1.product backlog （产品订单)"></a>1.product backlog （产品订单)</h3><p>产品订单写的是项目中待完成的工作列表，理想的是每一个待完成的工作都将对客户和用户产生价值，产品所有者将对这个列表进行优先级排序，每个迭代开始前优先级的排序工作还需要再度修正。</p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/敏捷开发/敏捷开发4.png" alt="敏捷开发4" style="zoom:80%;" /></p>
<h3 id="2-Sprint-backlog-冲刺订单"><a href="#2-Sprint-backlog-冲刺订单" class="headerlink" title="2.Sprint backlog (冲刺订单)"></a>2.Sprint backlog (冲刺订单)</h3><p>Sprint Backlog是Product Backlog的子集，Sprint Backlog的内容，由团队成员集体决定，团队中任何人都可以添加，删减或者更改迭代中的工作项目，团队中的每个人都为了冲刺目标以及将发布的结果而工作。</p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/敏捷开发/敏捷开发5.png" alt="敏捷开发5" style="zoom:80%;" /></p>
<h2 id="六、Scrum过程"><a href="#六、Scrum过程" class="headerlink" title="六、Scrum过程"></a>六、Scrum过程</h2><p>待续……</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>敏捷的最佳实践之一就是迭代开发，敏捷/迭代开发的核心思想是：聚集客户价值，以客户为中心，交付刚刚好的系统，随时构建产品质量。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑推荐软件</title>
    <url>/2022/10/26/%E5%85%B6%E4%BB%96/%E7%94%B5%E8%84%91%E6%8E%A8%E8%8D%90%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="电脑推荐软件"><a href="#电脑推荐软件" class="headerlink" title="电脑推荐软件"></a>电脑推荐软件</h1><p>记录一下电脑上使用的频率比较高的软件</p>
<h2 id="1-Snipaste"><a href="#1-Snipaste" class="headerlink" title="1.Snipaste"></a>1.Snipaste</h2><p>超级好用的截图软件，按下F1就可以截图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/339716.gif" alt="img"></p>
<p>下载地址：<a href="https://zh.snipaste.com/">https://zh.snipaste.com/</a></p>
<span id="more"></span>
<h2 id="2-Typora"><a href="#2-Typora" class="headerlink" title="2.Typora"></a>2.Typora</h2><p>Typora是个非常好用的markdown编辑器和阅读器，美中不足的是开始收费了，但是个人感觉免费版本已经足够使用了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/others/image-20221108194746752.png" alt="image-20221108194746752"></p>
<p>目前最后一个免费版本在网上都需要找一下，我是使用自己在百度网盘保留的版本</p>
<h2 id="3-FastGithub"><a href="#3-FastGithub" class="headerlink" title="3.FastGithub"></a>3.FastGithub</h2><p>这个是一个github加速器，解决github打不开、用户头像无法加载、releases无法上传下载、git-clone、git-pull、git-push失败等问题。</p>
<p>虽然科学上网可以解决上面的github的访问问题，但是有的时候git pull等问题通过科学上网还是没用办法解决。这个软件刚刚好解决我的这个问题。</p>
<p>下载地址：<a href="https://github.com/dotnetcore/FastGithub/releases">https://github.com/dotnetcore/FastGithub/releases</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib画图(二)各种类型图</title>
    <url>/2021/07/23/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/matplotlib%E7%94%BB%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="matplotlib画图（二）"><a href="#matplotlib画图（二）" class="headerlink" title="matplotlib画图（二）"></a>matplotlib画图（二）</h1><p>matplotlib是最流行的Python底层绘图库，主要做数据可视化图表,名字取材于MATLAB，模仿MATLAB进行构建。</p>
<p>👉官网地址：<a href="https://matplotlib.org/">https://matplotlib.org/</a></p>
<p>matplotlib能画的图有折线图、散点图、柱状图、直方图、饼状图等，所以本次主要讲解这几张图，注意本次代码主要使用官方文档上的<strong>面向对象</strong>风格，当然使用pyplot风格也是同样可以实现的</p>
<span id="more"></span>
<h2 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h2><p>折线图是默认的图像，直接使用plot就可以画出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that even in the OO-style, we use `.pyplot.figure` to create the figure.</span></span><br><span class="line">fig, ax = plt.subplots()  <span class="comment"># Create a figure and an axes.</span></span><br><span class="line">ax.plot(x, x, label=<span class="string">&#x27;linear&#x27;</span>)  <span class="comment"># Plot some data on the axes.</span></span><br><span class="line">ax.plot(x, x**<span class="number">2</span>, label=<span class="string">&#x27;quadratic&#x27;</span>)  <span class="comment"># Plot more data on the axes...</span></span><br><span class="line">ax.plot(x, x**<span class="number">3</span>, label=<span class="string">&#x27;cubic&#x27;</span>)  <span class="comment"># ... and some more.</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x label&#x27;</span>)  <span class="comment"># Add an x-label to the axes.</span></span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y label&#x27;</span>)  <span class="comment"># Add a y-label to the axes.</span></span><br><span class="line">ax.set_title(<span class="string">&quot;Simple Plot&quot;</span>)  <span class="comment"># Add a title to the axes.</span></span><br><span class="line">ax.legend()  <span class="comment"># Add a legend.</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210724091951456.png" alt="image-20210724091951456"></p>
<h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><p>散点图主要使用函数Scatter，然后输入点的x坐标列表和y坐标列表即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> [<span class="string">&#x27;tab:blue&#x27;</span>, <span class="string">&#x27;tab:orange&#x27;</span>, <span class="string">&#x27;tab:green&#x27;</span>]:</span><br><span class="line">    n = <span class="number">750</span></span><br><span class="line">    x, y = np.random.rand(<span class="number">2</span>, n)</span><br><span class="line">    scale = <span class="number">200.0</span> * np.random.rand(n)</span><br><span class="line">    ax.scatter(x, y, c=color, s=scale, label=color,</span><br><span class="line">               alpha=<span class="number">0.3</span>, edgecolors=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.legend()</span><br><span class="line">ax.grid(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210723213104165.png" alt="image-20210723213104165"></p>
<h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>条形图也就是我们所说的柱状图，有横着和竖着的这两种，一般使用的函数是<code>bar</code>和<code>barh</code></p>
<p>先展示竖着的条形图，这种条形图使用较多，展示效果不错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">labels = [<span class="string">&#x27;G1&#x27;</span>, <span class="string">&#x27;G2&#x27;</span>, <span class="string">&#x27;G3&#x27;</span>, <span class="string">&#x27;G4&#x27;</span>, <span class="string">&#x27;G5&#x27;</span>]</span><br><span class="line">men_means = [<span class="number">20</span>, <span class="number">34</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">27</span>]</span><br><span class="line">women_means = [<span class="number">25</span>, <span class="number">32</span>, <span class="number">34</span>, <span class="number">20</span>, <span class="number">25</span>]</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="built_in">len</span>(labels))  <span class="comment"># the label locations</span></span><br><span class="line">width = <span class="number">0.35</span>  <span class="comment"># the width of the bars</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">rects1 = ax.bar(x - width/<span class="number">2</span>, men_means, width, label=<span class="string">&#x27;Men&#x27;</span>)</span><br><span class="line">rects2 = ax.bar(x + width/<span class="number">2</span>, women_means, width, label=<span class="string">&#x27;Women&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add some text for labels, title and custom x-axis tick labels, etc.</span></span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Scores&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;Scores by group and gender&#x27;</span>)</span><br><span class="line">ax.set_xticks(x)</span><br><span class="line">ax.set_xticklabels(labels)</span><br><span class="line">ax.legend()</span><br><span class="line"></span><br><span class="line">ax.bar_label(rects1, padding=<span class="number">3</span>)</span><br><span class="line">ax.bar_label(rects2, padding=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210724090632449.png" alt="image-20210724090632449"></p>
<p>使用横着展示的条形图，直接使用barh就可以实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fixing random state for reproducibility</span></span><br><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line"></span><br><span class="line">plt.rcdefaults()</span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example data</span></span><br><span class="line">people = (<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Dick&#x27;</span>, <span class="string">&#x27;Harry&#x27;</span>, <span class="string">&#x27;Slim&#x27;</span>, <span class="string">&#x27;Jim&#x27;</span>)</span><br><span class="line">y_pos = np.arange(<span class="built_in">len</span>(people))</span><br><span class="line">performance = <span class="number">3</span> + <span class="number">10</span> * np.random.rand(<span class="built_in">len</span>(people))</span><br><span class="line">error = np.random.rand(<span class="built_in">len</span>(people))</span><br><span class="line"></span><br><span class="line">rects1 = ax.barh(y_pos, performance, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">ax.set_yticks(y_pos)</span><br><span class="line">ax.set_yticklabels(people)</span><br><span class="line">ax.invert_yaxis()  <span class="comment"># labels read top-to-bottom</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Performance&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;How fast do you want to go today?&#x27;</span>)</span><br><span class="line">ax.bar_label(rects1, padding=<span class="number">3</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210724092623279.png" alt="image-20210724092623279"></p>
<h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>直方图跟柱状图有点类似，看起来很像柱状图链接的很紧密，不过感觉这个说法不严谨，我更趋向于是直方图展示连续但是分段的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fixing random state for reproducibility</span></span><br><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line"></span><br><span class="line">N_points = <span class="number">100000</span></span><br><span class="line">n_bins = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate a normal distribution, center at x=0 and y=5</span></span><br><span class="line">x = np.random.randn(N_points)</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(sharey=<span class="literal">True</span>, tight_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># We can set the number of bins with the `bins` kwarg</span></span><br><span class="line">axs.hist(x, bins=n_bins)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210724094320817.png" alt="image-20210724094320817"></p>
<p><code>hist</code>参数中<code>bins</code>是指条形的个数像这个图里面就是20个条形</p>
<h2 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h2><p>饼状图可以看清一个分布，也就是一堆数据当中各种类别的分布。画饼状图主要使用pie函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pie chart, where the slices will be ordered and plotted counter-clockwise:</span></span><br><span class="line">labels = <span class="string">&#x27;Frogs&#x27;</span>, <span class="string">&#x27;Hogs&#x27;</span>, <span class="string">&#x27;Dogs&#x27;</span>, <span class="string">&#x27;Logs&#x27;</span></span><br><span class="line">sizes = [<span class="number">15</span>, <span class="number">30</span>, <span class="number">45</span>, <span class="number">10</span>]</span><br><span class="line">explode = (<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># only &quot;explode&quot; the 2nd slice (i.e. &#x27;Hogs&#x27;)</span></span><br><span class="line"></span><br><span class="line">fig1, ax1 = plt.subplots()</span><br><span class="line">ax1.pie(sizes, explode=explode, labels=labels, autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>,</span><br><span class="line">        shadow=<span class="literal">True</span>, startangle=<span class="number">90</span>)</span><br><span class="line">ax1.axis(<span class="string">&#x27;equal&#x27;</span>)  <span class="comment"># Equal aspect ratio ensures that pie is drawn as a circle.</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210724095404058.png" alt="image-20210724095404058"></p>
<p>需要注意的是<code>pie</code>函数中的<code>autopct</code>是用来显示百分比的，<code>shadow</code>用来控制阴影，<code>startangle</code>用来控制选择角度，而这个突出显示则是使用<code>explode</code>进行</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matlpotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib画图(一)基本操作</title>
    <url>/2021/07/17/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/matplotlib%E7%94%BB%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="matplotlib画图基本操作"><a href="#matplotlib画图基本操作" class="headerlink" title="matplotlib画图基本操作"></a>matplotlib画图基本操作</h1><p>matplotlib是最流行的Python底层绘图库，主要做数据可视化图表,名字取材于MATLAB，模仿MATLAB构建。最近做了很多关于数据分析的题目，对于画图感觉掌握的不熟练所以特地来学习一下。</p>
<p>👉官网地址：<a href="https://matplotlib.org/">https://matplotlib.org/</a></p>
<p>下面这张图是 Matplotlib 图形的组成部分。主要有title、tick、legend、label这类的东西，所以本次也主要从这些出发。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/anatomy.png" alt="anatomy.png"></p>
<span id="more"></span>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标中x的列表</span></span><br><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 坐标中y的列表</span></span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;some numbers&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>展示出的图</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210719225539311.png" alt="image-20210719225539311"></p>
<p>matplotlib使用起来比较简单，传入x的列表和y的列表，直接传入就可以画。</p>
<h2 id="设置图片大小"><a href="#设置图片大小" class="headerlink" title="设置图片大小"></a>设置图片大小</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 实例化figure</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>), dpi=<span class="number">80</span>)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;some numbers&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&quot;line.png&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 存图片</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210719230413323.png" alt="image-20210719230413323"></p>
<h2 id="设置x轴和y轴上的刻度（tick）"><a href="#设置x轴和y轴上的刻度（tick）" class="headerlink" title="设置x轴和y轴上的刻度（tick）"></a>设置x轴和y轴上的刻度（tick）</h2><p>x轴和y轴上面都有刻度如果我们不加，会默认帮我们加上去，但是有的时候我们想自己设计这个刻度也是可以的</p>
<p>比如下图我们可以设置刻度在线段外,当然发现图很丑，但是刻度确实是我们所设置的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;some numbers&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置刻度在线外</span></span><br><span class="line">xticks = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">5</span>, -<span class="number">1</span>)]</span><br><span class="line">yticks = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">5</span>, -<span class="number">1</span>)]</span><br><span class="line">plt.xticks(xticks)</span><br><span class="line">plt.yticks(yticks)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210720102612547.png" alt="image-20210720102612547"></p>
<p>不过我们一般都是设置合适的刻度，毕竟画图需要美观，刻意设置不必要，上面只是为了举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;some numbers&#x27;</span>)</span><br><span class="line"><span class="comment"># 正经设置</span></span><br><span class="line">xticks = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>)]</span><br><span class="line">yticks = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)]</span><br><span class="line">plt.xticks(xticks)</span><br><span class="line">plt.yticks(yticks)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210720102944193.png" alt="image-20210720102944193"></p>
<p>然后有的时候刻度是时间类型或者其他的label之类的，比如：我想展示一天24h的时间变化，刻度需要显示1：00这种，又或者是显示几年内每个月的收入变化，刻度是1998-01-01这种类型该如何显示呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 用来正常显示负号</span></span><br><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;some numbers&#x27;</span>)</span><br><span class="line">xticks = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="comment"># 设置标签</span></span><br><span class="line">xlabel = [<span class="string">&quot;&#123;&#125;点&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>)]</span><br><span class="line">plt.xticks(xticks, xlabel, rotation=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>可以看到只需要在调用xticks的时候传入xlabel就可以实现我们想要的功能，也就是设置对应的刻度列表和刻度标签即可</p>
<h2 id="给图像添加描述信息"><a href="#给图像添加描述信息" class="headerlink" title="给图像添加描述信息"></a>给图像添加描述信息</h2><p>图像的描述信息有xlabel、ylabel、title</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 用来正常显示负号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标中x的列表</span></span><br><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 坐标中y的列表</span></span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;x 的标签&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;y 的标签&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;标签描述&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210720110852460.png" alt="image-20210720110852460"></p>
<h2 id="设置图像风格"><a href="#设置图像风格" class="headerlink" title="设置图像风格"></a>设置图像风格</h2><p>画图我们可以设置线段的风格，可以决定是画线还是画点，然后线的粗细颜色之类的都可以设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]  # 用来正常显示中文标签</span><br><span class="line">plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False  # 用来正常显示负号</span><br><span class="line"></span><br><span class="line"># 坐标中x的列表</span><br><span class="line">x = [0, 1, 2, 3]</span><br><span class="line"># 坐标中y的列表</span><br><span class="line">y = [1, 2, 3, 5]</span><br><span class="line">plt.plot(x, y, color=&#x27;green&#x27;, marker=&#x27;o&#x27;, linestyle=&#x27;dashed&#x27;, linewidth=2, markersize=12)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210720112925627.png" alt="image-20210720112925627"></p>
<p>其中color是设置颜色，marker设置标记点，linestyle设置线条格式，linewidth设置线的宽度，markersize设置线的大小</p>
<p><strong>Colors</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>character</th>
<th>color</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&#39;b&#39;</code></td>
<td>blue</td>
</tr>
<tr>
<td><code>&#39;g&#39;</code></td>
<td>green</td>
</tr>
<tr>
<td><code>&#39;r&#39;</code></td>
<td>red</td>
</tr>
<tr>
<td><code>&#39;c&#39;</code></td>
<td>cyan</td>
</tr>
<tr>
<td><code>&#39;m&#39;</code></td>
<td>magenta</td>
</tr>
<tr>
<td><code>&#39;y&#39;</code></td>
<td>yellow</td>
</tr>
<tr>
<td><code>&#39;k&#39;</code></td>
<td>black</td>
</tr>
<tr>
<td><code>&#39;w&#39;</code></td>
<td>white</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Markers</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>character</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&#39;.&#39;</code></td>
<td>point marker</td>
</tr>
<tr>
<td><code>&#39;,&#39;</code></td>
<td>pixel marker</td>
</tr>
<tr>
<td><code>&#39;o&#39;</code></td>
<td>circle marker</td>
</tr>
<tr>
<td><code>&#39;v&#39;</code></td>
<td>triangle_down marker</td>
</tr>
<tr>
<td><code>&#39;^&#39;</code></td>
<td>triangle_up marker</td>
</tr>
<tr>
<td><code>&#39;&lt;&#39;</code></td>
<td>triangle_left marker</td>
</tr>
<tr>
<td><code>&#39;&gt;&#39;</code></td>
<td>triangle_right marker</td>
</tr>
<tr>
<td><code>&#39;1&#39;</code></td>
<td>tri_down marker</td>
</tr>
<tr>
<td><code>&#39;2&#39;</code></td>
<td>tri_up marker</td>
</tr>
<tr>
<td><code>&#39;3&#39;</code></td>
<td>tri_left marker</td>
</tr>
<tr>
<td><code>&#39;4&#39;</code></td>
<td>tri_right marker</td>
</tr>
<tr>
<td><code>&#39;8&#39;</code></td>
<td>octagon marker</td>
</tr>
<tr>
<td><code>&#39;s&#39;</code></td>
<td>square marker</td>
</tr>
<tr>
<td><code>&#39;p&#39;</code></td>
<td>pentagon marker</td>
</tr>
<tr>
<td><code>&#39;P&#39;</code></td>
<td>plus (filled) marker</td>
</tr>
<tr>
<td><code>&#39;*&#39;</code></td>
<td>star marker</td>
</tr>
<tr>
<td><code>&#39;h&#39;</code></td>
<td>hexagon1 marker</td>
</tr>
<tr>
<td><code>&#39;H&#39;</code></td>
<td>hexagon2 marker</td>
</tr>
<tr>
<td><code>&#39;+&#39;</code></td>
<td>plus marker</td>
</tr>
<tr>
<td><code>&#39;x&#39;</code></td>
<td>x marker</td>
</tr>
<tr>
<td><code>&#39;X&#39;</code></td>
<td>x (filled) marker</td>
</tr>
<tr>
<td><code>&#39;D&#39;</code></td>
<td>diamond marker</td>
</tr>
<tr>
<td><code>&#39;d&#39;</code></td>
<td>thin_diamond marker</td>
</tr>
<tr>
<td>`’</td>
<td>‘`</td>
<td>vline marker</td>
</tr>
<tr>
<td><code>&#39;_&#39;</code></td>
<td>hline marker</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Line Styles</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>character</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&#39;-&#39;</code></td>
<td>solid line style</td>
</tr>
<tr>
<td><code>&#39;--&#39;</code></td>
<td>dashed line style</td>
</tr>
<tr>
<td><code>&#39;-.&#39;</code></td>
<td>dash-dot line style</td>
</tr>
<tr>
<td><code>&#39;:&#39;</code></td>
<td>dotted line style</td>
</tr>
</tbody>
</table>
</div>
<p>具体更多设置可以参考官方文档</p>
<h2 id="设置图例"><a href="#设置图例" class="headerlink" title="设置图例"></a>设置图例</h2><p>有的时候我们一张图有好几条线，为了说清楚我们每条线是什么，我们可以设置图例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]  # 用来正常显示中文标签</span><br><span class="line">plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False  # 用来正常显示负号</span><br><span class="line"></span><br><span class="line"># 坐标中x的列表</span><br><span class="line">x = [0, 1, 2, 3]</span><br><span class="line"># 坐标中y的列表</span><br><span class="line">y1 = [1, 2, 3, 5]</span><br><span class="line">y2 = [1, 3, 5, 8]</span><br><span class="line">plt.plot(x, y1, label=&quot;第一条线&quot;)</span><br><span class="line">plt.plot(x, y2, label=&quot;第二条线&quot;)</span><br><span class="line">plt.legend(loc=&#x27;upper right&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210720114327323.png" alt="image-20210720114327323"></p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matlpotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy基础学习</title>
    <url>/2021/07/24/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/numpy%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="numpy基础学习"><a href="#numpy基础学习" class="headerlink" title="numpy基础学习"></a>numpy基础学习</h1><p>numpy模块是学习数据分析和深度学习必须学习的内容，一个在Python中做科学计算的基础库，重在数值计算，也是大部分PYTHON科学计算库的基础库，多用于在大型、多维数组上执行数值运算，所以本篇文章主要讲解一下numpy的基础内容</p>
<p>官网👉<a href="https://numpy.org/">https://numpy.org/</a></p>
<span id="more"></span>
<h2 id="numpy创建矩阵"><a href="#numpy创建矩阵" class="headerlink" title="numpy创建矩阵"></a>numpy创建矩阵</h2><p>一般创建矩阵使用比较多的就是array、ones等函数，下面展示一些部分创建矩阵的用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">b = np.array(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line">c = np.arange(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">d = np.asarray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>, a, <span class="built_in">type</span>(a), a.dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b&#x27;</span>, b, <span class="built_in">type</span>(b), b.dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c&#x27;</span>, c, <span class="built_in">type</span>(c), c.dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d&#x27;</span>, d, <span class="built_in">type</span>(d), d.dtype)</span><br></pre></td></tr></table></figure>
<p>结果展示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3\python.exe E:/work_space/shixi/Problem/Test.py</span><br><span class="line">a [1 2 3 4 5] &lt;class &#x27;numpy.ndarray&#x27;&gt; int32</span><br><span class="line">b [1 2 3 4 5] &lt;class &#x27;numpy.ndarray&#x27;&gt; int32</span><br><span class="line">c [1 2 3 4 5] &lt;class &#x27;numpy.ndarray&#x27;&gt; int32</span><br><span class="line">d [1 2 3 4 5] &lt;class &#x27;numpy.ndarray&#x27;&gt; int32</span><br></pre></td></tr></table></figure>
<p>上面的展示结果说明<code>a、b、c、d</code>内容的展示，其中<code>a、b、c、d</code>的内容都是<code>1,2,3,4,5</code>,其中<code>a、b、c、d</code>的类型是<code>numpy.ndarray</code>，其中每个元素的类型是<code>int32</code></p>
<h2 id="numpy中常见的数据类型"><a href="#numpy中常见的数据类型" class="headerlink" title="numpy中常见的数据类型"></a>numpy中常见的数据类型</h2><p>numpy常见的数据类型表展示如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">bool_</td>
<td style="text-align:left">布尔型数据类型（True 或者 False）</td>
</tr>
<tr>
<td style="text-align:left">int_</td>
<td style="text-align:left">默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td>
</tr>
<tr>
<td style="text-align:left">intc</td>
<td style="text-align:left">与 C 的 int 类型一样，一般是 int32 或 int 64</td>
</tr>
<tr>
<td style="text-align:left">intp</td>
<td style="text-align:left">用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td>
</tr>
<tr>
<td style="text-align:left">int8</td>
<td style="text-align:left">字节（-128 to 127）</td>
</tr>
<tr>
<td style="text-align:left">int16</td>
<td style="text-align:left">整数（-32768 to 32767）</td>
</tr>
<tr>
<td style="text-align:left">int32</td>
<td style="text-align:left">整数（-2147483648 to 2147483647）</td>
</tr>
<tr>
<td style="text-align:left">int64</td>
<td style="text-align:left">整数（-9223372036854775808 to 9223372036854775807）</td>
</tr>
<tr>
<td style="text-align:left">uint8</td>
<td style="text-align:left">无符号整数（0 to 255）</td>
</tr>
<tr>
<td style="text-align:left">uint16</td>
<td style="text-align:left">无符号整数（0 to 65535）</td>
</tr>
<tr>
<td style="text-align:left">uint32</td>
<td style="text-align:left">无符号整数（0 to 4294967295）</td>
</tr>
<tr>
<td style="text-align:left">uint64</td>
<td style="text-align:left">无符号整数（0 to 18446744073709551615）</td>
</tr>
<tr>
<td style="text-align:left">float_</td>
<td style="text-align:left">float64 类型的简写</td>
</tr>
<tr>
<td style="text-align:left">float16</td>
<td style="text-align:left">半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td>
</tr>
<tr>
<td style="text-align:left">float32</td>
<td style="text-align:left">单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td>
</tr>
<tr>
<td style="text-align:left">float64</td>
<td style="text-align:left">双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td>
</tr>
<tr>
<td style="text-align:left">complex_</td>
<td style="text-align:left">complex128 类型的简写，即 128 位复数</td>
</tr>
<tr>
<td style="text-align:left">complex64</td>
<td style="text-align:left">复数，表示双 32 位浮点数（实数部分和虚数部分）</td>
</tr>
<tr>
<td style="text-align:left">complex128</td>
<td style="text-align:left">复数，表示双 64 位浮点数（实数部分和虚数部分）</td>
</tr>
</tbody>
</table>
</div>
<p>数据类型的相关操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 生成bool类型的</span></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], dtype=np.bool_)</span><br><span class="line"><span class="comment"># 展示结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>, a, <span class="built_in">type</span>(a), a.dtype)</span><br><span class="line"><span class="comment"># 转化为int类型</span></span><br><span class="line">b = a.astype(np.int8)</span><br><span class="line"><span class="comment"># 展示结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b&#x27;</span>, b, <span class="built_in">type</span>(b), b.dtype)</span><br></pre></td></tr></table></figure>
<p>结果展示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3\python.exe E:/work_space/shixi/Problem/Test.py</span><br><span class="line">a [ True False  True False] &lt;class &#x27;numpy.ndarray&#x27;&gt; bool</span><br><span class="line">b [1 0 1 0] &lt;class &#x27;numpy.ndarray&#x27;&gt; int8</span><br></pre></td></tr></table></figure>
<p>浮点数的相关操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成均值为1.75,标准差为1的正态分布数据,10个</span></span><br><span class="line">a = np.random.normal(<span class="number">1.75</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 展示结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>, a, <span class="built_in">type</span>(a), a.dtype)</span><br><span class="line"><span class="comment"># 保留两位小数</span></span><br><span class="line">b = np.<span class="built_in">round</span>(a, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 展示结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b&#x27;</span>, b, <span class="built_in">type</span>(b), b.dtype)</span><br></pre></td></tr></table></figure>
<p>结果展示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3\python.exe E:/work_space/shixi/Problem/Test.py</span><br><span class="line">a [ 1.13844152  1.2766936   0.99489152  2.03742641  3.27012804  0.6785755</span><br><span class="line">  0.39133123  0.44052134 -0.38859551  1.39006692] &lt;class &#x27;numpy.ndarray&#x27;&gt; float64</span><br><span class="line">b [ 1.14  1.28  0.99  2.04  3.27  0.68  0.39  0.44 -0.39  1.39] &lt;class &#x27;numpy.ndarray&#x27;&gt; float64</span><br></pre></td></tr></table></figure>
<h2 id="数组的形状"><a href="#数组的形状" class="headerlink" title="数组的形状"></a>数组的形状</h2><p>numpy数组有不同的形状，有时候理解起来可能有些难以理解。特别是维度多了之后就比较晃眼，不过一般理解3维以内的就可以了。</p>
<p>比如这个三维数组(看有几个左括号就是几个维度)，怎么看出形状呢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[[1,2,3],[1,2,3],[1,2,3]],[[1,2,3],[1,2,3],[1,2,3]]]</span><br></pre></td></tr></table></figure>
<p>首先是看最里面那个<code>[1,2,3]</code>有三个元素，所以是3</p>
<p>其次是看这个<code>[[1,2,3],[1,2,3],[1,2,3]]</code>,有三个<code>[1,2,3]</code>元素，所以是3</p>
<p>最终看<code>[[[1,2,3],[1,2,3],[1,2,3]],[[1,2,3],[1,2,3],[1,2,3]]]</code>,有两个<code>[[1,2,3],[1,2,3],[1,2,3]]</code>，所以是2</p>
<p>综上这个数组的形状是<code>(2,3,3)</code></p>
<p>数组形状操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a的形状&quot;</span>, a.shape)</span><br><span class="line">b = a.reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b的形状&quot;</span>, b.shape)</span><br></pre></td></tr></table></figure>
<p>结果展示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3\python.exe E:/work_space/shixi/Problem/Test.py</span><br><span class="line">[[3 4 5 6 7 8]</span><br><span class="line"> [4 5 6 7 8 9]]</span><br><span class="line">(2, 6)</span><br><span class="line">[[3 4 5 6 7 8]</span><br><span class="line"> [4 5 6 7 8 9]]</span><br></pre></td></tr></table></figure>
<h2 id="数组的轴"><a href="#数组的轴" class="headerlink" title="数组的轴"></a>数组的轴</h2><p>数组的轴在numpy中可以理解为方向,使用0,1,2…数字表示,对于一个一维数组,只有一个0轴,对于2维数组(shape(2,2)),有0轴和1轴,对于三维数组(shape(2,2, 3)),有0,1,2轴。</p>
<p>有了轴的概念之后,我们计算会更加方便,比如计算一个2维数组的平均值,必须指定是计算哪个方向上面的数字的平均值</p>
<p>如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">4</span>,<span class="number">3</span>)  <span class="comment">#shape(4,3)</span></span><br><span class="line">arr_mean = arr.mean(<span class="number">0</span>)      <span class="comment">#shape(3,)</span></span><br></pre></td></tr></table></figure>
<p>图解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210726115552814.png" alt="image-20210726115552814"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据分析/image-20210726115616019.png" alt="image-20210726115616019"></p>
<h2 id="数组相关的计算操作"><a href="#数组相关的计算操作" class="headerlink" title="数组相关的计算操作"></a>数组相关的计算操作</h2><h3 id="数组和算的计算相关操作"><a href="#数组和算的计算相关操作" class="headerlink" title="数组和算的计算相关操作"></a>数组和算的计算相关操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a的值\n&quot;</span>, a)</span><br><span class="line">b = a + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a+1的值\n&quot;</span>, b)</span><br><span class="line">c = a * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a*3的值\n&quot;</span>, c)</span><br></pre></td></tr></table></figure>
<p>结果展示如下，可以看到都是在每个位置上进行对应的操作，这个其实是numpy当中的广播机制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3\python.exe E:/work_space/shixi/Problem/Test.py</span><br><span class="line">a的值</span><br><span class="line"> [[3 4 5 6 7 8]</span><br><span class="line"> [4 5 6 7 8 9]]</span><br><span class="line">a+1的值</span><br><span class="line"> [[ 4  5  6  7  8  9]</span><br><span class="line"> [ 5  6  7  8  9 10]]</span><br><span class="line">a*3的值</span><br><span class="line"> [[ 9 12 15 18 21 24]</span><br><span class="line"> [12 15 18 21 24 27]]</span><br></pre></td></tr></table></figure>
<h3 id="数组和数组的相关计算，数组维度相同时"><a href="#数组和数组的相关计算，数组维度相同时" class="headerlink" title="数组和数组的相关计算，数组维度相同时"></a>数组和数组的相关计算，数组维度相同时</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a的值\n&quot;</span>, a)</span><br><span class="line">b = a * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b的值\n&quot;</span>, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a+b的值\n&quot;</span>, a + b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a-b的值\n&quot;</span>, a - b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a*b的值\n&quot;</span>, a * b)</span><br></pre></td></tr></table></figure>
<p>结果展示如下，可以看到数组相乘是对应元素的乘积，与线性代数当中的矩阵相乘不一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3\python.exe E:/work_space/shixi/Problem/Test.py</span><br><span class="line">a的值</span><br><span class="line"> [[3 4 5 6 7 8]</span><br><span class="line"> [4 5 6 7 8 9]]</span><br><span class="line">b的值</span><br><span class="line"> [[ 9 12 15 18 21 24]</span><br><span class="line"> [12 15 18 21 24 27]]</span><br><span class="line">a+b的值</span><br><span class="line"> [[12 16 20 24 28 32]</span><br><span class="line"> [16 20 24 28 32 36]]</span><br><span class="line">a-b的值</span><br><span class="line"> [[ -6  -8 -10 -12 -14 -16]</span><br><span class="line"> [ -8 -10 -12 -14 -16 -18]]</span><br><span class="line">a*b的值</span><br><span class="line"> [[ 27  48  75 108 147 192]</span><br><span class="line"> [ 48  75 108 147 192 243]]</span><br></pre></td></tr></table></figure>
<h3 id="数组和数组的相关计算，数组维度不同时"><a href="#数组和数组的相关计算，数组维度不同时" class="headerlink" title="数组和数组的相关计算，数组维度不同时"></a>数组和数组的相关计算，数组维度不同时</h3><p>两个数组维度不用时，numpy当中会有一个著名的广播机制，具体的讲解可以查看<a href="https://www.cnblogs.com/jiaxin359/p/9021726.html">https://www.cnblogs.com/jiaxin359/p/9021726.html</a>这篇文章的讲解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a的值\n&quot;</span>, a)</span><br><span class="line">b = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b的值\n&quot;</span>, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a+b的值\n&quot;</span>, a + b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a-b的值\n&quot;</span>, a - b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a*b的值\n&quot;</span>, a * b)</span><br><span class="line">c = np.array([[<span class="number">1</span>], [<span class="number">2</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c的值\n&quot;</span>, c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a+c的值\n&quot;</span>, a + c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a-c的值\n&quot;</span>, a - c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a*c的值\n&quot;</span>, a * c)</span><br></pre></td></tr></table></figure>
<p>结果如下，可以看到b是沿着轴0上进行广播，而c是沿着轴1上进行广播的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3\python.exe E:/work_space/shixi/Problem/Test.py</span><br><span class="line">a的值</span><br><span class="line"> [[3 4 5 6 7 8]</span><br><span class="line"> [4 5 6 7 8 9]]</span><br><span class="line">b的值</span><br><span class="line"> [1 2 3 4 5 6]</span><br><span class="line">a+b的值</span><br><span class="line"> [[ 4  6  8 10 12 14]</span><br><span class="line"> [ 5  7  9 11 13 15]]</span><br><span class="line">a-b的值</span><br><span class="line"> [[2 2 2 2 2 2]</span><br><span class="line"> [3 3 3 3 3 3]]</span><br><span class="line">a*b的值</span><br><span class="line"> [[ 3  8 15 24 35 48]</span><br><span class="line"> [ 4 10 18 28 40 54]]</span><br><span class="line">c的值</span><br><span class="line"> [[1]</span><br><span class="line"> [2]]</span><br><span class="line">a+c的值</span><br><span class="line"> [[ 4  5  6  7  8  9]</span><br><span class="line"> [ 6  7  8  9 10 11]]</span><br><span class="line">a-c的值</span><br><span class="line"> [[2 3 4 5 6 7]</span><br><span class="line"> [2 3 4 5 6 7]]</span><br><span class="line">a*c的值</span><br><span class="line"> [[ 3  4  5  6  7  8]</span><br><span class="line"> [ 8 10 12 14 16 18]]</span><br></pre></td></tr></table></figure>
<h2 id="数组的拼接"><a href="#数组的拼接" class="headerlink" title="数组的拼接"></a>数组的拼接</h2><p>拼接相关的函数有许多，列出下面的几个函数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">concatenate</td>
<td style="text-align:left">提供了axis参数，用于指定拼接方向</td>
</tr>
<tr>
<td style="text-align:left">append</td>
<td style="text-align:left">默认先ravel再拼接成一维数组，也可指定axis</td>
</tr>
<tr>
<td style="text-align:left">stack</td>
<td style="text-align:left">提供了axis参数，用于生成新的维度</td>
</tr>
<tr>
<td style="text-align:left">vstack</td>
<td style="text-align:left">垂直拼接，沿着列的方向，对行进行拼接</td>
</tr>
<tr>
<td style="text-align:left">hstack</td>
<td style="text-align:left">水平拼接，沿着行的方向，对列进行拼接</td>
</tr>
<tr>
<td style="text-align:left">dstack</td>
<td style="text-align:left">沿着第三个轴（深度方向）进行拼接</td>
</tr>
</tbody>
</table>
</div>
<h3 id="concatenate"><a href="#concatenate" class="headerlink" title="concatenate"></a>concatenate</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组a\n&#x27;</span>, a)</span><br><span class="line">b = np.array([[<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组b\n&#x27;</span>, b)</span><br><span class="line">c = np.array([[<span class="number">5</span>], [<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组c\n&#x27;</span>, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;在轴0上拼接\n&#x27;</span>, np.concatenate((a, b), axis=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;在轴1上拼接\n&#x27;</span>, np.concatenate((a, c), axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;不指定轴上拼接\n&#x27;</span>, np.concatenate((a, b), axis=<span class="literal">None</span>))</span><br></pre></td></tr></table></figure>
<p>结果展示，可以看到对于0轴和1轴上的连接是不同的，并且如果不指定轴就是变成一维</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3\python.exe E:/work_space/shixi/Problem/Test.py</span><br><span class="line">数组a</span><br><span class="line"> [[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">数组b</span><br><span class="line"> [[5 6]]</span><br><span class="line">数组c</span><br><span class="line"> [[5 6]]</span><br><span class="line">在轴0上拼接</span><br><span class="line"> [[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]]</span><br><span class="line">在轴1上拼接</span><br><span class="line"> [[1 2 5]</span><br><span class="line"> [3 4 6]]</span><br><span class="line">不指定轴上拼接</span><br><span class="line"> [1 2 3 4 5 6]</span><br></pre></td></tr></table></figure>
<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组a\n&#x27;</span>, a)</span><br><span class="line">b = np.array([[<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组b\n&#x27;</span>, b)</span><br><span class="line">c = np.array([[<span class="number">5</span>], [<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组c\n&#x27;</span>, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;在轴0上拼接\n&#x27;</span>, np.append(a, b, axis=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;在轴1上拼接\n&#x27;</span>, np.append(a, c, axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;不指定轴上拼接\n&#x27;</span>, np.append(a, b))</span><br></pre></td></tr></table></figure>
<p>结果展示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3\python.exe E:/work_space/shixi/Problem/Test.py</span><br><span class="line">数组a</span><br><span class="line"> [[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">数组b</span><br><span class="line"> [[5 6]]</span><br><span class="line">数组c</span><br><span class="line"> [[5 6]]</span><br><span class="line">在轴0上拼接</span><br><span class="line"> [[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]]</span><br><span class="line">在轴1上拼接</span><br><span class="line"> [[1 2 5]</span><br><span class="line"> [3 4 6]]</span><br><span class="line">不指定轴上拼接</span><br><span class="line"> [1 2 3 4 5 6]</span><br></pre></td></tr></table></figure>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack函数比较复杂，以后再补上</p>
<h3 id="vstack、hstack和dstack"><a href="#vstack、hstack和dstack" class="headerlink" title="vstack、hstack和dstack"></a>vstack、hstack和dstack</h3><p>vstack、hstack和dstack分别代表垂直拼接、水平拼接和深度拼接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组a\n&#x27;</span>, a)</span><br><span class="line">b = np.array((<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组b\n&#x27;</span>, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;垂直拼接\n&#x27;</span>, np.vstack((a, b)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;水平拼接\n&#x27;</span>, np.hstack((a, b)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;深度拼接\n&#x27;</span>, np.dstack((a, b)))</span><br></pre></td></tr></table></figure>
<p>结果展示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3\python.exe E:/work_space/shixi/Problem/Test.py</span><br><span class="line">数组a</span><br><span class="line"> [1 2 3]</span><br><span class="line">数组b</span><br><span class="line"> [4 5 6]</span><br><span class="line">垂直拼接</span><br><span class="line"> [[1 2 3]</span><br><span class="line"> [4 5 6]]</span><br><span class="line">水平拼接</span><br><span class="line"> [1 2 3 4 5 6]</span><br><span class="line">深度拼接</span><br><span class="line"> [[[1 4]</span><br><span class="line">  [2 5]</span><br><span class="line">  [3 6]]]</span><br></pre></td></tr></table></figure>
<p>可能水平和垂直比较好理解，那个深度拼接（第三个维度）就比较难以理解了，在官方文档上的解释是<code>这等效于在形状 (M,N) 的二维阵列被重新整形为 (M,N,1) 并且形状 (N,) 的一维阵列被重新整形为 (1, N,1)。重建除以 dsplit 的数组</code>。也就是是说二维数组和一维数组都会被重新reshape成三维数组。所以出现了上面的结果</p>
<h2 id="numpy索引和切片"><a href="#numpy索引和切片" class="headerlink" title="numpy索引和切片"></a>numpy索引和切片</h2><p>numpy中索引和切片和python原生的list是相同的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">24</span>).reshape((<span class="number">4</span>, <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;展示a\n&#x27;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;取一行&quot;</span>, a[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;取一列&quot;</span>, a[:, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;取多行\n&quot;</span>, a[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;取多列\n&quot;</span>, a[:, <span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;取多行多列\n&quot;</span>, a[<span class="number">0</span>:<span class="number">3</span>, <span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;使用数组索引\n&quot;</span>, a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;使用数组索引\n&quot;</span>, a[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;使用数组索引\n&quot;</span>, a[[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">3</span>]], [[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">2</span>]]])</span><br></pre></td></tr></table></figure>
<p>结果展示，可以发现数组索引的维度会对返回后的维度产生影响</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3\python.exe E:/work_space/shixi/Problem/Test.py</span><br><span class="line">展示a</span><br><span class="line"> [[ 0  1  2  3  4  5]</span><br><span class="line"> [ 6  7  8  9 10 11]</span><br><span class="line"> [12 13 14 15 16 17]</span><br><span class="line"> [18 19 20 21 22 23]]</span><br><span class="line">取一行 [0 1 2 3 4 5]</span><br><span class="line">取一列 [ 2  8 14 20]</span><br><span class="line">取多行</span><br><span class="line"> [[ 0  1  2  3  4  5]</span><br><span class="line"> [ 6  7  8  9 10 11]]</span><br><span class="line">取多列</span><br><span class="line"> [[ 0  1]</span><br><span class="line"> [ 6  7]</span><br><span class="line"> [12 13]</span><br><span class="line"> [18 19]]</span><br><span class="line">取多行多列</span><br><span class="line"> [[ 0  1  2]</span><br><span class="line"> [ 6  7  8]</span><br><span class="line"> [12 13 14]]</span><br><span class="line">使用数组索引</span><br><span class="line"> [ 0  7 12]</span><br><span class="line">使用数组索引</span><br><span class="line"> [ 0  2 18 20]</span><br><span class="line">使用数组索引</span><br><span class="line"> [[ 0  2]</span><br><span class="line"> [18 20]]</span><br></pre></td></tr></table></figure>
<p>numpy当中还可以使用布尔索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">24</span>).reshape((<span class="number">4</span>, <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;展示a\n&#x27;</span>, a)</span><br><span class="line">b = a &lt; <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;展示b\n&quot;</span>, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;使用布尔索引\n&quot;</span>, a[b])</span><br></pre></td></tr></table></figure>
<p>结果展示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3\python.exe E:/work_space/shixi/Problem/Test.py</span><br><span class="line">展示a</span><br><span class="line"> [[ 0  1  2  3  4  5]</span><br><span class="line"> [ 6  7  8  9 10 11]</span><br><span class="line"> [12 13 14 15 16 17]</span><br><span class="line"> [18 19 20 21 22 23]]</span><br><span class="line">展示b</span><br><span class="line"> [[ True  True  True  True  True  True]</span><br><span class="line"> [ True  True  True  True False False]</span><br><span class="line"> [False False False False False False]</span><br><span class="line"> [False False False False False False]]</span><br><span class="line">使用布尔索引</span><br><span class="line"> [0 1 2 3 4 5 6 7 8 9]</span><br></pre></td></tr></table></figure>
<h2 id="numpy中的nan和inf"><a href="#numpy中的nan和inf" class="headerlink" title="numpy中的nan和inf"></a>numpy中的nan和inf</h2><p>nan(NAN,Nan):not a number表示不是一个数字</p>
<p>什么时候numpy中会出现nan？</p>
<p>当我们读取本地的文件为float的时候，如果有缺失，就会出现nan，或者当做了一个不合适的计算的时候(比如无穷大(inf)减去无穷大)</p>
<p>inf(-inf,inf):infinity,inf表示正无穷，-inf表示负无穷</p>
<p>什么时候回出现inf包括（-inf，+inf）？</p>
<p>比如一个数字除以0，（python中直接会报错，numpy中是一个inf或者-inf）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.inf</span><br><span class="line">b = np.nan</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># &lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b)) <span class="comment"># &lt;class &#x27;float&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>nan需要注意的点</p>
<ol>
<li><p>两个nan是不相等的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.nan==np.nan <span class="comment">#False</span></span><br><span class="line">np.nan!=np.nan <span class="comment">#True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>任何值和nan进行计算都是nan</p>
</li>
</ol>
<p>判断数组中nan的个数我们可以使用<code>np.count_nonzero(t!=t)</code>进行</p>
<p>改变数组中nan的值也可以使用<code>t[np.isnan(t)] = 0</code>进行</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>numpy当中三元运算符<code>where</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a的值\n&#x27;</span>, a)</span><br><span class="line"><span class="comment"># 将a 当中大于5的部分乘以10</span></span><br><span class="line"><span class="built_in">print</span>(np.where(a &lt; <span class="number">5</span>, a, <span class="number">10</span> * a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果展示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3\python.exe E:/work_space/shixi/Problem/Test.py</span><br><span class="line">a的值</span><br><span class="line"> [0 1 2 3 4 5 6 7 8 9]</span><br><span class="line">[ 0  1  2  3  4 50 60 70 80 90]</span><br></pre></td></tr></table></figure>
<p>numpy当中经常使用的统计函数有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">求和：t.sum(axis=None)</span><br><span class="line"></span><br><span class="line">均值：t.mean(a,axis=None) 受离群点的影响较大</span><br><span class="line"></span><br><span class="line">中值：np.median(t,axis=None)</span><br><span class="line"></span><br><span class="line">最大值：t.max(axis=None)</span><br><span class="line"></span><br><span class="line">最小值：t.min(axis=None)</span><br><span class="line"></span><br><span class="line">极值：np.ptp(t,axis=None) 即最大值和最小值差</span><br><span class="line"></span><br><span class="line">标准差：t.std(axis=None)</span><br><span class="line"></span><br><span class="line">获取最大值最小值的位置 np.argmax(t,axis=0) np.argmin(t,axis=1)</span><br><span class="line"></span><br><span class="line">创建一个全0的数组: np.zeros((3,4))</span><br><span class="line"></span><br><span class="line">创建一个全1的数组:np.ones((3,4))</span><br><span class="line"></span><br><span class="line">创建一个对角线为1的正方形数组(方阵)np.eye(3)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>QTbinarytree</title>
    <url>/2021/05/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QTbinarytree/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Qt绘制二叉树是大二时数据结构的一个实习题目，当时的功能要求如下：</p>
<ul>
<li>键盘输入二叉树结点序列（前序或层次），创建一棵二叉树<ul>
<li>实现<strong>SwapTree</strong>方法，以根结点为参数，交换每个结点的左子树和右子树（提示：前序递归）</li>
</ul>
</li>
<li>实现<strong>Find</strong>方法，查找值为<strong>key</strong>的结点，并输出该结点的所有祖先结点</li>
<li><strong>输入一棵二叉树的前序遍历序列和中序遍历序列，重构这棵二叉树（这个序列里面是不带空结点’#‘的）</strong></li>
</ul>
<span id="more"></span>
<p> 二叉树的前序和中序创建要求如下：</p>
<ul>
<li>要求键盘输入二叉树结点序列<ul>
<li>结点序列可以是前序，也可以是层次</li>
</ul>
</li>
<li><p>空结点以<strong>#</strong>表示</p>
<p>由题目可知呢主要就是可视化一颗二叉树，另外需要说清的是<strong>仅仅前序遍历是无法确定一颗二叉树的顺序的，但是如果前序中加上空节点‘#’，是可以确定的</strong></p>
</li>
</ul>
<p><strong>示例1（前序和层次的）：</strong></p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/数据结构/QTbinarytree.png" alt="QTbinarytree.png"></p>
<p><strong>示例2（前序=“ABC##DE#G##F###” 或者 层次=“AB#CD##EF#G####”）：</strong></p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/数据结构/QTbinarytree3.png" alt="QTbinarytree3"></p>
<p><strong>示例3（前序=”ABHFDECKG”和中序=”HBDFAEKCG”）：</strong></p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/数据结构/QTbinarytree4.png" alt="QTbinarytree4"></p>
<h2 id="主要建树思路"><a href="#主要建树思路" class="headerlink" title="主要建树思路"></a>主要建树思路</h2><ol>
<li>主要功能就前序构造、层次构造、交换节点、查找关键字、重新构建这几个，所以为了图便捷，就直接在Qt提供的ui界面上加上这几个菜单项，可以参考下图</li>
</ol>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/数据结构/QTbinarytree2.png" alt="QTbinarytree2"></p>
<ol>
<li><p>二叉树根据前序生成一颗树。编写了一个函数CreateBinTree，利用递归进行二叉树的生成。思路也比较简单可以看下面的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序创造节点</span></span><br><span class="line"><span class="comment">//i代表第几个字母</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::CreateBinTree</span><span class="params">(QString &amp;str, BinTreeNode *&amp;Node,<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  qDebug()&lt;&lt;str;</span></span><br><span class="line"><span class="keyword">if</span>(str[i]!=<span class="string">&#x27;#&#x27;</span>)<span class="comment">//说明不是空结点</span></span><br><span class="line">&#123;</span><br><span class="line">   Node=<span class="keyword">new</span> <span class="built_in">BinTreeNode</span>(str[i]);</span><br><span class="line">   Treesize++;</span><br><span class="line">   i++;</span><br><span class="line">   <span class="keyword">this</span>-&gt;<span class="built_in">CreateBinTree</span>(str,Node-&gt;left,i);</span><br><span class="line">   <span class="keyword">this</span>-&gt;<span class="built_in">CreateBinTree</span>(str,Node-&gt;right,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">   i++;</span><br><span class="line">   Node=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉树的层次遍历生成一颗二叉树。这个利用队列来完成，利用队列遍历字符串，先将字符串第一个字符塞进队列作为根节点，然后按顺序遍历字符串并且创建对应的孩子节点，具体如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    Treesize=<span class="number">0</span>;</span><br><span class="line">    QQueue&lt;BinTreeNode *&gt;Q;</span><br><span class="line">    BinTreeNode *p=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(str[j]==<span class="string">&#x27;#&#x27;</span>)   <span class="comment">//先创建根节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        Treesize=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root=<span class="keyword">new</span> <span class="built_in">BinTreeNode</span>(str[j]);</span><br><span class="line">    Treesize++;</span><br><span class="line">    Q.<span class="built_in">enqueue</span>(root);</span><br><span class="line">    j++;</span><br><span class="line"><span class="keyword">while</span>(j&lt;(str.<span class="built_in">size</span>()<span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(Q.<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            p=Q.<span class="built_in">dequeue</span>();</span><br><span class="line">			<span class="keyword">if</span>(str[j]!=<span class="string">&#x27;#&#x27;</span>)   <span class="comment">//如果字符不为‘#’，创建左结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;left=<span class="keyword">new</span> <span class="built_in">BinTreeNode</span>(str[j]);</span><br><span class="line">            Treesize++;</span><br><span class="line">            Q.<span class="built_in">enqueue</span>(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">         j++;</span><br><span class="line">        <span class="keyword">if</span>(str[j]!=<span class="string">&#x27;#&#x27;</span>)   <span class="comment">//如果字符不为‘#’，创建右结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;right=<span class="keyword">new</span> <span class="built_in">BinTreeNode</span>(str[j]);</span><br><span class="line">            Treesize++;</span><br><span class="line">            Q.<span class="built_in">enqueue</span>(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">         j++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>通过前序和中序建树。前序和中序确定树的顺序思想比较简单，利用前序的特性找到父节点，然后利用中序确定左右子树，然后重复这样的过程。代码如下，借鉴一下就行，看以前的代码自己都想吐槽。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序和中序建树</span></span><br><span class="line"><span class="comment">//pre代表前序字符串</span></span><br><span class="line"><span class="comment">//in代表中序字符串</span></span><br><span class="line"><span class="comment">//n代表pre可以到的位置</span></span><br><span class="line"><span class="comment">//测试用例： 前序：&quot;ABHFDECKG&quot;，中序：&quot;HBDFAEKCG&quot;</span></span><br><span class="line"><span class="function">BinTreeNode *<span class="title">BinaryTree::creatBinaryTree</span><span class="params">(QString pre, QString in, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">qDebug</span>()&lt;&lt;pre;</span><br><span class="line">  <span class="built_in">qDebug</span>()&lt;&lt;in;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(pre[<span class="number">0</span>]!=in[k]&amp;&amp;k&lt;in.<span class="built_in">length</span>())k++;</span><br><span class="line">  <span class="keyword">if</span>(k&gt;=in.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">//理论上应该需要抛出异常的，</span></span><br><span class="line">  BinTreeNode *t=<span class="keyword">new</span> <span class="built_in">BinTreeNode</span>(pre[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">//以位置k分为左子树和右子树</span></span><br><span class="line">  t-&gt;left=<span class="built_in">creatBinaryTree</span>(pre.<span class="built_in">mid</span>(<span class="number">1</span>),in,k);<span class="comment">//从0-k是左子树，所以在这里pre只能遍历到k</span></span><br><span class="line">  t-&gt;right=<span class="built_in">creatBinaryTree</span>(pre.<span class="built_in">mid</span>(k<span class="number">+1</span>),in.<span class="built_in">mid</span>(k<span class="number">+1</span>),n-k<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">//由于pre和in同时都只保留右子树部分，所以pre</span></span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面建树的例子看看就行，尤其是最后一个前中序建树，也不知道自己当时是怎么写出这么魔性的代码。下面就专门介绍一下画二叉树的部分。</p>
<h2 id="主要画树思路"><a href="#主要画树思路" class="headerlink" title="主要画树思路"></a>主要画树思路</h2><p> 画树是利用了Qt的绘图事件，直接进行画图，画图是在建树已经完成的基础之上完成的。<strong>想法比较简单，所以画出来的比较难看，先在这里说明一下</strong>。</p>
<ol>
<li><p>二叉树的节点是圆形的，半径为25。二叉树的子节点和父节点之间x轴上相差45，y轴上100。举个例子：父节点的坐标为（x，y），则左孩子坐标为（x-45，y+100），右孩子坐标为（x+45，y+100）。根节点的坐标设置为（500，75），这些数据都可以根据自己的需求改，不定死。</p>
</li>
<li><p>数据结构设计的时候，对于二叉树的节点BinTreeNode，设计一个data（QChar类型，用于存储数据）、point（QPoint类型，用于存储位置）</p>
</li>
<li><p>数据结构设计时，对于二叉树BinaryTree，设计Mypoints（QPoint <em>类型，存储树各个结点坐标）、My_lines（ QLine </em>类型，存储需要画的线的条数）</p>
</li>
<li><p>写一个函数setMyPoints，通过层次遍历，完成各个坐标的匹配。其中对于Mypoints直接存储节点的中心，然后画圆；对于线段，从上面的例子也看得出来是父节点的中心向下半径个位置作为起点，子节点中心向上半径个位置为终点。具体代码如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为坐标组设置应的坐标,以及得到相应的线段</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::setMyPoints</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="comment">//设置父节点和子节点间横坐标相差的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//    int H=height();</span></span><br><span class="line">    Mypoints=<span class="keyword">new</span> QPoint[Treesize];  <span class="comment">//动态分配空间</span></span><br><span class="line">    My_lines=<span class="keyword">new</span> QLine[Treesize<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    QQueue&lt;BinTreeNode *&gt;Q;         <span class="comment">//调用队列</span></span><br><span class="line">    BinTreeNode *p=root;</span><br><span class="line">    root-&gt;<span class="built_in">setpoint</span>(<span class="built_in">QPoint</span>(<span class="number">500</span>,<span class="number">75</span>));  <span class="comment">//为根节点设置坐标</span></span><br><span class="line">    Q.<span class="built_in">enqueue</span>(root);</span><br><span class="line">    Mypoints[i]=root-&gt;point;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过层次遍历，完成各个坐标的匹配</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        p=Q.<span class="built_in">dequeue</span>();</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="type">int</span> h=<span class="built_in">height</span>(p);</span><br><span class="line">            p-&gt;left-&gt;<span class="built_in">setpoint</span>(p-&gt;point-<span class="built_in">QPoint</span>(<span class="number">45</span>*h,<span class="number">-100</span>));</span><br><span class="line">            Mypoints[i]=p-&gt;left-&gt;point;</span><br><span class="line">            My_lines[i<span class="number">-1</span>].<span class="built_in">setP1</span>(p-&gt;point+<span class="built_in">QPoint</span>(<span class="number">0</span>,<span class="number">25</span>));<span class="comment">//线</span></span><br><span class="line">            My_lines[i<span class="number">-1</span>].<span class="built_in">setP2</span>(p-&gt;left-&gt;point-<span class="built_in">QPoint</span>(<span class="number">0</span>,<span class="number">25</span>));</span><br><span class="line">            Q.<span class="built_in">enqueue</span>(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="type">int</span> h=<span class="built_in">height</span>(p);</span><br><span class="line">            p-&gt;right-&gt;<span class="built_in">setpoint</span>(p-&gt;point+<span class="built_in">QPoint</span>(<span class="number">45</span>*h,<span class="number">100</span>));</span><br><span class="line">            Mypoints[i]=p-&gt;right-&gt;point;</span><br><span class="line">            My_lines[i<span class="number">-1</span>].<span class="built_in">setP1</span>(p-&gt;point+<span class="built_in">QPoint</span>(<span class="number">0</span>,<span class="number">25</span>));</span><br><span class="line">            My_lines[i<span class="number">-1</span>].<span class="built_in">setP2</span>(p-&gt;right-&gt;point-<span class="built_in">QPoint</span>(<span class="number">0</span>,<span class="number">25</span>));</span><br><span class="line">            Q.<span class="built_in">enqueue</span>(p-&gt;right);</span><br><span class="line">            h--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>对于左侧显示的字符，这个就比较简单了，直接在建树之后进行相对应的前序、中序、后续、层次遍历，然后将字符串保存下来即可，在这里就不展开详细讲解</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我画二叉树的思想比较简单，所以画出来也不是很好看，代码虽然可以运行，但是也有一些小细节上的问题，如果有什么更好的意见欢迎指教。</p>
<p><a href="https://github.com/bugcat9/Qtbinarytree.git">源码传输门</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络</title>
    <url>/2021/05/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>在机器学习的基础知识学习过程当中，学习了一下神经网络，然后就机器学习方面的神经网络和卷积神经网络方面写一下自己的个人理解，顺便总结一下。</p>
</blockquote>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h3 id="一、神经元模型"><a href="#一、神经元模型" class="headerlink" title="一、神经元模型"></a>一、神经元模型</h3><p>神经元是神经网络当中最基本的模型。在生物神经网络中每个神经元与其他神经元相连，当它“兴奋”时，就会向相连的神经元发送化学物质，从而改变其他神经元内的电位;如果这些神经元的电位超过了 个“阔值” ，那么它就会被激活 “兴奋“起来，也同样会向其他神经元发送化学物质。<br><span id="more"></span><br>​    在机器学习当中，人们将这个模型抽象出来，就产生了机器学习当中的<strong>神经元模型</strong>，如下图，$x<em>i$就是其他神经元的输入（相当于神经物质），$\omega_i$为权值，神经网络主要学习的就是这个权值，$ \theta $为对应的阈值，超过这个阈值就向其他神经元发送化学物质，而这个$f$是激活函数，用于判断是否发送化学物质，产生的值为0或者1（0不发送，1就发送）,$f$可以理解为输入$\sum</em>{i=1}^{n}\omega_ix_i-\theta$输出0或者1的函数。</p>
<p>​    所有一个神经元的输入为$x_i$,输出为0或者1（个人认为可以简单这样理解），计算公式如下：</p>
<script type="math/tex; mode=display">
y=f(\sum_{i=1}^{n}\omega_ix_i-\theta)</script><p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/机器学习/神经网络1.png" alt="神经网络1" style="zoom:80%;" /></p>
<p><strong>相关趣事</strong>：</p>
<blockquote>
<p>1943年，心理学家McCulloch和数学家Pitts参考了生物神经元的结构，发表了抽象的神经元模型MP，1943年发布的MP模型，虽然简单，但已经建立了神经网络大厦的地基。但是，MP模型中，权重的值都是预先设置的，因此不能学习。1949年心理学家Hebb提出了Hebb学习率，认为人脑神经细胞的突触（也就是连接）上的强度上可以变化的。于是计算科学家们开始考虑用调整权值的方法来让机器学习。这为后面的学习算法奠定了基础。</p>
</blockquote>
<h3 id="二、激活函数"><a href="#二、激活函数" class="headerlink" title="二、激活函数"></a>二、激活函数</h3><pre><code>     神经元最终是通过激活函数的处理产生神经元的输出,最开始的时候激活函数的模型为$sgn(x)$(如下图a，其实在数学课上见过很多次这个函数)，刚好符合我们的要求，当$(\sum_&#123;i=1&#125;^&#123;n&#125;\omega_ix_i-\theta)&gt;0$时，输出1否则输出0。可是这个函数的缺点是不可导，这在数学上性质就很不好，所以人们就用另外一个性质优秀的函数代替了它，就是$sigmoid(x)$函数（如下图b，记住这个函数后面会用到）。
</code></pre><p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/机器学习/神经网络2.png" alt="神经网络2" style="zoom:80%;" /></p>
<p>​        除了这两个函数之外，还有许多其他的常用的激活函数，如：$tanh:f(x)=tanh(x)、ReLU：f(x)=max(x,0)、softmax:f(x)=log(1+exp(x))$</p>
<h3 id="三、感知机"><a href="#三、感知机" class="headerlink" title="三、感知机"></a>三、感知机</h3><p>​        由于一个神经元的功能太过鸡肋，所以在1958年，计算科学家Rosenblatt提出了提出了两层神经元组成的神经网络，取名为“感知机”。</p>
<p>​        感知机由两层神经元组成，输入层接收外界输入信息后传给输出层，输出层是M-P神经元。感知器是当时首个可以学习的人工神经网络，当时Rosenblatt现场演示了其学习识别简单图像的过程，在当时的社会引起了轰动。</p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/机器学习/神经网络3.png" alt="神经网络3" style="zoom:80%;" /></p>
<p>​        感知机可以解决线性问题，如：</p>
<ol>
<li>“与”问题($x_1$^$x_2$)，令参数$\omega_1=1,\omega_2=1,\theta=2$,则有$y=f(1<em>x_1+1</em>x_2-2)$,当且仅当$x_1=x_2=1$时，才有$y=1$</li>
<li>“或”问题($x_1$||$x_2$)，令参数$\omega_1=1,\omega_2=1,\theta=0.5$,则有$y=f(1<em>x_1+1</em>x_2-0.5)$,当且仅当$x_1=1或者x_2=1$时，有$y=1$</li>
<li>“非问题”(~$x_1$)，令参数$\omega_1=-0.6,\omega_2=0,\theta=-0.5$,则有$y=f(-0.6<em>x_1+0</em>x_2+0.5)$,当$x_1=1,y=0$;当$x_1=0,y=1$</li>
</ol>
<p>感知机可以解决线性问题，可以这也理解，看下图</p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/机器学习/神经网络4.png" alt="神经网络4" style="zoom: 80%;" /></p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/机器学习/神经网络5.png" alt="神经网络5" style="zoom:80%;" /></p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/机器学习/神经网络6.png" alt="神经网络6" style="zoom:80%;" /></p>
<p>可以发现$z=g(\omega_{i,j}*a_i)$,是以矩阵形式呈现的，和机器学习前面学的线性模型的表达式一样，所以感知机其实可以认为是一个线性模型。</p>
<p><strong>相关历史趣事</strong>：</p>
<blockquote>
<p>​        1958年，计算科学家Rosenblatt提出了由两层神经元组成的神经网络。他给它起了一个名字:“感知器”（Perceptron）（有的文献翻译成“感知机”）。</p>
<p>感知器是当时首个可以学习的人工神经网络。Rosenblatt现场演示了其学习识别简单图像的过程，在当时的社会引起了轰动。人们认为已经发现了智能的奥秘，许多学者和科研机构纷纷投入到神经网络的研究中。美国军方大力资助了神经网络的研究，并认为神经网络比“原子弹工程”更重要。这段时间直到1969年才结束，这个时期可以看作神经网络的第一次高潮。</p>
<p>​        但是，Minsky在1969年出版了一本叫《Perceptron》的书，里面用详细的数学证明了感知器的弱点，尤其是感知器对XOR（异或）这样的简单分类任务都无法解决。由于Minsky的巨大影响力以及书中呈现的悲观态度，让很多学者和实验室纷纷放弃了神经网络的研究。神经网络的研究陷入了冰河期。这个时期又被称为“AI winter”。接近10年以后，对于两层神经网络的研究才带来神经网络的复苏。</p>
</blockquote>
<h3 id="四、多层神经网络和BP算法"><a href="#四、多层神经网络和BP算法" class="headerlink" title="四、多层神经网络和BP算法"></a>四、多层神经网络和BP算法</h3><h4 id="1-多层神经网络"><a href="#1-多层神经网络" class="headerlink" title="1.多层神经网络"></a>1.多层神经网络</h4><p>​        由于感知机对非线性问题的乏力，为了解决非线性问题，就提出了多层神经网络。多层神经网络：输入层和输出层之间加一层神经元（隐含层），隐含层和输出层神经元都拥有激活函数的功能神经元，并且有理论证明，两层神经网络可以无限逼近任意连续函数。</p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/机器学习/神经网络7.png" alt="神经网络7" style="zoom:80%;" /></p>
<p>​        出现多层神经网络的原因是误差逆传播算法的出现。误差传播算法（error BackPropagation,简称BP）算法，被成为迄今为止最成功的神经网络算法，在现实任务中使用神经网络时，大多数时在使用BP算法进行训练。</p>
<h4 id="2-BP算法"><a href="#2-BP算法" class="headerlink" title="2.BP算法"></a>2.BP算法</h4><p>给定训练集$D=\left{(x_1,y_1),(x_2,y_2),…,(x_m,y_m)\right},x_i\in R^d,y_i\in R^d$</p>
<p>假设一个神经网络有$d$个输入神经元、$l$个输出神经元，$q$个隐含神经元(可以参考下图)</p>
<p>设输出层第$j$个神经元的阈值用$\theta_i$表示，隐含层第$h$个神经元阈值用$\gamma_h$表示</p>
<p>输入层第$i$个神经元和隐含层第$h$个神经元之间权重为$\upsilon<em>{ih}$;隐含层第$h$个神经元和输出层第$j$个神经元之间权重为$\omega</em>{hj}$</p>
<p>记隐含层第$h$个神经元的输入为$\alpha<em>h=\sum</em>{i=1}^{d}{\upsilon<em>{ih}x_i}$;输出层第$j$个神经元接收的输入为$\beta_j=\sum</em>{h=1}^{q}{\omega_{hj}b_h}$（其中$b_h$为隐含层第$h$个神经元的输出）</p>
<p>然后假设隐藏层和输出层都使用$sigmoid(x)$函数作为激活函数，因为该函数有可导的性质，该函数的导数为$f\prime(x)=f(x)(1-f(x))$</p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/机器学习/神经网络8.png" alt="神经网络8" style="zoom:80%;" /></p>
<p>对于其中的训练例子$(x_k,y_k)$,假设神经网络的输出为$\hat y_k=(\hat y_1^k,\hat y_2^k,…,\hat y_l^k)$,即$\hat y_l^k=f(\beta_j-\theta_j)$</p>
<p>可以得到均方误差$E_k=\frac{1}{2}(\hat y^k_j-y^k_j)^2$,并且有$(d+l+1)*q+l$个参数需要确定。</p>
<p>以其中权重参数$\omega<em>{hj}$为例，它的更新估计式：$\omega\leftarrow\omega+\Delta\omega$,其中$\Delta\omega=-\eta\frac{ \partial E_k}{\partial \omega</em>{hj}}$（就是求偏导，其中$\eta$为学习率）</p>
<p>式子：$\frac{ \partial E<em>k}{\partial \omega</em>{hj}}=\frac{\partial E<em>k}{\partial \hat y^k_j}\cdot\frac{\partial \hat y^k_j}{\partial \beta_j}\cdot\frac{\partial \beta_j}{\partial \omega</em>{hj}}$</p>
<p>可以知道$\frac{\partial \beta<em>j}{\partial  \omega</em>{hj}}=b_h$,然后设</p>
<script type="math/tex; mode=display">
g_i=\frac{\partial E_k}{\partial  \hat y^k_j}\cdot\frac{\partial  \hat y^k_j}{\partial  \beta_j}</script><p>由于$E_k=\frac{1}{2}(\hat y^k_j-y^k_j)^2$以及$\hat y_l^k=f(\beta_j-\theta_j)$，所以有</p>
<script type="math/tex; mode=display">
g_i=(\hat y^k_j-y^k_j)\cdot f\prime(\beta_j-\theta_j)</script><p>再由激活函数$f(x)$为$sigmoid(x)$函数，所以导数$f\prime(x)=f(x)(1-f(x))$，则：</p>
<script type="math/tex; mode=display">
g_i=\hat y^k_j(1-\hat y^k_j)(y^k_j-\hat y^k_j)</script><p>这样我们就得到了</p>
<script type="math/tex; mode=display">
\Delta\omega=\eta g_ib_h</script><p>同理我们可以得到其他的参数值，如：$\Delta \theta<em>j=-\eta g_i$、$\Delta \upsilon</em>{ih}=\eta e<em>h x_i$、$\Delta \gamma_h=-\eta e_h$,其中$e_h=b_h(1-b_h)\sum</em>{j=1}^{l}{\omega_{hj}gi}$</p>
<p>上面只是简单的说明了一下在神经网络过程中，参数大概是怎么计算出来的，在正真的编程的时候其实这些过程都不需要我们自己实现，一般的深度学习框架都帮我们实现了。</p>
<h4 id="3-过拟合问题"><a href="#3-过拟合问题" class="headerlink" title="3.过拟合问题"></a>3.过拟合问题</h4><p>由于神经网络强大的表示能力，经常会出现过拟合问题，一般解决方法由两种：</p>
<ul>
<li><p>“早停”：将数据分为训练集和验证集，训练集计算梯度、更新权值和阈值，验证集用来估计误差</p>
</li>
<li><p>“正则化”：其思想是在误差目标函数中增加一个用于描述网路复炸程度的部分，例如连接权值和阈值的平方和，如下图，其中λϵ（0，1），用于对经验误差与网络复杂度进行折中。</p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/机器学习/神经网络9.png" alt="神经网络9" style="zoom: 50%;" /></p>
</li>
</ul>
<p><strong>相关历史趣事：</strong></p>
<blockquote>
<p>​        1986年，Rumelhar和Hinton等人提出了反向传播（Backpropagation，BP）算法，解决了两层神经网络所需要的复杂计算量问题，从而带动了业界使用两层神经网络研究的热潮。但是不幸的是，当时的神经网络任然存在很多问题，比如训练时间长、优化困难等。值得注意的是这个时候的Hinton还比较年轻，30年以后，正是他重新定义了神经网络，带来了神经网络复苏的又一春。</p>
<p>​        90年代中期，由Vapnik等人发明的SVM（Support Vector Machines，支持向量机）算法诞生，很快就在若干个方面体现出了对比神经网络的优势：无需调参；高效；全局最优解。基于以上种种理由，SVM迅速打败了神经网络算法成为主流，神经网络的研究再次陷入了冰河期。</p>
<p>​        直到2006年，Hinton在《Science》和相关期刊上发表了论文，首次提出了“深度信念网络”的概念，同时他给多层神经网络相关的学习方法赋予了一个新名词—“<strong>深度学习</strong>”，就在这之后，关于深度神经网络的研究与应用不断涌现。</p>
<p>​        2019年3月27日 ——ACM宣布，深度学习的三位创造者Yoshua Bengio， Yann LeCun， 以及Geoffrey Hinton获得了2019年的图灵奖。</p>
</blockquote>
<p>Hinton老爷子的照片：</p>
<p><img src="https://gitee.com/bugcat9/BlogImage/raw/master/机器学习/神经网络10.png" alt="神经网络10"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单的讲解了一下神经网络的基本概念，并没有涉及CNN、RNN等相关的东西。然后自己用pytorch写了一下这个神经网络识别手写数据集：<a href="https://github.com/Zhounning/MachineLearning/blob/master/arithmetic/MNIST手写数字数据集MLP.ipynb">点这里</a></p>
<p><strong>参考</strong>：</p>
<p>《机器学习》—周志华</p>
<p><a href="https://www.cnblogs.com/subconscious/p/5058741.html">https://www.cnblogs.com/subconscious/p/5058741.html</a></p>
<p><a href="https://www.zhihu.com/question/22553761">https://www.zhihu.com/question/22553761</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode-Introduction</title>
    <url>/2021/05/20/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/VScode-Introduction/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>VSCode是微软推出的一款编译器，在Mac、Linux、Windows下都可以使用，听别人说挺好用，但是自己并没有尝试，现在是第一次使用，用它来写c++。<br>本篇博客主要是讲解一下VSCode写C++的配置</p>
<span id="more"></span>
<h2 id="一、VSCode下载安装"><a href="#一、VSCode下载安装" class="headerlink" title="一、VSCode下载安装"></a>一、VSCode下载安装</h2><p>VSCode下载和安装比较简单，直接百度vscode然后进入官网就能够下载(<a href="https://code.visualstudio.com/">官网传送门</a>),可以参考下图：<br><img src="https://gitee.com/bugcat9/BlogImage/raw/master/其他/download1.png" alt=""><br><img src="https://gitee.com/bugcat9/BlogImage/raw/master/其他/download2.png" alt=""><br>VSCode安装比较简单，就不多解释了</p>
</blockquote>
<h2 id="二、下载C-编译器"><a href="#二、下载C-编译器" class="headerlink" title="二、下载C++编译器"></a>二、下载C++编译器</h2><p>vscode只是一个简单的IDE，说白了就是一个写txt的地方，所以我们还需要下载一个编译器。我选择的编译器是MinGW(<a href="https://sourceforge.net/projects/mingw-w64/">下载传送门</a>)，下载后进行安装，安装之后直接打开会进入MinGW Installation Manaager界面，在左侧栏选择Basic Setup，然后右侧会出现7个包，我们只需要选中这七个包进行下载即可（如果有其他需求可以选择左侧的All Packages自行选择）。下载的方法是选中相对应的包然后按下鼠标右键选择“Mark For Installtion”，可以参考下图：<br><img src="https://gitee.com/bugcat9/BlogImage/raw/master/其他/download3.png" alt=""><br>将想下载的包都选中之后，然点击菜单栏上的Installation选择Apply Changes，可以参考下图：<br><img src="https://gitee.com/bugcat9/BlogImage/raw/master/其他/download4.png" alt=""><br>下载完成之后，C++编译器也算是完成了，最后将对应的MinGW的环境配置一下就行，简单来说就是将安装下载MinGW目录下的bin目录加到环境path当中，比如我MinGW安装的位置是：“D:\MinGW\bin”，就将“D:\MinGW\bin”加入到path当中就行，如果想测试是否安装成功，可以在cmd当中试下“g++ —version”、“gdb —version”是否都有结果如果都有则安装成功。</p>
<h2 id="三、在VSCode当中配置C-C-环境"><a href="#三、在VSCode当中配置C-C-环境" class="headerlink" title="三、在VSCode当中配置C/C++环境"></a>三、在VSCode当中配置C/C++环境</h2><p>配置的大部分都是参考了VSCode的官方文档，翻了许多别人写的博客，许多因为版本问题其实在现在并不是很适用，后来看了官方提供的文档，才觉得豁然开朗。在vscode当中有个文件夹.vscode比较重要，里面会存放vscode的配置文件，对于本次比较重要的配置文件有三个，分别为：tasks.json（构建指令配置）、launch.json（调试设置）、c_cpp_properties.json（编译路径路径配置）</p>
<h3 id="1-安装VSCode中的C-C-插件"><a href="#1-安装VSCode中的C-C-插件" class="headerlink" title="1.安装VSCode中的C/C++插件"></a>1.安装VSCode中的C/C++插件</h3><p>在Extensions（Ctrl+Shift+X）当中搜索C++进行安装,如下图：<br><img src="https://gitee.com/bugcat9/BlogImage/raw/master/其他/download5.png" alt=""></p>
<h3 id="2-创建hello-cpp文件"><a href="#2-创建hello-cpp文件" class="headerlink" title="2.创建hello.cpp文件"></a>2.创建hello.cpp文件</h3><p>找一个空的目录（当作工作空间）在里面创建hello.cpp文件，然后用VSCode打开,在里面写下如下的代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   vector&lt;string&gt; msg &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;from&quot;</span>, <span class="string">&quot;VS Code&quot;</span>, <span class="string">&quot;and the C++ extension!&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">const</span> string&amp; word : msg)</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>参考图如下：<br><img src="https://gitee.com/bugcat9/BlogImage/raw/master/其他/download6.png" alt=""></p>
<h3 id="3-创建tasks-json文件"><a href="#3-创建tasks-json文件" class="headerlink" title="3.创建tasks.json文件"></a>3.创建tasks.json文件</h3><p>接下来，我们需要创建一个tasks.json文件来告诉VS Code如何构建（编译）程序。但是这个文件不要我们手动创建，具体可以看下面。<br>我们在主菜单中选择<strong>终端（Terminal ）&gt;配置默认生成任务（Configure Default Build Task）</strong>。在弹出来的下拉列表中，选择<strong>g++.exe build active file</strong>，点击之后他会自动生成.vscod文件夹,并且里面会自动生成tasks.json文件。<br><img src="https://gitee.com/bugcat9/BlogImage/raw/master/其他/download7.png" alt=""><br>然后我们需要在tasks.json里面写下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">// 有关 tasks.json 格式的文档，请参见</span></span><br><span class="line">    <span class="comment">// https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++.exe build active file&quot;</span><span class="punctuation">,</span>   </span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\bin\\g++.exe&quot;</span><span class="punctuation">,</span>   <span class="comment">//对应自己下载的目录,换一下安装位置</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\bin&quot;</span>  <span class="comment">//对应自己下载的目录,换一下安装位置</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>完成上诉步骤之后你就可以直接运行程序,会生成对应的exe应该可以看见（按下ctrl+shit+B可以运行）。</p>
<h3 id="4-创建launch-json文件"><a href="#4-创建launch-json文件" class="headerlink" title="4.创建launch.json文件"></a>4.创建launch.json文件</h3><p>目前我们并不能对代码进行调试，要想进行调试需要创建aunch.json文件，同理也不需要我们自己创建,可以选择在调试界面选择“创建launch.json文件”，或者在菜单栏中选择<strong>调试 &gt; 添加配置.</strong>，然后选择<strong>C ++（GDB / LLDB）</strong>，然后选择<strong>g++.exe build and debug active file.</strong><br><img src="https://gitee.com/bugcat9/BlogImage/raw/master/其他/download9.png" alt=""><br>然后在launch.json文件中写下如下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++.exe build and debug active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span>      <span class="comment">//更改到自己的目录下</span></span><br><span class="line">      <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++.exe build active file&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>完成上述事情之后就可以设置断点进行相对应的调试了</p>
<h3 id="5-设置C-C-配置"><a href="#5-设置C-C-配置" class="headerlink" title="5.设置C/C++配置"></a>5.设置C/C++配置</h3><p>按下<strong>Ctrl+Shift+P</strong> 打开搜索界面然后选择<strong>C/C++: Edit Configurations (UI)</strong><br><img src="https://gitee.com/bugcat9/BlogImage/raw/master/其他/download10.png" alt=""><br>选择左下角的<strong>c_cpp_properties.json 文件</strong><br><img src="https://gitee.com/bugcat9/BlogImage/raw/master/其他/download11.png" alt=""><br>编写c_cpp_properties.json内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Win32&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\bin\\gcc.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang-x86&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>可以根据自己安装路径将compilerPath的对应目录进行更换</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>完成上述步骤之后，就能使用vscode进行相对应的C++编写了，不得不说vscode还是挺香的</p>
]]></content>
      <categories>
        <category>环境配置安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>android studio安装</title>
    <url>/2021/05/20/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/android%20studio%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Android-studio-下载安装"><a href="#Android-studio-下载安装" class="headerlink" title="Android studio 下载安装"></a>Android studio 下载安装</h1><h2 id="java环境配置"><a href="#java环境配置" class="headerlink" title="java环境配置"></a>java环境配置</h2><h3 id="java下载"><a href="#java下载" class="headerlink" title="java下载"></a>java下载</h3><p>去<a href="https://www.oracle.com/java/technologies/javase-downloads.html">Oracle官网</a>下载自己需要的java版本</p>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/企业微信截图_16104173834716.png" alt="图片"></p>
<p>我这里选择的是windows的jdk8</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/企业微信截图_16104172348073.png" alt="图片"></p>
<p>ps:下载需要登录自己Oracle账号，注册登录一下就行</p>
<p>下载之后的exe文件双击开，安装到你需要安装的位置即可，我这里安装位置是</p>
<p><code>D:\Program Files\Java\jdk1.8.0_271</code></p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>在系统变量里面加入了变量<code>JAVA_HOME</code>，值为安装的位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210113195035403.png" alt=""></p>
<p>然后在Path里面加入了<code>%JAVA_HOME%\bin</code>和<code>%JAVA_HOME%\jre\bin</code>(这个有待商量)</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210113195354124.png" alt=""></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在cmd当中输入<code>java -version</code>和<code>javac -version</code>查看输出，如果有如下的输出说明配置正确</p>
<p><code>java -version</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java version &quot;1.8.0_271&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_271-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.271-b09, mixed mode)</span><br></pre></td></tr></table></figure>
<p><code>javac -version</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac 1.8.0_271</span><br></pre></td></tr></table></figure>
<h2 id="Android-studio下载和安装"><a href="#Android-studio下载和安装" class="headerlink" title="Android studio下载和安装"></a>Android studio下载和安装</h2><h3 id="android-studio下载"><a href="#android-studio下载" class="headerlink" title="android studio下载"></a>android studio下载</h3><p>直接去<a href="https://developer.android.com/studio?hl=zh-cn">官网</a>,下载<code>installer.exe</code>或者zip都可以，我这里是下载的zip。</p>
<p>然后找个合适的位置解压，解压完之后是这个样子</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210114095707274.png" alt=""></p>
<p>我们进入bin文件点击<code>studio64.exe</code>就可以运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210114095925560.png" alt=""></p>
<h3 id="第一次运行"><a href="#第一次运行" class="headerlink" title="第一次运行"></a>第一次运行</h3><p>第一次运行可能会下载一些sdk等东西，这里的话只需要记得更改sdk下载位置，别下载到c盘就行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/企业微信截图_16105903698073.png" alt=""></p>
<p>ps:网络可能会导致很难下载下来，这个可以通过设置镜像等方法解决</p>
<h2 id="Android环境配置"><a href="#Android环境配置" class="headerlink" title="Android环境配置"></a>Android环境配置</h2><p>Android 环境配置主要配置sdk的环境变量，跟上面java环境配置类似，在系统变量中加入<code>ANDROID_HOME</code>对应着sdk安装位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/企业微信截图_16106158683453.png" alt=""></p>
<p>然后在path当中加入<code>%ANDROID_HOME%\platform-tools</code>和<code>%ANDROID_HOME%\tools</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210114172309012.png" alt=""></p>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>在cmd当中输入adb，然后输出类似如下信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Android Debug Bridge version 1.0.41</span><br><span class="line">Version 30.0.5-6877874</span><br><span class="line">Installed as D:\Users\ningzzhou\AppData\Local\Android\SDK\platform-tools\adb.exe</span><br><span class="line"></span><br><span class="line">global options:</span><br><span class="line"> -a         listen on all network interfaces, not just localhost</span><br><span class="line"> -d         use USB device (error if multiple devices connected)</span><br></pre></td></tr></table></figure>
<p>更多环境变量配置可以参考官网：<a href="https://developer.android.com/studio/command-line/variables?hl=zh-cn">https://developer.android.com/studio/command-line/variables?hl=zh-cn</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Android studio因为经常需要安装,所以记录一下</p>
]]></content>
      <categories>
        <category>环境配置安装</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse中android环境配置</title>
    <url>/2021/05/20/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/eclipse%E4%B8%ADandroid%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="eclipse中android环境配置"><a href="#eclipse中android环境配置" class="headerlink" title="eclipse中android环境配置"></a>eclipse中android环境配置</h1><h2 id="java环境配置"><a href="#java环境配置" class="headerlink" title="java环境配置"></a>java环境配置</h2><h3 id="java下载"><a href="#java下载" class="headerlink" title="java下载"></a>java下载</h3><p>去<a href="https://www.oracle.com/java/technologies/javase-downloads.html">Oracle官网</a>下载自己需要的java版本</p>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/企业微信截图_16104173834716.png" alt="图片"></p>
<p>我这里选择的是windows的jdk8</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/企业微信截图_16104172348073.png" alt="图片"></p>
<p>ps:下载需要登录自己Oracle账号，注册登录一下就行</p>
<p>下载之后的exe文件双击开，安装到你需要安装的位置即可，我这里安装位置是</p>
<p><code>D:\Program Files\Java\jdk1.8.0_271</code></p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>在系统变量里面加入了变量<code>JAVA_HOME</code>，值为安装的位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210113195035403.png" alt=""></p>
<p>然后在Path里面加入了<code>%JAVA_HOME%\bin</code>和<code>%JAVA_HOME%\jre\bin</code>(这个有待商量)</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210113195354124.png" alt=""></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在cmd当中输入<code>java -version</code>和<code>javac -version</code>查看输出，如果有如下的输出说明配置正确</p>
<p><code>java -version</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java version &quot;1.8.0_271&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_271-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.271-b09, mixed mode)</span><br></pre></td></tr></table></figure>
<p><code>javac -version</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac 1.8.0_271</span><br></pre></td></tr></table></figure>
<h2 id="eclipse下载和配置"><a href="#eclipse下载和配置" class="headerlink" title="eclipse下载和配置"></a>eclipse下载和配置</h2><h3 id="eclipse下载"><a href="#eclipse下载" class="headerlink" title="eclipse下载"></a>eclipse下载</h3><p>去<a href="https://www.eclipse.org/downloads/packages/">官网</a>下载Eclipse IDE for Enterprise Java Developers</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/eclipse/企业微信截图_16107116328073-1610711653956.png" alt=""></p>
<p>ps:下载的时候可能要你捐款什么的，跳过即可</p>
<p>解压完之后是这样的</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/eclipse/企业微信截图_16111073888073.png" alt=""></p>
<p>点击eclipse.exe就能够运行</p>
<h3 id="下载adt"><a href="#下载adt" class="headerlink" title="下载adt"></a>下载adt</h3><p>adt是eclipse里面的Android插件，有这个才能在eclipse里面开发Android</p>
<p>点击<code>Help-&gt;Install New Software</code>,进入安装插件的界面</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/eclipse/image-20210120095351409.png" alt=""></p>
<p>点击<code>Add</code>添加插件地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/eclipse/企业微信截图_16111078194716.png" alt=""></p>
<p>插件我设置名字为<code>ADT</code>,地址为<code>http://dl-ssl.google.com/android/eclipse</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/eclipse/image-20210120095943961.png" alt=""></p>
<p>之后只需要按照安装正常插件的过程一样安装一下就行</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/eclipse/image-20210120100225418.png" alt=""></p>
<p>ps：我已经安装了，所以显示都安装了</p>
<p>安装后可以在<code>About Eclipse IDE</code>上看到</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/eclipse/image-20210120163100705.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/eclipse/image-20210120163135222.png" alt=""></p>
<h2 id="SDK以及工具下载"><a href="#SDK以及工具下载" class="headerlink" title="SDK以及工具下载"></a>SDK以及工具下载</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>我们需要先下载SDK Manager等工具下载sdk，工具下载地址：<a href="https://dl.google.com/android/android-sdk_r24.4.1-windows.zip?utm_source=androiddevtools&amp;utm_medium=website。">https://dl.google.com/android/android-sdk_r24.4.1-windows.zip?utm_source=androiddevtools&amp;utm_medium=website。</a></p>
<p>下载解压之后是这样的</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/eclipse/image-20210120164312559.png" alt=""></p>
<p>双击SDK Manager.exe，对sdk以及相对应的工具进行下载。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/eclipse/image-20210120164715178.png" alt=""></p>
<p>下载完成后我这边多了许多东西</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/eclipse/image-20210120164747825.png" alt=""></p>
<p>ps：网络可能不好，需要换源</p>
<p>需要注意在SDK manager中下载的android SDK Build-tools工具，因为adt不再升级，所以android SDK Build-tools版本不能太高，推荐为24</p>
<h3 id="eclipse上配置"><a href="#eclipse上配置" class="headerlink" title="eclipse上配置"></a>eclipse上配置</h3><p>在Preferences-&gt;Android当中配置一下SDK的位置，浏览选择到我们解压zip的位置就行</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/eclipse/企业微信截图_16111325677086.png" alt=""></p>
<p>ps：SDK用Android Studio其实也可以进行下载，但是不知道为啥eclipse使用不了，可能是不太兼容吧，毕竟adt都不维护了</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用eclipse来编写Android已经过时了，但是有时候我们需要维护以前用eclipse写的代码，所以迫于无奈还是得使用eclipse。所以记一下环境配置，方便后续的维护</p>
]]></content>
      <categories>
        <category>环境配置安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>编程更改镜像总结</title>
    <url>/2021/05/22/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/%E6%9B%B4%E6%94%B9%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="编程更改镜像总结"><a href="#编程更改镜像总结" class="headerlink" title="编程更改镜像总结"></a>编程更改镜像总结</h1><p>在学习编程的过程中，总是会遇到各种各样的网络问题（指包下载的网络问题），所以总结一下这些镜像源的更改，方便自己更快的下载这些包。因为本人电脑是windows系统的，所以注意总结windows系统下的镜像更改。</p>
<span id="more"></span>
<h2 id="python中pip更改镜像源"><a href="#python中pip更改镜像源" class="headerlink" title="python中pip更改镜像源"></a>python中pip更改镜像源</h2><p>pip安装包的时候默认都是从国外安装，网速堪忧，所以一般安装完python，都需要将自己使用的pip源进行更换。</p>
<p>windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini，内容如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<p>其中这个<strong>index-url</strong>的解释是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python软件包索引的基本URL（默认为https://pypi.org/simple）。这应该指向符合PEP 503（简单存储库API）的存储库或以相同格式布置的本地目录。</span><br></pre></td></tr></table></figure>
<p>我看有的博客也会叫再加一个<strong>extra-index-url</strong>参数，但是目前使用来看似乎不太需要。</p>
<p>关于<strong>index-url、extra-index-url</strong>的讲解可以参考<a href="https://pip.pypa.io/en/stable/cli/pip_install/#install-index-url">https://pip.pypa.io/en/stable/cli/pip_install/#install-index-url</a></p>
<p>当然其实也可以不创建该文件，但是需要我们安装的时候加上参数<code>-i</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -i 包名 https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/lambert310/article/details/52412059">https://blog.csdn.net/lambert310/article/details/52412059</a></p>
<h2 id="conda更改镜像源"><a href="#conda更改镜像源" class="headerlink" title="conda更改镜像源"></a>conda更改镜像源</h2><p>参考：<a href="https://blog.csdn.net/weixin_40871455/article/details/90071122">https://blog.csdn.net/weixin_40871455/article/details/90071122</a></p>
<h2 id="maven换源"><a href="#maven换源" class="headerlink" title="maven换源"></a>maven换源</h2><p>maven更改源比较简单。</p>
<ol>
<li><p>找到maven安装目录中的settings.xml</p>
</li>
<li><p>找到 \<mirrors>  &lt;/ mirrors&gt;标签，标签中添加mirror子节点，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一般来说也也需要更改maven下载包的目录，不然他默认下载在c盘当中(我的c盘太小了，还是改改)</p>
<p>找到 \<localRepository> \</localRepository>,将其变成</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\Program Files\MavenRepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="nodejs中npm换源"><a href="#nodejs中npm换源" class="headerlink" title="nodejs中npm换源"></a>nodejs中npm换源</h2><p>一般是更换淘宝的源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>配置后可通过下面方式来验证是否成功</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm config get registry </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>环境配置安装</category>
      </categories>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2023/07/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><span id="more"></span>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ol>
<li>确定分界点（随机取任意一个数为分界点，一般取中点）；</li>
<li>调整区间，把小于<code>x</code>的数移到左边，把大于<code>x</code>的数移到右边，把区间分为<code>[l, j]</code>、<code>[j + 1, r]</code>；</li>
<li>递归左右。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 快速排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = nums[l + (r - l) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span> i++; <span class="keyword">while</span> (nums[i] &lt; x);</span><br><span class="line">		<span class="keyword">do</span> j--; <span class="keyword">while</span> (nums[j] &gt; x);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">QuickSort</span>(nums, l, j);</span><br><span class="line">	<span class="built_in">QuickSort</span>(nums, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ol>
<li>取数组的中间数作为分界点；</li>
<li>将分界点左右两边分别排好序；</li>
<li>将左右两边进行合并。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> mid = l + (r - l) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">MergeSort</span>(nums, l, mid);</span><br><span class="line">	<span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] &lt;= nums[j])</span><br><span class="line">			tmp[k++] = nums[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tmp[k++] = nums[j++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) tmp[k++] = nums[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r) tmp[k++] = nums[j++];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) nums[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对应的题目"><a href="#对应的题目" class="headerlink" title="对应的题目"></a>对应的题目</h2><p><a href="https://leetcode.cn/problems/sort-an-array/submissions/">排序数组</a></p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>acwing算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>实用小软件</title>
    <url>/2021/08/22/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/%E5%AE%9E%E7%94%A8%E5%B0%8F%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="实用小软件"><a href="#实用小软件" class="headerlink" title="实用小软件"></a>实用小软件</h1><p>自己开发或者写文档的时候经常需要使用一些工具软件，在这里记录一下</p>
<span id="more"></span>
<h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>科学上网小工具，人称小飞机基本上是科学上网必须的，下载之后解压直接使用无需安装，非常方便。</p>
<p>下载地址：</p>
<p><a href="https://github.com/shadowsocksr-rm/shadowsocksr-csharp/releases">https://github.com/shadowsocksr-rm/shadowsocksr-csharp/releases</a></p>
<h2 id="Snipaste"><a href="#Snipaste" class="headerlink" title="Snipaste"></a>Snipaste</h2><p>截图小工具，在写文档需要截图的时候就可以使用这个东西，功能感觉和qq上截图功能差不多，但是qq截图没有快捷键，并且复制到剪切板比较复杂，所以多数时候我使用的是这个截图，运行之后F1快捷截图，也是下载解压直接使用无需安装，非常方便。</p>
<p>下载地址：</p>
<p><a href="https://zh.snipaste.com/index.html">https://zh.snipaste.com/index.html</a></p>
<h2 id="ScreenToGif"><a href="#ScreenToGif" class="headerlink" title="ScreenToGif"></a>ScreenToGif</h2><p>录制屏幕的GIF专用工具，有的时候截图并不能很好的表达出操作这个时候使用GIF就很重要了，ScreenToGif是我使用的gif录制小工具，操作简单，并且也是解压直接使用无需安装（当然需要下载portable版本）。</p>
<p>下载地址：</p>
<p><a href="https://www.screentogif.com/">https://www.screentogif.com/</a></p>
<h2 id="OBS-Studio"><a href="#OBS-Studio" class="headerlink" title="OBS Studio"></a>OBS Studio</h2><p>屏幕录制软件，目前没有找到比较好用的屏幕录制软件，这个也算我使用比较习惯的一款吧</p>
<p>这个也有无需要安装的版本，下载zip之后开箱即用</p>
<p>下载地址：</p>
<p><a href="https://obsproject.com/zh-tw">https://obsproject.com/zh-tw</a></p>
<h2 id="v2rayn"><a href="#v2rayn" class="headerlink" title="v2rayn"></a>v2rayn</h2><p>也是科学上网小工具，据说隐蔽性比ssr好，因为协议不一样</p>
<p>官网地址：</p>
<p><a href="https://v2ray.com/">https://v2ray.com/</a></p>
<p>最终需要到github上下载</p>
<h2 id="Clash"><a href="#Clash" class="headerlink" title="Clash"></a>Clash</h2><p>科学上网小工具，有人说是最好的上网工具</p>
<p>讲解地址：</p>
<p><a href="https://docs.cfw.lbyczf.com/">https://docs.cfw.lbyczf.com/</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前就写这么多吧，如果后面有再加上，我安装软件的特点是能直接使用就不安装，所以基本都提议安装便携版本</p>
]]></content>
      <categories>
        <category>环境配置安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>整数二分</title>
    <url>/2023/07/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/2.%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h1 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h1><p>可以划分为满足某种性质与不满足某种性质的两个区间，用二分法可以找到两区间边界的左右两个点。如图中红色和绿色区间，可以通过二分找到这个区间边界。这里需要注意的是利用单调性二分只是其中一种，其他性质其实也可以二分，不过我们掌握单调性进行二分查找就行。<br><span id="more"></span><br><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/算法学习/二分-第 3 页.drawio.png" alt="二分-第 3 页.drawio"></p>
<ol>
<li>寻找红色区域的边界。<ul>
<li>mid = (l+r+1)/2</li>
<li>如果mid在红色区域，[l,r]-&gt;[mid,r]</li>
<li>如果mid不在红色区域，也就是红色右侧的区域，[l,r]-&gt;[l,mid-1]</li>
</ul>
</li>
<li>寻找绿色区域的边界。<ul>
<li>mid = (l+r)/2 </li>
<li>如果mid在绿色区域，[l,r]-&gt;[l,mid] </li>
<li>如果mid不在绿色区域，也就是绿色左侧的区域，[l,r]-&gt;[mid+1,r]</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 二分查找</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用二分查找3的起始位置和终止位置，我可以使用上面的方法进行查找</p>
<p>可以使用bsearch_2查找3的终止位置，条件是<code>x&lt;=3</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/算法学习/二分.drawio.png" alt="二分.drawio"></p>
<p>可以使用bsearch_1查找3的终止位置，条件是<code>x&gt;=3</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/算法学习/二分-第 2 页.drawio.png" alt="二分-第 2 页.drawio"></p>
<h2 id="对应题目"><a href="#对应题目" class="headerlink" title="对应题目"></a>对应题目</h2><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">在排序数组中查找元素的第一个和最后一个位置
</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>())<span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">LeftBound</span>(nums,target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[l]!=target)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">RightBound</span>(nums,target);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对应bsearch_1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LeftBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应bsearch_2</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">RightBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acwing算法学习</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度计算</title>
    <url>/2023/07/03/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/3.%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="高精度计算"><a href="#高精度计算" class="headerlink" title="高精度计算"></a>高精度计算</h1><span id="more"></span>
<h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/ C = A + B, A &gt;= <span class="number">0</span>, B &gt;= <span class="number">0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; <span class="built_in">add</span>(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/add-strings/description/">字符串相加</a></p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acwing算法学习</tag>
        <tag>高精度加法、减法、乘法、除法</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和与差分</title>
    <url>/2023/07/03/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/4.%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h1 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h1><span id="more"></span>
<h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><p><code>a[i]</code> 表示数组中第i个数、<code>s[i]</code>表示为前i个数之和</p>
<ol>
<li><code>s[i] = a[1] + a[2] + ……+ a[i] = s[i-1] + a[i]</code></li>
<li><code>[l, r]</code>区间内数的和：<code>s[r] - s[l-1]</code>（为了当l=1时不需要进行特判。规定s[0]记为0，且读入数组的时候从下标1开始记录）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S[i] = a[1] + a[2] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - 1]</span><br></pre></td></tr></table></figure>
<p>封装一下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一维前缀和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PreSum</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">PreSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; m_preSum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PreSum::<span class="built_in">PreSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	m_preSum.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_preSum[i] = m_preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PreSum::query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m_preSum[right + <span class="number">1</span>] - m_preSum[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p>差分是前缀和的逆运算，简单封装<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Difference</span>(vector&lt;<span class="type">int</span>&gt; nums);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; m_diff;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Difference::<span class="built_in">Difference</span>(vector&lt;<span class="type">int</span>&gt; nums)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">	m_diff.<span class="built_in">resize</span>(size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Difference::increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m_diff[i] += val;</span><br><span class="line">	<span class="keyword">if</span> (j + <span class="number">1</span> &lt; m_diff.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		m_diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Difference::result</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(m_diff.size())</span></span>;</span><br><span class="line">	res[<span class="number">0</span>] = m_diff[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m_diff.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		res[i] = res[i - <span class="number">1</span>] + m_diff[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/range-sum-query-immutable/">前缀和</a></p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acwing算法学习</tag>
        <tag>前缀和与差分</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2023/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/5.%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>这里主要记录一下学习到的位运算算法<br><span id="more"></span></p>
<h2 id="求第k位数字"><a href="#求第k位数字" class="headerlink" title="求第k位数字"></a>求第k位数字</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="返回n的最后一位1"><a href="#返回n的最后一位1" class="headerlink" title="返回n的最后一位1"></a>返回n的最后一位1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lowbit(n) = n &amp; -n，，如101000得1000</span><br></pre></td></tr></table></figure>
<p>这个可能咋看一下不好理解，但是可以推理出来:</p>
<ol>
<li>假设<code>x = 1010...10000</code></li>
<li><code>-x = ~x+1</code></li>
<li><code>~x = 0101...01111</code></li>
<li><code>~x + 1 = 0101...10000</code></li>
<li><code>x &amp; (~x+1) = (1010...10000) &amp; (0101...10000) = 0000...10000</code><br>可以通过上面步骤发现<code>lowbit(n)</code>算法最终取到最后一位1和后面的二进制</li>
</ol>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/number-of-1-bits/description/">位1的个数</a></p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acwing算法学习</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>区间和</title>
    <url>/2023/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/7.%E5%8C%BA%E9%97%B4%E5%92%8C/</url>
    <content><![CDATA[<h1 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h1><p>这个区间和思想和之前的前缀和思想有相同之处，区别在于这个区间和是离散化的，在一个较大的区间中，多数元素为0，少部分有数据，求这部分区间和。<br><span id="more"></span></p>
<ol>
<li>首先取操作涉及的下标，即将要存数字的下标与求和范围两端的下标，存入小数组q中;</li>
<li>对数组q排序;</li>
<li>重新创建一个大小与q相同的数组s，从数组q中找到对应大数组要存入数据的位置映射，在s相同位置存入数据（q中找映射可以用二分法）;</li>
<li>找大数组求和范围两端点在q中的映射位置，在数组s对应映射位置求和即可，可用前缀和.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acwing算法学习</tag>
        <tag>区间和</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/2023/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/6.%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常见问题分类：</p>
<ol>
<li>对于一个序列，用两个指针维护一段区间</li>
<li>对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</li>
</ol>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acwing算法学习</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2023/09/03/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/9.%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><span id="more"></span>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/算法学习/01背包.png" alt="01背包"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;              <span class="comment">// 物品总数</span></span><br><span class="line"><span class="type">int</span> m;              <span class="comment">// 背包容量</span></span><br><span class="line"><span class="type">int</span> W[n<span class="number">+1</span>];           <span class="comment">// 重量 </span></span><br><span class="line"><span class="type">int</span> V[n<span class="number">+1</span>];           <span class="comment">// 价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------二维形式---------------</span></span><br><span class="line"><span class="type">int</span> f[n<span class="number">+1</span>][m<span class="number">+1</span>];    <span class="comment">// f[i][j]表示在考虑前i个物品后，背包容量为j条件下的最大价值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; W[i]) </span><br><span class="line">        <span class="comment">//  当前重量装不进，价值等于前i-1个物品</span></span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];      </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">// 能装，需判断  </span></span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i<span class="number">-1</span>][j-W[i]] + V[i]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[n][m];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------一维形式---------------</span></span><br><span class="line"><span class="type">int</span> f[m<span class="number">+1</span>];   <span class="comment">// f[j]表示背包容量为j条件下的最大价值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = M; j &gt;= W[i]; --j)</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - W[i]] + V[i]);           <span class="comment">// 注意是倒序，否则出现写后读错误</span></span><br><span class="line">cout &lt;&lt; f[m];           <span class="comment">// 注意是m不是n</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.nowcoder.com/questionTerminal/708f0442863a46279cce582c4f508658">牛客01背包</a></p>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><script type="math/tex; mode=display">
f(i,j)=max{f(i−1,j),f(i−1,j−vi)+wi,f(i−1,j−2vi)+2wi,⋯,f(i−1,j−kvi)+kwi}</script><script type="math/tex; mode=display">
f(i,j−vi)=max{f(i−1,j−vi),f(i−1,j−2vi)+wi,f(i−1,j−3vi)+2wi,⋯,f(i−1,j−kvi)+(k−1)wi}</script><script type="math/tex; mode=display">
f(i,j−vi)+wi=max{f(i−1,j−vi)+w,f(i−1,j−2vi)+2wi,f(i−1,j−3vi)+3wi,⋯,f(i−1,j−kvi)+kwi}</script><p>所以</p>
<script type="math/tex; mode=display">
f(i,j)=max{f(i−1,j),f(i,j−vi)+wi}</script><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/算法学习/完全背包.png" alt="完全背包"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;              <span class="comment">// 物品总数</span></span><br><span class="line"><span class="type">int</span> m;              <span class="comment">// 背包容量</span></span><br><span class="line"><span class="type">int</span> W[n<span class="number">+1</span>];           <span class="comment">// 重量 </span></span><br><span class="line"><span class="type">int</span> V[m<span class="number">+1</span>];           <span class="comment">// 价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------二维形式---------------</span></span><br><span class="line"><span class="comment">// 未优化</span></span><br><span class="line"><span class="type">int</span> f[n<span class="number">+1</span>][m<span class="number">+1</span>];    <span class="comment">// f[i][j]表示在考虑前i个物品后，背包容量为j条件下的最大价值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * W[i] &lt;= j; k++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * W[i]] + k * V[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 已优化</span></span><br><span class="line"><span class="type">int</span> f[n<span class="number">+1</span>][m<span class="number">+1</span>];    <span class="comment">// f[i][j]表示在考虑前i个物品后，背包容量为j条件下的最大价值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        <span class="keyword">if</span>(j &lt; W[i]) f[i][j] = f[i<span class="number">-1</span>][j];   <span class="comment">//  当前重量装不进，价值等于前i-1个物品   </span></span><br><span class="line">        <span class="keyword">else</span> f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i][j-W[i]] + V[i]); <span class="comment">// 能装，需判断  </span></span><br><span class="line">cout &lt;&lt; f[n][m];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------一维形式---------------</span></span><br><span class="line"><span class="type">int</span> f[m<span class="number">+1</span>];   <span class="comment">// f[j]表示背包容量为j条件下的最大价值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = W[i]; j &lt;= m; ++j)</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - W[i]] + V[i]);           <span class="comment">// 注意是倒序，否则出现写后读错误</span></span><br><span class="line">cout &lt;&lt; f[m<span class="number">+1</span>];           <span class="comment">// 注意是m不是n</span></span><br></pre></td></tr></table></figure><br><a href="https://www.acwing.com/problem/content/description/3/">完全背包题目</a></p>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>多重背包可以转化为01背包然后使用二进制优化进行优化。<br>朴素做法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;              <span class="comment">// 物品总数</span></span><br><span class="line"><span class="type">int</span> m;              <span class="comment">// 背包容量</span></span><br><span class="line"><span class="type">int</span> W[n<span class="number">+1</span>];           <span class="comment">// 重量 </span></span><br><span class="line"><span class="type">int</span> V[n<span class="number">+1</span>];           <span class="comment">// 价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------未优化（完全背包模板）----------------------</span></span><br><span class="line"><span class="type">int</span> f[n<span class="number">+1</span>][m+!];    <span class="comment">// f[i][j]表示在考虑前i个物品后，背包容量为j条件下的最大价值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= S[i] &amp;&amp; k * W[i] &lt;= j; k++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * W[i]] + k * V[i]);</span><br></pre></td></tr></table></figure><br>二进制优化原理<br>我们用$A_{i,j}$ 代表第 $i$ 种物品拆分出的第 $j$ 个物品。</p>
<p>在朴素的做法中，$\forall j\le k<em>i，A</em>{i,j}$ 均表示相同物品。那么我们效率低的原因主要在于我们进行了大量重复性的工作。举例来说，我们考虑了「同时选 $A<em>{i,1},A</em>{i,2}$」与「同时选 $A<em>{i,2},A</em>{i,3}$」这两个完全等效的情况。这样的重复性工作我们进行了许多次。那么优化拆分方式就成为了解决问题的突破口。<br>具体地说就是令 $A_{i,j}\left(j\in\left[0,\lfloor \log_2(k_i+1)\rfloor-1\right]\right)$ 分别表示由 $2^{j}$ 个单个物品「捆绑」而成的大物品。特殊地，若 $k_i+1$ 不是 2 的整数次幂，则需要在最后添加一个由 $k_i-2^{\lfloor \log_2(k_i+1)\rfloor-1}$ 个单个物品「捆绑」而成的大物品用于补足。<br>举几个例子：<br>6=1+2+3<br>8=1+2+4+1<br>18=1+2+4+8+3<br>31=1+2+4+8+16<br>显然，通过上述拆分方式，可以表示任意 $\le k_i$ 个物品的等效选择方式。将每种物品按照上述方式拆分后，使用 0-1 背包的方法解决即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读入物品个数时顺便打包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 输入 价值、体积、数量</span></span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;      <span class="comment">// 当前包裹大小</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt;= s)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt ++ ;            <span class="comment">// 实际物品种数</span></span><br><span class="line">        W[cnt] = a * k;</span><br><span class="line">        V[cnt] = b * k;</span><br><span class="line">        s -= k;</span><br><span class="line">        k *= <span class="number">2</span>;             <span class="comment">// 倍增包裹大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不足的单独放一个，即C</span></span><br><span class="line">        cnt ++ ;</span><br><span class="line">        W[cnt] = a * s;</span><br><span class="line">        V[cnt] = b * s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">n = cnt;        <span class="comment">// 更新物品种数</span></span><br><span class="line"><span class="comment">// 转换成01背包问题</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= W[i]; j -- )</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - W[i]] + V[i]);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[m] &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><p>起始就是对每个组进行01背包<br>$f(i,j)=max{f(i−1,j),f(i−1,j−v(i,k))+w(i,k)}$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;              <span class="comment">// 物品总数</span></span><br><span class="line"><span class="type">int</span> m;              <span class="comment">// 背包容量</span></span><br><span class="line"><span class="type">int</span> W[n<span class="number">+1</span>][s<span class="number">+1</span>];         <span class="comment">// 重量 </span></span><br><span class="line"><span class="type">int</span> V[n<span class="number">+1</span>][s<span class="number">+1</span>];         <span class="comment">// 价值</span></span><br><span class="line"><span class="type">int</span> S[n<span class="number">+1</span>];           <span class="comment">// 各组物品种数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读入数据</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"> &#123;</span><br><span class="line">     cin &gt;&gt; S[i];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= S[i]; j ++ )</span><br><span class="line">         cin &gt;&gt; W[i][j] &gt;&gt; V[i][j];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">1</span>; j -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= S[i]; k ++ )</span><br><span class="line">            <span class="keyword">if</span> (W[i][k] &lt;= j)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - W[i][k]] + V[i][k]);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[m] &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acwing算法学习</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>区间合并</title>
    <url>/2023/08/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/8.%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><p>给定多个区间，将有重叠的合并到一起<br><span id="more"></span></p>
<ol>
<li>按区间的左端点排序；</li>
<li>从左到右扫描，维护一个当前区间（随着遍历，若相交则区间变长）</li>
<li>每次遍历的区间和当前区间有三种情况分类讨论：<ul>
<li>右端点小于当前区间右端点，当前区间不变；</li>
<li>右端点大于当前区间右端点，当前区间变长；</li>
<li>左端点大于当前区间右端点，将该区间置为当前区间；</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/merge-intervals/description/">合并区间</a></p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acwing算法学习</tag>
        <tag>区间合并</tag>
      </tags>
  </entry>
  <entry>
    <title>Background Suppression Network for Weakly-supervised Temporal Action Localization</title>
    <url>/2021/06/15/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/Background%20Suppression%20Network/</url>
    <content><![CDATA[<h1 id="Background-Suppression-Network-for-Weakly-supervised-Temporal-Action-Localization"><a href="#Background-Suppression-Network-for-Weakly-supervised-Temporal-Action-Localization" class="headerlink" title="Background Suppression Network for Weakly-supervised Temporal Action Localization"></a>Background Suppression Network for Weakly-supervised Temporal Action Localization</h1><h2 id="提出问题："><a href="#提出问题：" class="headerlink" title="提出问题："></a>提出问题：</h2><p>弱监督视频动作定位中，先前的方法聚合帧级别的类分数，以产生视频级别的预测并从视频级别的动作中学习。此方法无法完全模拟问题，因为背景帧被迫错误地分类为行动类别，无法准确预测视频级标签。</p>
<h2 id="做了什么："><a href="#做了什么：" class="headerlink" title="做了什么："></a>做了什么：</h2><p>设计了背景抑制网络（BaSNet），该网络引入了背景的辅助类，并具有带有非对称度量训练策略的两分支权重共享体系结构。这使BaSNet可以抑制来自背景帧的激活，从而提高定位性能。广泛的实验证明了BaSNet的效率及其在最流行的基准THUMOS14和ActivityNet上优于最新方法的优越性</p>
<p>BaSNet：有两条分支Base branch and Suppression branch<br><span id="more"></span></p>
<h2 id="怎么做的："><a href="#怎么做的：" class="headerlink" title="怎么做的："></a>怎么做的：</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Background Suppression Network for Weakly-supervised Temporal Action Localization/image-20210411104708142.png" alt="image-20210411104708142"></p>
<ol>
<li>Suppression分支包含一个过滤模块，该模块学习过滤出背景帧以最终抑制CAS中来自它们的激活</li>
<li>他们的培训目标是不同的。 Base分支的目的是将插入视频分类为其原始动作类和背景类的样本。另一方面，训练带有过滤模块的Suppression分支以最小化背景类得分，而背景类得分与原始动作类的目标相同。权重共享策略可以防止分支在给出相同输入时同时满足其两个目标。因此，过滤模块是解决背景的唯一关键，并且经过培训可以抑制来自背景框架的激活，从而同时实现两个目标。这减少了背景帧的干扰并提高了动作定位性能</li>
</ol>
<h3 id="特征提取："><a href="#特征提取：" class="headerlink" title="特征提取："></a>特征提取：</h3><p>由于存储器限制，我们首先将每个输入视频$v<em>n$分成16帧不重叠的$L_n$段，即$v_n = {S</em>{n,l} }^{Ln}<em>{l = 1}$。为了应对视频长度的较大变化，我们从每个视频中采样了固定数量的T段。然后，我们将采样的RGB和flow分段输入到预训练的特征提取器中，以分别生成$F$维的特征向量$x</em>{n,t}^{RGB}$和$x<em>{n,t}^{flow}$。然后，将RGB和flow特征连接起来以构建完整的特征$x</em>{n,t}$，然后将它们沿着时间维度堆叠以形成长度为T的特征图,即$X<em>n=[x</em>{n,1},…,x_{n,T}]$</p>
<p><strong>小结：</strong>这一步就是普通的特征提取，提取RGB和flow光流特征，然后将它们连接一下比较简单。</p>
<h3 id="Base-branch"><a href="#Base-branch" class="headerlink" title="Base branch"></a>Base branch</h3><p>为了预测线段级别的类别得分，我们通过将特征图馈送到时间一维卷积层中来生成CAS （类激活序列），其中每个线段都有其类别得分，反应了对应类别的概率。对于视频$v_n$，可以将其形式化如下:</p>
<script type="math/tex; mode=display">
A_n=f_{conv}(X_n,\phi)</script><p>其中$\phi$表示卷积层中的可训练参数，$A_n\in R^{(C+1)\times T}$。一个$C+1$尺寸是因为我们使用C动作类和一个辅助类作为背景。</p>
<p>接着使用top-k均值技术，可以如下得出视频vn的c类的视频级类评分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Background Suppression Network for Weakly-supervised Temporal Action Localization/image-20210411151544441.png" alt="image-20210411151544441"></p>
<p>然后，通过沿类别维度应用softmax函数，将视频级别的类别得分用于预测每个类别的样本的概率：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Background Suppression Network for Weakly-supervised Temporal Action Localization/image-20210411151640191.png" alt="image-20210411151640191"></p>
<p>为了训练网络，我们为每个类别定义一个具有二进制交叉熵损失的损失函数$L_{base}$</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Background Suppression Network for Weakly-supervised Temporal Action Localization/image-20210411151931573.png" alt="image-20210411151931573"></p>
<p>其中$y^{base}<em>n=[y</em>{n;1},…,y_{n;C},1]^T\in \mathbb R^{C+1}$,其中最后一个1是背景类，因为基础分支没有去除背景所以设置为1这和后面的抑制分支想对应。</p>
<p><strong>小结：</strong>可以知道Base branch只是简单的进行训练，默认是有背景类的。</p>
<h3 id="Suppression-branch"><a href="#Suppression-branch" class="headerlink" title="Suppression branch"></a>Suppression branch</h3><p>与Base分支不同，Suppression分支在其前面包含一个过滤模块，该模块被针对背景类的相反的训练目标训练为抑制背景帧。过滤模块由两个时间一维卷积层和随后的S型函数组成。过滤模块的输出是前景权重$W_n∈R^T$，范围从0到1。来自过滤模块的前景权重在时间维度上与特征图相乘以过滤出背景帧。此步骤可以表示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Background Suppression Network for Weakly-supervised Temporal Action Localization/image-20210411153148668.png" alt="image-20210411153148668"></p>
<p>接着的话和前面Base 分支的训练类似，只是将$\acute{X}_n$ 代替$X_n$</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Background Suppression Network for Weakly-supervised Temporal Action Localization/image-20210413103100493.png" alt="image-20210413103100493"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Background Suppression Network for Weakly-supervised Temporal Action Localization/image-20210413103610515.png" alt="image-20210413103610515"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Background Suppression Network for Weakly-supervised Temporal Action Localization/image-20210413103127374.png" alt="image-20210413103127374"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Background Suppression Network for Weakly-supervised Temporal Action Localization/image-20210413103139512.png" alt="image-20210413103139512"></p>
<p>其中$y^{supp}<em>n=[y</em>{n;1},…,y_{n;C},0]^T\in \mathbb R^{C+1}$,其中最后一个1是背景类，因为基础分支没有去除背景所以设置为0，因为抑制分支经过了前面的过滤模块，默认是过滤掉背景。</p>
<p><strong>小结：</strong>抑制分支设置背景类为0，目的就是训练过滤模块，他们俩共享了前面的一维权重，但是最终一个有背景一个没有背景，两个分支的区别就在于过滤模块，这也是所谓的非对称共享权重训练。</p>
<h3 id="Joint-training"><a href="#Joint-training" class="headerlink" title="Joint training"></a>Joint training</h3><p>我们联合训练base分支和Suppression 分支。我们需要优化的总体损失函数如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Background Suppression Network for Weakly-supervised Temporal Action Localization/image-20210411154052601.png" alt="image-20210411154052601"></p>
<p>前两个在上面已经介绍了，而$L_{norm}$:</p>
<script type="math/tex; mode=display">
L_{norm}=\frac{1}{N}\sum_{n=1}^N|w_n|</script><p>这个其实对训练的过滤模块权重进行$L_1$正则，目的是使得权重更加偏向0或者1，简单理解就是背景帧就是0进行抑制，动作帧就是1不受影响。术语就是更好的识别关键帧</p>
<p><strong>小结：</strong>这个$L_{norm}$的设计还是比较巧妙，可能也是我接触比较少</p>
<h3 id="Classification-and-Localization"><a href="#Classification-and-Localization" class="headerlink" title="Classification and Localization"></a>Classification and Localization</h3><p>在描述了我们的模型是如何配置和训练的之后，我们转向讨论它在测试时如何工作。由于我们使用过滤模块阻止来自背景框架的激活，因此使用Suppression分支的输出进行推理是合理的。对于分类，我们丢弃在概率低于阈值$\theta<em>{class}$的类。然后，对于其余类别，我们使用阈值$\theta</em>{act}$对CAS进行阈值选择候选片段。然后，每组连续的候选段将成为一个建议。我们根据最近的工作，使用内部和外部区域之间的对比来计算每个建议的置信度得分。</p>
<p><strong>小结：</strong>这个分类和定位比较平常 ，不多介绍</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这篇<code>Background Suppression Network for Weakly-supervised Temporal Action Localization</code>还真的在设计上就十分巧妙，两个分支一个训练有背景，一个训练却没有背景，两个分支的不同之处就只有过滤模块，所以说明了过滤模块的作用。最终的话使用过滤分支输出的概率和CAS来进行定位也是比较合理。</p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>时序动作定位</tag>
        <tag>弱监督</tag>
      </tags>
  </entry>
  <entry>
    <title>Background-Click Supervision for Temporal Action Localization</title>
    <url>/2022/04/29/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/Background-Click%20Supervision%20for%20Temporal%20Action%20Localization/</url>
    <content><![CDATA[<h1 id="Background-Click-Supervision-for-Temporal-Action-Localization"><a href="#Background-Click-Supervision-for-Temporal-Action-Localization" class="headerlink" title="Background-Click Supervision for Temporal Action Localization"></a>Background-Click Supervision for Temporal Action Localization</h1><h2 id="论文简介"><a href="#论文简介" class="headerlink" title="论文简介"></a>论文简介</h2><p>BackTAL是2021年发表在IEEE上一篇关于弱监督时序定位的文章。论文的作者如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429192856464.png" alt="image-20220429192856464"></p>
<p>论文地址：<a href="https://github.com/VividLe/BackTAL">https://github.com/VividLe/BackTAL</a></p>
<p>B站观看网站：<a href="https://www.bilibili.com/video/BV1oL4y1T7eL/">https://www.bilibili.com/video/BV1oL4y1T7eL/</a></p>
<span id="more"></span>
<h2 id="论文动机"><a href="#论文动机" class="headerlink" title="论文动机"></a>论文动机</h2><p>目前<strong>弱监督</strong>时间动作定位遵循着一个潜在的假设，视频片段能够为video-level级别分类提供更多证据，尤其是动作，为video-level分类贡献更多。但是，有论文指出当背景片段与video-level更相关时，在此假设下开发的算法会陷入动作-上下文混淆困境。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429193155150.png" alt="image-20220429193155150"></p>
<p>论文还分析了一下</p>
<p>1.定位错误的原因，主要的错误来自背景的误差。</p>
<p>2.给定特定的CAS，top-k帧中大部分为动作</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429193303489.png" alt="image-20220429193303489"></p>
<h2 id="论文框架"><a href="#论文框架" class="headerlink" title="论文框架"></a>论文框架</h2><p>模型总体框架如下，框架重要的部分分别为Affinity Module和Score Separation Module</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429193353467.png" alt="image-20220429193353467"></p>
<p>BackTAL使用三个时间卷积层来处理视频特征序列。输入视频特征$X$，获得类激活序列$S\in \mathbb R^{(C+1)\times T}$，接着使用top-k均值的方法获得视频级分类得分$s_v^c$</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429194200422.png" alt="image-20220429194200422"></p>
<p>因为有背景click-level的信息，所以拥有帧级别的监督信息，可以对带注释的背景帧进行监督分类，以提高类激活序列S的质量。</p>
<p>考虑背景标签$b_t=1$的帧，这个帧的分类分数$S[:,t]∈R^{(C+1)×1}$,使用softmax得到$\hat{S}_t=[\hat{s}_t^0,\hat{s}_t^1,…,\hat{s}_t^c]$</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429194825636.png" alt="image-20220429194825636"></p>
<h3 id="Score-Separation-Module"><a href="#Score-Separation-Module" class="headerlink" title="Score Separation Module"></a><strong>Score Separation Module</strong></h3><p>在使用top-k均值方法中，训练后期的模型总是趋向于选择相似的top-k的位置。并且对于动作和背景混淆的部分，分数也会偏高，不能很好的将背景和前景进行分离。像下图图b中红色箭头和黄色箭头所展示的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429194858571.png" alt="image-20220429194858571"></p>
<p>给定一个包含$c^{th}$ 类别动作的视频，将top-k分数作为潜在动作，并计算平均分数</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429203658216.png" alt="image-20220429203658216"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220509163603985.png" alt="image-20220509163603985"></p>
<p>同样的，对于该视频中N_frame 注释的背景帧，计算平均分数</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429203725159.png" alt="image-20220429203725159"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429203737728.png" alt="image-20220429203737728"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429204251346.png" alt="image-20220429204251346"></p>
<h3 id="Affinity-Module"><a href="#Affinity-Module" class="headerlink" title="Affinity Module"></a><strong>Affinity Module</strong></h3><p>Affinity Module主要基于带注释的背景帧和潜在的动作帧，充分挖掘其中的特征信息。在Affinity Module考虑到特定的一帧，可以度量它和相邻帧的亲和度，得到一帧特定的注意力权重，形成局部注意力掩码，并将其注入到卷积计算过程中。特定帧的关注权值可以引导卷积过程动态关注相关的邻居，从而产生更精确的响应。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429204310948.png" alt="image-20220429204310948"></p>
<p>在affinity模块中，首先学习了一个嵌入空间，以从背景中区分与类无关的动作。$E=[e<em>1,e_2,…,e_T]$，其中$e_t∈R^{D</em>{emb}}$ ，其中每个向量$e_t$都经过L2正则对于任意两个嵌入向量，可以计算两个向量的相似度</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429204322516.png" alt="image-20220429204322516"></p>
<p>基于标注的背景帧和潜在的动作帧，可以计算两个背景帧之间、两个动作帧之间、动作和背景之间三个项的亲和力损失</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429204415269.png" alt="image-20220429204415269"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429204428626.png" alt="image-20220429204428626"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429204436799.png" alt="image-20220429204436799"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429204445755.png" alt="image-20220429204445755"></p>
<p>度量一帧与它的局部邻居之间的余弦相似度，嵌入向量可以区分动作帧和背景帧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429204546840.png" alt="image-20220429204546840"></p>
<p>考虑一个视频特征$X\in\mathbb R^{D<em>{in}\times T}$可以使用卷积核$H∈R^{h×D</em>{in}×D_{out}}$ 进行处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429205955081.png" alt="image-20220429205955081"></p>
<p>给定一个视频，我们计算每个时间位置的局部相似度，得到亲和力矩阵$a∈R^{h×T}$</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429210028440.png" alt="image-20220429210028440"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429210037452.png" alt="image-20220429210037452"></p>
<h3 id="total-loss"><a href="#total-loss" class="headerlink" title="total loss"></a>total loss</h3><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220429210124173.png" alt="image-20220429210124173"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>论文对于click-level，将之前关注于action-click聚集到了backgroud-click上，并提出了弱监督时间动作定位的BackTAL方法。并且提出了自己的挖掘位置信息和特征信息的方法，很好的缓解了动作边界混淆的问题。</p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>时序动作定位</tag>
        <tag>弱监督</tag>
      </tags>
  </entry>
  <entry>
    <title>CoLA Weakly-Supervised Temporal Action Localization with Snippet Contrastive Learning</title>
    <url>/2021/09/11/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/CoLA%20Weakly-Supervised%20Temporal%20Action%20Localization%20with%20Snippet%20Contrastive%20Learning/</url>
    <content><![CDATA[<h1 id="CoLA-Weakly-Supervised-Temporal-Action-Localization-with-Snippet-Contrastive-Learning"><a href="#CoLA-Weakly-Supervised-Temporal-Action-Localization-with-Snippet-Contrastive-Learning" class="headerlink" title="CoLA Weakly-Supervised Temporal Action Localization with Snippet Contrastive Learning"></a>CoLA Weakly-Supervised Temporal Action Localization with Snippet Contrastive Learning</h1><h2 id="提出问题："><a href="#提出问题：" class="headerlink" title="提出问题："></a>提出问题：</h2><p>弱监督时间动作定位（WSTAL）的目的是只通过视频级别的标签，对未裁剪的视频进行动作定位。目前存在的模型大都是遵循“localization by classification”的过程，定位对视频级别分类贡献最大的时间区域，一般来说，它们单独处理每个片段(或帧)，因此忽略了有效的时间上下文关系</p>
<h2 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h2><ul>
<li>提出利用视频片段对比学习来实现动作定位</li>
<li>提出了一个Snippet Contrast (SniCo) Loss来从特征空间中hard snippet的表示，它指导网络感知精确的时间边界，避免时间间隔中断。</li>
<li>由于没有办法访问帧级别的注释，引入了一种hard snippet挖掘算法，来定位潜在的hard snippet（这里的hard snippet可以理解为在背景和动作过渡区域的snippet，具有比较强的欺骗性）。</li>
</ul>
<span id="more"></span>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220414193438015.png" alt="image-20220414193438015"></p>
<p>论文的动机可以从图中看出，由于缺乏帧级别的标签，上图中<strong>#2</strong>和<strong>#3</strong>这两个片段很难进行分类，如果只是使用baseline，我们会发现<strong>#2</strong>被识别为背景，而<strong>#3</strong>被识别为动作，这和GT是相违背。但是我们发现在这些片段中<strong>#1</strong>是很容易分类成动作（论文称这很容易识别的动作片段为easy action），而<strong>#4</strong>很容易分类背景（论文里面称为easy bkg），我们将<strong>#2</strong>和<strong>#1</strong>进行对比很容易发现<strong>#2</strong>是个动作，<strong>#3</strong>和<strong>#4</strong>对比很容易发现是背景，通过这种对比的思想就提出了这篇论文的模型。论文中将类型<strong>#2</strong>和<strong>#3</strong>的片段成为hard snippets，因为他们都是“cheating”的</p>
<p>论文的模型如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210912195346687.png" alt="image-20210912195346687"></p>
<h3 id="Feature-Extraction-and-Embedding"><a href="#Feature-Extraction-and-Embedding" class="headerlink" title="Feature Extraction and Embedding"></a>Feature Extraction and Embedding</h3><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210913192458877.png" alt="image-20210913192458877"></p>
<p>给定$N$个未裁剪的视频$\lbrace{V<em>n}\rbrace^N</em>{n=1}$和它们视频级别的标签 $\lbrace y<em>n\rbrace^N</em>{n=1}$ ，其中 $y_n\in \mathbb R^C $ ，$C$是动作类别的数量</p>
<p>对于每个视频$V<em>n$，我们把它分成多帧不重叠的$L_n$片段，其中$V_n=\lbrace S</em>{n,l}\rbrace^{L<em>n}</em>{l=1}$，由于视频长度的变化，利用采样，固定视频为数量$T$的片段$\lbrace S<em>{n,t}\rbrace^T</em>{t=1}$（采样的方法很常见，也是正常的方法）。</p>
<p>接着提取RGB特征$X<em>n^R=\lbrace x_t^R \rbrace^T</em>{t=1}$和flow特征$X<em>n^O=\lbrace x_t^O \rbrace^T</em>{t=1}$，其中$x^R_t \in \mathbb R^d$和$x^O_t \in \mathbb R^d$,$d$是每个片段的特性维度。</p>
<p>我们使用函数$f_{embed}$，将$X_n^R$和$X_n^O$连接起来，获取我们所提取的特征$X_n^E \in \mathbb R^{T \times 2d}$</p>
<p>$f_{embed}$通过时间卷积和ReLU激活函数实现。</p>
<h3 id="Actionness-Modeling"><a href="#Actionness-Modeling" class="headerlink" title="Actionness Modeling"></a>Actionness Modeling</h3><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210913192542486.png" alt="image-20210913192542486"></p>
<p>给定特征$X<em>n^E$  ,利用   $f</em>{cls}$获得类激活序列即CAS（在论文当中叫T-CAS，其实概念是相同的）</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210913192823389.png" alt="image-20210913192823389"></p>
<p>我们简单地沿着通道维度(fsum)加上Sigmoid函数对CAS进行求和，以获得一个类不可知的聚合，并使用它来表示动作</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210913193042814.png" alt="image-20210913193042814"></p>
<p>其中$A_n^{ness}\in\mathbb R^T$</p>
<h3 id="Hard-amp-Easy-Snippet-Mining"><a href="#Hard-amp-Easy-Snippet-Mining" class="headerlink" title="Hard &amp; Easy Snippet Mining"></a>Hard &amp; Easy Snippet Mining</h3><p>这一块是论文的创新点，主要挖掘论文当中Hard和Easy片段</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210913193628164.png" alt="image-20210913193628164"></p>
<h4 id="Hard-Snippet-Mining"><a href="#Hard-Snippet-Mining" class="headerlink" title="Hard Snippet Mining"></a>Hard Snippet Mining</h4><p>hard Snippet 指那种边界相邻的片段，由于它们位于动作和背景之间的过渡区域，因此可靠性较差，从而导致检测模糊。所以hard snippet是可以进行挖掘，以得到更好的判决。在论文中构建了一种新的硬片段挖掘算法来挖掘边界区域的硬片段。</p>
<p>首先，我们对动作评分进行阈值，以生成一个二进制序列(1或0分别表示动作或背景位置):</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210913194552618.png" alt="image-20210913194552618"></p>
<p>其中$\epsilon(\cdot )$是一个heaviside跃阶函数，其中$\theta_b$是阈值，如果$A_n^{ness}\geq\theta_b$，则$A_n^{bin}=1$,反之则为0</p>
<p>接着我们采取两种级联的扩张或者变窄操作（这个操作在语义分割动作有所使用），来扩大或缩小动作间隔的时间范围，将扩张和变窄程度不同的不同区域定义为硬背景（hard background）或者硬动作（hard action）区域。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210913195927059.png" alt="image-20210913195927059"></p>
<p>其中(·;∗)+和(·;∗)−分别表示mask∗下的二元扩张和变窄操作。这个些个操作类似卷积，作用是挖掘出hard的片段。</p>
<p>内部区域$R_n^{inner}$定义为mask较小m和mask较大的M变窄序列之间的不同片段的差值，如图3左边部分(绿色部分)所示。</p>
<p>同样，外部的$R_n^{outer}$计算为mask大掩码M和小掩码m之间的差值，如图3右侧部分(粉红色)所示。</p>
<p>经验上，我们考虑内部区域硬动作片段集，因为这些区域是$A_n^{bin}$= 1。同理外部区域被认为是硬背景代码片段集。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210913201417966.png" alt="image-20210913201417966"></p>
<p>接着定义hard action snippets，$X_n^{HA}\in \mathbb R^{k^{hard}\times 2d}$，从$R_n^{inner}$中挑选出来</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210914204708488.png" alt="image-20210914204708488"></p>
<p>其中$I_n^{inner}$是$R_n^{inner}$内的代码片段的索引集，$I_n^{act}$是$I_n^{inner}$中大小为$k^{hard}$的子集，即$\lvert I_n^{act} \rvert=k^{hard}$。其中$k^{hard}$是一个超参，简单理解就是找了$k^{hard}$个hard action片段</p>
<p>同理可以得到 hard background snippets</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210914205334459.png" alt="image-20210914205334459"></p>
<p>我们可以这样理解图3，对于左侧的图，我们先拿卷积核为3的神经元去移动，当3个位置都为1时（都为动作时），才把中心位置标为1，然后卷积核为6的神经元去移动，当6个位置都为1时才把中心位置标为1，显然卷积核为6的神经元比较严格看的更远，他减去卷积为3移动完的数据剩下的就是不是那么严格的位置，所以把这些位置作为hard snippet。</p>
<h4 id="Easy-Snippet-Mining"><a href="#Easy-Snippet-Mining" class="headerlink" title="Easy Snippet Mining"></a>Easy Snippet Mining</h4><p>为了形成对比对，我们仍然需要挖掘具有区别性的简单片段</p>
<p>我们假设动作度得分为top-k和bottom-k的视频片段恰好是easy action 片段($X_n^{EA}\in \mathbb R^{k^{easy}\times 2d}$)和easy background  片段 ($X_n^{EB}\in \mathbb R^{k^{easy}\times 2d}$)，可以理解为选取了k个容易区分的片段</p>
<p>我们基于前面计算的动作评分$A_n^{ness}$进行简单的代码片段挖掘。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210914210005061.png" alt="image-20210914210005061"></p>
<p>其中$S_n^{DESC}$和$S_n^{ASC}$分别为$A_n^{ness}$按照降序和升序排列的索引。基本理解和前面一样。</p>
<h3 id="Network-Training"><a href="#Network-Training" class="headerlink" title="Network Training"></a>Network Training</h3><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210915151007435.png" alt="image-20210915151007435"></p>
<p>在挖掘hard和easy片段的基础上，我们的CoLA引入了额外的片段对比(SniCo)损失($L_s$)，与基线模型相比取得了相当大的改进。全损可以表示为:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210915111910708.png" alt="image-20210915111910708"></p>
<p>其中$L_a$和$L_s$分别表示动作损失和SniCo损失。$\lambda$是平衡因子。我们将对这两个术语作如下阐述。</p>
<h4 id="Action-Loss"><a href="#Action-Loss" class="headerlink" title="Action Loss"></a>Action Loss</h4><p>Action Loss（$L_a$）预测的视频类别与真实值之间的分类损失。为了获得视频级预测，我们聚合片段级别的类别分数(CAS)，即$A_n$</p>
<p>然后采取top-k均值方法，对于每个类别$c$，我们取具有最大的类特定CAS值的$K^{easy}$项，并计算它们的平均值$a<em>{n;c}$，即video $V_n$的class $c$的视频级类得分。在获得所有类的$a</em>{n;c}$之后，我们在类维上应用Softmax函数得到视频级类的概率$p_n \in \mathbb R^C$</p>
<p>Action Loss（$L_a$）使用交叉熵损失</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210915113148418.png" alt="image-20210915113148418"></p>
<h4 id="Snippet-Contrast-SniCo-Loss"><a href="#Snippet-Contrast-SniCo-Loss" class="headerlink" title="Snippet Contrast (SniCo) Loss"></a>Snippet Contrast (SniCo) Loss</h4><p>对比学习已经被用于图像或者补丁级别。对于本次论文，给定特征$X_n^E$，对比学习应用于代码片段级别。在论文中将这种命名为snippet Contrast (SniCo)Loss ($L_s$)，目的是细化hard 片段，因为有hard action和hard background两个对比，所以我们分为“HA refinement” and “HB refinement”</p>
<p>查询$x\in \mathbb R^{1\times2d}$，positive $x^+ \in \mathbb R^{1\times 2d}$和$S$消极$x^-\in \mathbb R^{S\times 2d}$均从预挖掘片段中选取</p>
<p>对于“HA refinement”</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210915161615227.png" alt="image-20210915161615227"></p>
<p>对于“HB refinement”</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210915161743980.png" alt="image-20210915161743980"></p>
<p>我们将它们投射到一个标准化的单位球体上，以防止空间坍塌或膨胀(没怎么看懂)，不过这其实是一个简单对比学习。</p>
<p>建立了一个(S+ 1)分类问题，利用交叉熵损失来表示正例比负例被选择的概率</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210915162133500.png" alt="image-20210915162133500"></p>
<p>其中$\tau$是一个超参，而$x^T$为$x$的转置，建议SniCo损失如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210915162339793.png" alt="image-20210915162339793"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文思路不错，直接从以前WTAL中使用比较多的度量学习直接进入到对比学习，算是一种进步。</p>
<p>图像的 eroded和dilated操作可以看：</p>
<p><a href="https://segmentfault.com/a/1190000004048075">https://segmentfault.com/a/1190000004048075</a></p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>时序动作定位</tag>
        <tag>对比学习</tag>
      </tags>
  </entry>
  <entry>
    <title>CvT:Introducing Convolutions to Vision Transformers</title>
    <url>/2021/11/05/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/CvT%20Introducing%20Convolutions%20to%20Vision%20Transformers/</url>
    <content><![CDATA[<h1 id="CvT-Introducing-Convolutions-to-Vision-Transformers"><a href="#CvT-Introducing-Convolutions-to-Vision-Transformers" class="headerlink" title="CvT:Introducing Convolutions to Vision Transformers"></a>CvT:Introducing Convolutions to Vision Transformers</h1><h2 id="论文简介"><a href="#论文简介" class="headerlink" title="论文简介"></a>论文简介</h2><p>CvT是发表在ICCV上的一篇文章，主要团队是来自麦吉尔大学, 微软云+AI。论文的主要工作是将卷积<strong>CNN</strong>模型引入<strong>Transformer模型</strong>中来产生两种设计的最佳效果，从而提高了视觉Transformer（ViT）的性能和效率</p>
<p>下面图展示的是团队成员：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211121210127584.png" alt="image-20211121210127584"></p>
<span id="more"></span>
<h2 id="思路和研究方法"><a href="#思路和研究方法" class="headerlink" title="思路和研究方法"></a>思路和研究方法</h2><h3 id="ViT模型"><a href="#ViT模型" class="headerlink" title="ViT模型"></a>ViT模型</h3><p>ViT模型通过将图片进行分块和降维，然后再送入到transformer中，实现了对图像进行分类。</p>
<p><strong>缺点：</strong>ViT在小样本上，性能低于类似规模的CNN网络</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121210228422.png" alt="image-20211121210228422"></p>
<h3 id="Convolutional-vision-Transformer"><a href="#Convolutional-vision-Transformer" class="headerlink" title="Convolutional vision Transformer"></a>Convolutional vision Transformer</h3><p>本文提出了卷积视觉Transformer（CvT），设计了两个操作：<strong>Convolutional Token Embedding</strong>和<strong>Convolutional Projection</strong>，使得整个网络结构同时具备了卷积和Transformer的特点，去除了位置编码embedding，简化了网络设计。</p>
<p>论文比较了一下CvT、ViT、BiT的参数，相同参数量下CvT模型准确度最高，如下图展示</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121210310100.png" alt="image-20211121210310100"></p>
<p>本文的网络模型如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121210447006.png" alt="image-20211121210447006"></p>
<h3 id="Convolutional-Token-Embedding"><a href="#Convolutional-Token-Embedding" class="headerlink" title="Convolutional Token Embedding"></a>Convolutional Token Embedding</h3><p>给定一个2D的image或者一个来自上一层的2D-reshaped输出$x<em>i\in \mathbb R^{H</em>{i-1}\times W<em>{i_1}\times C</em>{i-1}}$作为输入，学习一个函数$f(*)$，把输入$x<em>{i-1}$映射到一个新的token$f(x</em>{i-1}\in \mathbb R^{H_i\times W_i \times C_i})$，它的高和宽如下（其中卷积核大大小为$s\times s$，步长为$s-o$，padding为$p$）</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121211053382.png" alt="image-20211121211053382"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121211100484.png" alt="image-20211121211100484"></p>
<p>之后得到的$f(x_{i-1} )$会被<strong>flatten</strong>到$H_i W_i×C_i$ ，并进行Layer Normalization操作，得到的结果会进入下面的的第i个stage的Transformer Block的操作。</p>
<p>Convolutional Token Embedding允许我们通过使用不同的卷积参数，调整token feature dimension 和每一阶段的token数量。以该方式，我们渐渐减少token sequence length，同时增加token feature dimension。这使得token能够以增加更大的空间，去表征增加的复杂视觉模式。</p>
<h3 id="Convolutional-Projection-for-Attention"><a href="#Convolutional-Projection-for-Attention" class="headerlink" title="Convolutional Projection for Attention"></a><strong>Convolutional Projection for Attention</strong></h3><p>Convolutional Projection 层主要目标是实现额外的局部上下文建模，和提供高效的K，V矩阵采样方式。</p>
<p>从根本上来说，本文提出的带有Convolutional Projection 的Transformer block是原始Transformer block的一般化表示。因为先前的工作都是尝试在Transformer block 上添加额外的卷积模块，这增加了额外的计算代价。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121211243532.png" alt="image-20211121211243532"></p>
<p>简单理解就是把普通Transformer的Block中的Linear Projection操作换成了Convolutional Projection操作，我们提出用深度可分卷积代替多头自注意(MHSA)的位置线性投影，形成卷积投影层。如下图所示为ViT中使用的Linear projection操作，采用的是线性的映射</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121211357005.png" alt="image-20211121211357005"></p>
<p>如下图所示为CvT中使用的Convolutional Projection操作，采用的是卷积变换。</p>
<p>具体来讲，token首先reshape成2D的token map，再分别通过3个Depthwise-separable Convolution(kernel=s×s)变成query，key和value值。最后再把这些query，key和value值通过flatten操作得到真正的query，key和value值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121211426548.png" alt="image-20211121211426548"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121211432397.png" alt="image-20211121211432397"></p>
<p>其中的<strong>Conv2d</strong>是个Depthwise-separable Convolution的复合操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121211452115.png" alt="image-20211121211452115"></p>
<h4 id="Depthwise-Separable-Convolution"><a href="#Depthwise-Separable-Convolution" class="headerlink" title="Depthwise Separable Convolution"></a><strong>Depthwise</strong> <strong>Separable Convolution</strong></h4><p><strong>常规卷积运算：</strong>假设输入层为一个大小为64×64像素、三通道彩色图片。经过一个包含4个Filter的卷积层，最终输出4个Feature Map，且尺寸与输入层相同。整个过程可以用下图来概括。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121211524088.png" alt="image-20211121211524088"></p>
<p><strong>Depthwise</strong> <strong>Convolution</strong>：一个大小为64×64像素、三通道彩色图片首先经过第一次卷积运算，不同之处在于此次的卷积完全是在二维平面内进行，且Filter的数量与上一层的Depth相同。</p>
<p><strong>缺点：</strong>运算对输入层的每个channel独立进行卷积运算后就结束，没有有效的利用不同map在相同空间位置上的信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121211540006.png" alt="image-20211121211540006"></p>
<p><strong>Pointwise Convolution</strong>：Pointwise Convolution的运算与常规卷积运算非常相似，不同之处在于卷积核的尺寸为 1×1×M，M为上一层的depth。所以这里的卷积运算会将上一步的map在深度方向上进行加权组合，生成新的Feature map。有几个Filter就有几个Feature map。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121211606550.png" alt="image-20211121211606550"></p>
<p><strong>参数对比：</strong></p>
<p>常规卷积的参数个数为：</p>
<script type="math/tex; mode=display">
N_{std} = 4 × 3 × 3 × 3 = 108</script><p>Separable Convolution的参数由两部分相加得到：</p>
<script type="math/tex; mode=display">
N_{depthwise}=3×3×3=27</script><script type="math/tex; mode=display">
N_{pointwise}=1×1×3×4=12</script><script type="math/tex; mode=display">
N_{separable}=N_{depthwise}+N_{pointwise}=39</script><p>相同的输入，同样是得到4张Feature map，Separable Convolution的参数个数是常规卷积的约1/3。因此，在参数量相同的前提下，采用Separable Convolution的神经网络层数可以做的更深。</p>
<h3 id="Efficiency-Considerations"><a href="#Efficiency-Considerations" class="headerlink" title="Efficiency Considerations"></a><strong>Efficiency Considerations</strong></h3><p>对于常规的Convolution所需的参数量和计算量分别是 $s^2 C^2$和$o(s^2 C^2 T)$，</p>
<p>如果是Depthwise-separable Convolution所需的参数量和计算量分别是$s^2 C$和$o(s^2 CT)$</p>
<p>其中C是token的channel dimension，T是token的数量。</p>
<p>除此之外，为了使得模型进一步简化，作者又提出了如图所示的Squeezed convolutional projection操作。</p>
<p>作者在计算query时，采用的Depthwise-separable Convolution的stride值为1。在计算key和value时，采用的Depthwise-separable Convolution的stride值为2。如下图所示。按照这种方式，token的数量对于key和value来说可以减少4倍，性能只有很少的下降。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121211952118.png" alt="image-20211121211952118"></p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><strong>数据集：</strong>ImageNet-1k (1.3M images)，ImageNet (14M images，22k类)，CIFAR-10/100，Oxford-IIIT-Pet，Oxford-IIIT-Flower。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121212018071.png" alt="image-20211121212018071"></p>
<p>CvT模型可以以较低的参数量和计算量达到更好的性能，比如21层的CvT在ImageNet上可以达到82.5%的高性能，比DeiT-B的性能还要好，而参数量和计算量都有大幅地下降。</p>
<p>CvT系列最大的模型：CvT-W24可以在ImageNet上达到87.7%的性能，不需要JFT-300预训练，超过了ViT-L模型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121212042974.png" alt="image-20211121212042974"></p>
<h3 id="迁移学习性能"><a href="#迁移学习性能" class="headerlink" title="迁移学习性能"></a><strong>迁移学习性能</strong></h3><p>CvT在小数据集上的结果如图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121212108045.png" alt="image-20211121212108045"></p>
<h3 id="对比实验1：位置编码的影响"><a href="#对比实验1：位置编码的影响" class="headerlink" title="对比实验1：位置编码的影响"></a><strong>对比实验</strong>1：位置编码的影响</h3><p>作者在CvT中没有使用位置编码，为了探究这么做到底会不会影响性能，作者设计了以下6个实验，发现DeiT在不使用位置编码时会掉点，但是CvT不使用位置编码则不会影响性能。根本原因还是CvT中的卷积操作自带了暗位置信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121212140269.png" alt="image-20211121212140269"></p>
<h3 id="对比实验2：Convolutional-Token-Embedding的影响"><a href="#对比实验2：Convolutional-Token-Embedding的影响" class="headerlink" title="对比实验2：Convolutional Token Embedding的影响"></a><strong>对比实验</strong>2：Convolutional Token Embedding的影响</h3><p>为了说明Convolutional Token Embedding的作用，作者把它替换成了Patch embedding并做了如下4组实验。结果表明，当使用Convolutional Token Embedding并不使用位置编码时效果最佳，当使用Patch embedding并同时使用位置编码时效果次之。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121212219380.png" alt="image-20211121212219380"></p>
<h3 id="对比实验3：Convolutional-Projection对比实验"><a href="#对比实验3：Convolutional-Projection对比实验" class="headerlink" title="对比实验3：Convolutional Projection对比实验"></a><strong>对比实验</strong>3：Convolutional Projection对比实验</h3><p>作者首先对比了Convolutional Projection的stride的影响，当把stride=1换成stride=2之后，计算量会有下降，但是精度也有相应的下降。</p>
<p>作者对比了把 Convolutional Projection 替换成传统的Position-wise 的 Linear Projection之后的性能变化。结果发现在3个stage中都使用 Convolutional Projection 时的性能是最优的，证明 Convolutional Projection 是一种很有效的建模策略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper//image-20211121212257789.png" alt="image-20211121212257789"></p>
<p><img src="新建文件夹/image-20211121212305909.png" alt="image-20211121212305909"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先embedding的方式变成了卷积操作，在每个Multi-head self-attention之前都进行Convolutional Token Embedding。</p>
<p>其次在 Self-attention的Projection操作不再使用传统的Linear Projection，而是使用Convolutional Projection。</p>
<p>最后取消位置编码，因为卷积操作包含了暗位置信息。</p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="http://ishero.net/CvT%20%20Introducing%20Convolutions%20to%20Vision%20Transformers.html">http://ishero.net/CvT%20%20Introducing%20Convolutions%20to%20Vision%20Transformers.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/361112935">https://zhuanlan.zhihu.com/p/361112935</a></li>
<li><a href="https://yinguobing.com/separable-convolution/">https://yinguobing.com/separable-convolution/</a></li>
</ul>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>End-to-End Object Detection with Transformers</title>
    <url>/2021/09/29/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/End-to-End%20Object%20Detection%20with%20Transformers/</url>
    <content><![CDATA[<h1 id="End-to-End-Object-Detection-with-Transformers"><a href="#End-to-End-Object-Detection-with-Transformers" class="headerlink" title="End-to-End Object Detection with Transformers"></a>End-to-End Object Detection with Transformers</h1><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>目标检测的目标是预测一个bbox的集合和各个bbox的标签。目前的检测器不是直接预测一个目标的集合，而是使用替代的回归和分类去处理大量的propoasls、anchors或者window centers。模型的效果会受到一系列问题的影响：后处理去消除大量重叠的预测、anchors的设计、怎么把target box与anchor关联起来。怎么能够简化这个流程，使得目标检测简单起来</p>
<h2 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h2><p>把目标检测看做是一种set prediction的问题，我们的方法也直接移除了一些人工设计的组件，例如NMS和anchor的生成。使用transformer来完成这一任务，在coco数据集上有着可以和faster-rcnn媲美的准确率与效率。</p>
<span id="more"></span>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211003170232176.png" alt="image-20211003170232176"></p>
<h3 id="集合预测"><a href="#集合预测" class="headerlink" title="集合预测"></a>集合预测</h3><p>集合预测是指网络直接输出最终的预测集合（这个集合不需要做任何后处理），这个集合包括预测框的位置和类别，所以能够直接得到预测的集合就可以达到目标检测的目的。</p>
<p>比如：在Detr中，transformer的后面的输出就是最终预测的结果，固定为100个预测结果也就说网络输出就是$ 100\times 4$和$100\times (C+1)$的两个tensor，分别对应框的预测和类别的预测，C表示总共的类别数,+1是背景类。</p>
<h3 id="DETR-模型"><a href="#DETR-模型" class="headerlink" title="DETR 模型"></a>DETR 模型</h3><p>目标检测中使用直接集合预测最关键的两个点是：</p>
<p>1）保证真实值与预测值之间唯一匹配的集合预测损失。</p>
<p>2）一个可以预测（一次性）目标集合和对他们关系建模的架构。</p>
<h4 id="目标检测集合预测损失"><a href="#目标检测集合预测损失" class="headerlink" title="目标检测集合预测损失"></a>目标检测集合预测损失</h4><p>DETR输出固定大小为N的预测，只需要执行一次解码器，N比常规图片中待检测目标大得多。训练中最难的地方就是根据真实值评价预测目标(类别、位置、大小)。我们的损失构造了一个最优的二分匹配而且接着优化目标向（bounding box）的损失。</p>
<p>用$y$表示真实值，$\widehat{y}=\lbrace \widehat{y}<em>i\rbrace</em>{i=1}^N$指示N个预测值。假设N远大于图像中的目标，我们可以认为y的大小也是N，用$\phi$填充空元素。目标就是找到这两个集合的二分匹配，中的一种排列$\sigma$有着最低的损失：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211003192428870.png" alt="image-20211003192428870"></p>
<p>匹配损失同时考虑到类别与真实值与预测值之间的相似度，使用的方法是匈牙利算法</p>
<p>真实值每个元素都可以看作$y_i=(c_i,b_i)$，其中$c_i$是目标类别（可能是$\phi$），而$b_i \in [0,1]^4$可以理解为b是值域在[0，1]的四维向量，bbox的中心坐标与宽高。</p>
<p>对于$\sigma(i)$的预测，我们定义类别$c<em>i$的概率为$\widehat{p}</em>{\sigma(i)}(c<em>i)$预测框为$\widehat{b}</em>{\sigma(i)}$。我们定义$L<em>{match}(y_i,\widehat{y}</em>{\sigma(i)})$为</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211003195822297.png" alt="image-20211003195822297"></p>
<p>第二步就是计算损失函数，之前的步骤就是使用匈牙利算法计算所有的匹配。我们定义的loss与常见的检测模型很相似，就是负对数似然与box损失的线性组合。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211003200122762.png" alt="image-20211003200122762"></p>
<h4 id="边界框损失"><a href="#边界框损失" class="headerlink" title="边界框损失"></a>边界框损失</h4><p>上面提到了$L<em>{box}(b_i,\widehat{b}</em>{\sigma(i)})$,$L<em>{box}(b_i,\widehat{b}</em>{\sigma(i)})$我们定义如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211004100109331.png" alt="image-20211004100109331"></p>
<p>我们直接预测box在图像中的位置，直接使用L1loss的话，对小目标就不公平，因此我们使用了L1 loss 与IOU loss的组合，让loss对目标的大小不敏感。</p>
<h4 id="骨架"><a href="#骨架" class="headerlink" title="骨架"></a>骨架</h4><p>开始输入原始图片大小为$x_{img} \in \mathbb R^{3\times H_0 \times W_0}$（三通道），使用CNN进行特征提取，最终得到特征图$f\in \mathbb R^{C\times H\times W}$，其中$C=2048$ 和$H,W=\frac{H_0}{32},\frac{W_0}{32}$</p>
<h4 id="Transfomer-encoder"><a href="#Transfomer-encoder" class="headerlink" title="Transfomer encoder"></a>Transfomer encoder</h4><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/v2-c6a17e20665898daf3507fb8b805dfcf_720w.jpg" alt="img"></p>
<p>首先使用$1\times1$的卷积将原来的$C=2048$降维到$d$维，得到$z_0\in \mathbb R^{d\times H\times W}$的特征图，因为编码器需要一个序列作为输入因此我们将$z_0$压缩到一维，得到$d\times HW$的特征映射。每个encoder层由multi-head self-attention模块和FFN组成。由于transformer对排列顺序不敏感，所以我们加入了位置的编码，并添加到所有attention层的输入。</p>
<h4 id="Transfomer-decoder"><a href="#Transfomer-decoder" class="headerlink" title="Transfomer decoder"></a>Transfomer decoder</h4><p>与常规transformer的区别就是，本文可以并行的解码，而之前的transformer都是自回归的依次解码。由于decoder也是对排列顺序不敏感，这N个嵌入必须不一样，才能预测不同的结果。这些输入的嵌入是学到的位置编码，我们称之为object queries，类似于encoder，我们把它们加到每个decoder的输入。由于用了transformer，我们可以学习全局的信息。</p>
<h4 id="Prediction-feed-forward-networks-FFNs-（预测前馈网络）"><a href="#Prediction-feed-forward-networks-FFNs-（预测前馈网络）" class="headerlink" title="Prediction feed-forward networks(FFNs)（预测前馈网络）"></a>Prediction feed-forward networks(FFNs)（预测前馈网络）</h4><p>由三层的感知器计算，使用relu，隐层的size为d，线性的映射层。使用softmax输出类别概率。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/337649487">https://zhuanlan.zhihu.com/p/337649487</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/149252931">https://zhuanlan.zhihu.com/p/149252931</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/127774251">https://zhuanlan.zhihu.com/p/127774251</a></li>
<li><a href="https://blog.csdn.net/wd18508423052/article/details/111686666">https://blog.csdn.net/wd18508423052/article/details/111686666</a></li>
<li><a href="https://blog.csdn.net/donkey_1993/article/details/106939936">https://blog.csdn.net/donkey_1993/article/details/106939936</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/266069794">https://zhuanlan.zhihu.com/p/266069794</a></li>
</ul>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>transformer</tag>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning Temporal Co-Attention Models for Unsupervised Video Action Localization</title>
    <url>/2021/06/15/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/Learning%20Temporal%20Co-Attention%20Models%20for%20Unsupervised%20Video%20Action/</url>
    <content><![CDATA[<h1 id="Learning-Temporal-Co-Attention-Models-for-Unsupervised-Video-Action-Localization"><a href="#Learning-Temporal-Co-Attention-Models-for-Unsupervised-Video-Action-Localization" class="headerlink" title="Learning Temporal Co-Attention Models for Unsupervised Video Action Localization"></a>Learning Temporal Co-Attention Models for Unsupervised Video Action Localization</h1><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>未修剪视频中的时间动作定位（Temporal action localization，TAL） 最近获得了巨大的研究热情，但是TAL目前并没有无监督的的方法出现，所以本论文提出了第一种无监督的TAL方法。</p>
<h2 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h2><p>为了解决动作定位，两步进行 “聚类+定位”迭代过程。</p>
<p>聚类步骤为定位步骤提供了noisy的伪标记，而定位步骤提供了时间共关注模型，从而提高了聚类性能，这两个过程相辅相成。</p>
<p>在弱监督下 TAL可被视为我们ACL的直接扩展模型。</p>
<p>从技术上讲，我们的贡献有两个方面：</p>
<ul>
<li><p>从视频级标签或伪标签中学习的时间共同注意模型，无论是针对特定类别还是不可知类别的 以反复强化的方式； </p>
</li>
<li><p>为ACL设计了新的loss，包括<code>action-background separation loss</code>和<code>cluster-based triplet loss</code>。 </p>
</li>
</ul>
<p>最终的成绩：</p>
<p>针对20种动作THUMOS14和100种 行动ActivityNet-1.2。 在两个基准上，建议 ACL的模型具有强大的性能，甚至可以与最新的弱监督方法相比。 例如，以前最好的弱监督 在THUMOS14上的mAP@0.5下，模型达到了26.8％， 我们的新记录分别为30.1％（弱监督）和25.0％ （无监督）。</p>
<span id="more"></span>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415103823407.png" alt="image-20210415103823407"></p>
<h3 id="Video-Feature-Extraction"><a href="#Video-Feature-Extraction" class="headerlink" title="Video Feature Extraction"></a>Video Feature Extraction</h3><p>给定一个未修剪的视频，我 令$X^R,X^F\in \mathbb{R}^{T \times D}$分别代表片段式RGB和flow特征序列，其中$T$代表片段的数量，$D$代表特征尺寸。</p>
<h3 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h3><p>目前我们知道训练集的动作类别<code>C</code>的数量。为了获得每个视频的视频级伪标签，我们在训练集上利用频谱聚类算法来获得<code>C</code>个聚类，以便可以根据视频的分配给每个视频一个伪标签。</p>
<p>对于每个视频$v$,我们同样得到视频的RGB和flow特征$X^R,X^F\in \mathbb{R}^{T \times D}$，令$S^R<em>{v,i},S^F</em>{v,i} \in R ^{T_v×1}$为第i次迭代中的class-agnostic attention weights权重。因为这个是训练的时候才能得到所以最开始可以都设为<code>1/T</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action//image-20210415160529774.png" alt="image-20210415160529774"></p>
<p>对于视频$v$在迭代i产生的RGB特征和光流特征就能得到</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415161152468.png" alt="image-20210415161152468"></p>
<p>将每个视频$v$的RGB特征$f^R$和光流特征$f^F$  concatenate成最后的总特征$f_i$（这个目的是去除掉背景），这样就得到了每个视频$v$的特征，就可以构建图结构了。</p>
<p>对于图G = {V, E}，其中V表示顶点的集合，即训练集视频，E表示边缘的集合。其中$v<em>i,v_j$的权重$w</em>{i,j}$由</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415161728852.png" alt="image-20210415161728852"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415161738706.png" alt="image-20210415161738706"></p>
<p>计算得来。基于构造的图，使用频谱聚类算法将未修剪的视频分组为C个簇，每个簇都定义了一个伪动作。然后，将这些视频级伪标签用于训练动作定位模型。对于弱监督扩展，每个视频均具有视频级别标签，因此跳过了聚类。</p>
<h3 id="Local-Global-Feature-Aggregation-Block"><a href="#Local-Global-Feature-Aggregation-Block" class="headerlink" title="Local-Global Feature Aggregation Block"></a>Local-Global Feature Aggregation Block</h3><p>由于每个段的特征仅包含当前代码段的信息，因此缺少时间上下文信息。为了提高每个代码段特征的可分辨性，提出了局部全局特征聚合块（Local-Global Feature Aggregation Block，FAB）以提取局部和全局上下文信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415162119941.png" alt="image-20210415162119941"></p>
<p>FAB主要是三个部分：</p>
<ul>
<li>a 1D temporal convolution branch</li>
<li>a dilated temporal pyramid branch</li>
<li>a global context branch</li>
</ul>
<p>dilated temporal pyramid branch由2个并行的卷积组成，它们具有不同的扩张率，以聚集局部时间上下文。</p>
<p>global context branch使用non-local网络捕获所有帧之间的时间相关性。在全局上下文分支之前添加了内核大小为1的一维时间卷积以降低计算成本。</p>
<p>所有分支的输出通过一维时间卷积进行级联和融合。这步可以理解为将特征富含上了上下文信息，即视频的时序信息，经过了这个module后便得到了特征信息$X_e$</p>
<h3 id="Class-Specific-Temporal-Attention-Module"><a href="#Class-Specific-Temporal-Attention-Module" class="headerlink" title="Class-Specific Temporal Attention Module"></a>Class-Specific Temporal Attention Module</h3><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415173239749.png" alt="image-20210415173239749"></p>
<p>这个模块的功能主要是获得在不同时间出现的不同动作类别的概率。</p>
<p>以$X_{cs}$中间层作为输入，输出类特定分数$A \in R^{T \times C}$,其中T是分段数，C是分类总数，这里可以理解为分数A表示了每段是某一类动作的概率。最终还是加上了softmax来归一化</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415172547677.png" alt="image-20210415172547677"></p>
<p>这个模块除了计算分数A之外，还会计算动作背景分离损失(action-background separation loss)。</p>
<p>对于一批训练视频，我们从随机训练集的$C$簇中，抽取出$Z$簇，再从$Z$簇中各自抽取出$K$个视频，定义$V_z$为属于某以簇的$K$个视频的集合</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415193402240.png" alt="image-20210415193402240"></p>
<p>对于每个视频$v_k$，我们计算动作特征和背景特征</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415193715643.png" alt="image-20210415193715643"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415193703592.png" alt="image-20210415193703592"></p>
<p>除此之外还要加上这三条限制：</p>
<p>假设我们有一对属于$V_z$的视频$v_m$和$v_n$。令d表示余弦距离函数，τ1和τ2分别表示两个cos余弦距离。</p>
<p>为了确保视频间动作的高度相似性，我们使用以下等式来强制执行此要求:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415194047630.png" alt="image-20210415194047630"></p>
<p>为了满足较高的视频内动作-背景清晰度，我们使用以下方程式:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415194318008.png" alt="image-20210415194318008"></p>
<p>然后我们就可以得到损失函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415194718815.png" alt="image-20210415194718815"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415194728168.png" alt="image-20210415194728168"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415194739349.png" alt="image-20210415194739349"></p>
<p>这个loss的作用主要是加强同簇中视频的动作相似性和动作背景的分离性</p>
<h3 id="Class-Agnostic-Temporal-Attention-Module"><a href="#Class-Agnostic-Temporal-Attention-Module" class="headerlink" title="Class-Agnostic Temporal Attention Module"></a>Class-Agnostic Temporal Attention Module</h3><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415173213102.png" alt="image-20210415173213102"></p>
<p>这个模块的功能是为了学习和动作类别无关的部分即背景部分出现的概率</p>
<p>以$X_{ca}$作为输入，输出类无关分数$S \in R^{T \times 1}$，这个分数和上面的$A$有相同的作用</p>
<p>除了计算$S$之外，这个模块也计算了cluster-based triplet loss，计算方式和上面有些类似</p>
<p>先计算class-agnostic video feature representation H</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415195736514.png" alt="image-20210415195736514"></p>
<p>抽取出某一簇内的一个视频$v_a$，假设$v_n$是不在群集z中并且与$v_a$的距离最小的视频，$v_p$是群集z中的视频并且与$v_a$的距离最大，有这样的限制：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415200547254.png" alt="image-20210415200547254"></p>
<p>接着就可以计算cluster-based triplet loss</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415200747883.png" alt="image-20210415200747883"></p>
<p>这个LOSS的意义很明确，为了将同一聚类的视频特征表示拉近，并将不同聚类的视频特征表示在特征空间中推得更远</p>
<h3 id="最终loss计算"><a href="#最终loss计算" class="headerlink" title="最终loss计算"></a>最终loss计算</h3><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415202421538.png" alt="image-20210415202421538"></p>
<p>其中$L_{cls}$是经典的交叉熵损失</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/image-20210415202705033.png" alt="image-20210415202705033"></p>
<p>其中$y_n$表示视频$v_n$的标签，${p}^n$表示视频$v_n$的预测标签。</p>
<p>至于$p$的是计算方法则是<br><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/Learning Temporal Co-Attention Models for Unsupervised Video Action/202009101218470.png" alt="在这里插入图片描述"></p>
<p>通过沿p上的类别维执行softmax，可以得到动作类$\hat {p}^n$上的概率分布</p>
<p>参考：<a href="https://blog.csdn.net/qq_43310834/article/details/108502214">https://blog.csdn.net/qq_43310834/article/details/108502214</a></p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>时序动作定位</tag>
        <tag>动作检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Fine-grained Temporal Contrastive Learning for Weakly-supervised Temporal Action Localization</title>
    <url>/2022/07/22/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/Fine-grained%20Temporal%20Contrastive%20Learning%20for%20Weakly-supervised%20Temporal%20Action%20Localization/</url>
    <content><![CDATA[<h1 id="Fine-grained-Temporal-Contrastive-Learning-for-Weakly-supervised-Temporal-Action-Localization"><a href="#Fine-grained-Temporal-Contrastive-Learning-for-Weakly-supervised-Temporal-Action-Localization" class="headerlink" title="Fine-grained Temporal Contrastive Learning for Weakly-supervised Temporal Action Localization"></a>Fine-grained Temporal Contrastive Learning for Weakly-supervised Temporal Action Localization</h1><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>文章发表在<strong>CVPR2022</strong>上，在这篇文章中，作者发现目前弱监督动作定位（WSAL）的任务，主要采用按分类定位的范式，这种范式忽略了视频序列之间富有成效的细粒度时间差异，在分类学习和分类到定位的适应中存在严重的歧义。为此作者提出<strong>细粒度序列距离（FSD）对比</strong>和<strong>最长公共子序列（LCS）对比</strong>，缓解分类和定位之间的任务差距。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220728221208824.png" alt="image-20220728221208824"></p>
<span id="more"></span>
<h2 id="论文动机"><a href="#论文动机" class="headerlink" title="论文动机"></a>论文动机</h2><p>目前WSAL多采用按分类定位（localization-by-classification）的范式。他旨在生成时间类激活序列（CAS）。大多数方法采用的是使用<strong>多实例学习MIL</strong>和<strong>attention</strong>机制来训练模型，以获得具有不同类激活的片段，再通过阈值化和合并这些激活来推断最终动作定位结果。</p>
<p>存在问题：</p>
<p>（1）在弱监督中缺乏<strong>足够的注释</strong>，学习的分类器没有足够的区分性和鲁棒性，导致<strong>动作背景分离困难</strong>。 </p>
<p>（2）分类和定位之间存在任务差距，学习的分类器通常关注<strong>易于区分的片段</strong>，而忽略定位中<strong>不突出的片段</strong>。因此，局部时间序列通常是不完整和不精确的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220728221303202.png" alt="image-20220728221303202"></p>
<p>为了解决上诉问题提出了Fine-grained Temporal Contrastive Learning (FTCL)。</p>
<p>（1）计算<strong>细粒度序列距离</strong>(FSD)，这个计算可以通过计算将一个序列转换为另一个序列所需的最小成本来评估两个序列在结构上是否相似 。比如下图通过Action instance1和Action instance2以及Action instance1和Background instance对比，从而实现动作和背景分离。</p>
<p>（2）挖掘两个包含相同动作视频之间的<strong>最长公共子序列</strong>(LCS)，同一类别的不同视频序列可以通过优化LCS为探索完整的动作实例提供补充线索，比如让Action instance1和Action instance2计算LCS，可以让模型学习到动作的完整性，比如对于这个Action instance1举重最后一个帧和Action instance2对应这样就不会学丢了帧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220728221451595.png" alt="image-20220728221451595"></p>
<p>模型的总体结构图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220728234726191.png" alt="image-20220728234726191"></p>
<h2 id="Notations-and-Preliminaries"><a href="#Notations-and-Preliminaries" class="headerlink" title="Notations and Preliminaries"></a>Notations and Preliminaries</h2><p>给定视频X和他的标签$y \in \mathbb R^c$ 。作者将视频划分伪不重叠的T段，并使用特征提取器获得特征$X=[x_1,…,x_T]\in \mathbb R^{D\times T}$，最后输入到一个嵌入模块，用于生成$T$。</p>
<p>目前，现有的主流方法主要采用按分类定位的框架，改框架搜先学习将片段级别特征聚合到视频嵌入的重要性分数，然后使用视频级别标签进行动作分类：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220728234904130.png" alt="image-20220728234904130"></p>
<p>其中$\alpha<em>t=f</em>{\alpha}(x<em>t)$为学习到的重要性分数，将生成的视频特征进一步送入到分类器以获得预测结果$\tilde{y}=f</em>{cls}(\bar{x})$。经过模型训练后。使用$f<em>\alpha(\cdot)$和$f</em>{cls}(\cdot)$来推断测试视频的片段级别激活序列CAS。</p>
<h2 id="Discriminative-Aciton-Background-Separation-via-FSD-Contrasting"><a href="#Discriminative-Aciton-Background-Separation-via-FSD-Contrasting" class="headerlink" title="Discriminative Aciton-Background Separation via FSD Contrasting"></a>Discriminative Aciton-Background Separation via FSD Contrasting</h2><p>在上述分类定位框架中，为了学习判别运动背景分类，现有的一些方法基本使用全局特征进行学习，这些方法忽略了视频之间<strong>细粒度</strong>时间差异，导致辨别能力不够。</p>
<p>现有的方法主要是通过测量两个序列的全局特征表示之间的向量距离来计算其相似性。而作者希望通过评估一个序列转换为另一个序列所需的最小代价来确定两个序列在结构上是否相似（如果越相似，转换的代价越小）。</p>
<p>本来这个问题是个np问题，但是作者使用了动态规划算法来解决这个问题，为此作者设计了可以微分的匹配、插入和删除动作符。</p>
<p>具体来说，通过学习到的CAS，作者科可以生成各种动作/背景proposals，其中动作proposals $U$包含高动作激活片段，而背景proposals $V$则相反。对于长度分别为M和N的两个序列， $U=[u_1,…,u_m]\in \mathbb R^{D\times M}$和 $V=[v_1,…,v_m]\in \mathbb R^{D\times N}$，它们的相似度按照如下的递归进计算：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220728235011250.png" alt="image-20220728235011250"></p>
<p>其中子序列相似度评分$S(i,j)$在第一个序列$U$的$i$位置和第二个序列$V$的$j$位置求值。$S(0,:)$和$S(:,0)$初始化为$0$。直观上，在位置$(i,j)$，如果$u<em>i$和$v_j$匹配，应该提高序列相似度得分。如果执行插入或者删除动作相似性得分应该降低。作者学习了三种类型的残值(标量):$\mu</em>{i,j},g<em>{i,j}$和$h</em>{i,j}$。</p>
<p>这里以$\mu<em>{i,j}$和$g</em>{i,j}$为例，计算公式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220728235041653.png" alt="image-20220728235041653"></p>
<p>其中$\Delta^\mu<em>{i,j}=[f</em>\mu(u<em>i),f</em>\mu(v<em>j)],\Delta^g</em>{i,j}$类似。$f<em>\mu(\cdot),f_g(\cdot),f_h(\cdot)$是三层全连接层。作者使用这些函数来模拟不同的动作，包括匹配、插入和删除。$\sigma</em>\mu$和$\sigma_g$是求得残差值的激活函数。</p>
<p>经过上述递归计算，保证$S(i,j)$为两个序列之间的最优相似度得分。显然来自同一类别的两项动作proposals之间的相似性应大于一项动作proposals与一项背景proposals之间的相似性。通过利用这一关系，作者设计FSD对比损失如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220728235100324.png" alt="image-20220728235100324"></p>
<p>其中$l(x)$是rank loss。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220728235112789.png" alt="image-20220728235112789"></p>
<h2 id="Robust-Classification-to-Localization-Adaption-via-LCS-Contrastingsting"><a href="#Robust-Classification-to-Localization-Adaption-via-LCS-Contrastingsting" class="headerlink" title="Robust Classification-to-Localization Adaption via LCS Contrastingsting"></a><strong>Robust Classification-to-Localization Adaption via LCS</strong> <strong>Contrastingsting</strong></h2><p>WSAL的使用视频标签进行时间上的定位，这会导致<strong>分类和定位之间存在很大的任务差距</strong>。为了缓解这一任务差距，作者试图挖掘两个视频X和Z之间的<strong>最长公共子序列(LCS)</strong>，从而提高学习到的动作proposals的一致性。</p>
<p>直觉上来说：</p>
<p>（1）如果两个视频动作不同，则X和Z之间的LCS长度应较小。显然，由于两种类型的动作的背景不同且存在实质性差异，两个单独视频中的片段可能高度不一致，导致LCS较短。</p>
<p>（2） 类似地，如果两个视频动作相同，则它们的LCS很可能很长，因为来自同一类别的动作实例由相似的时间动作片段组成。</p>
<p>基于上述观察 。作者也设计了一个动态规划的编程策略来计算X和Z之间的LCS。</p>
<p>具体来说，作者维护了一个递归矩阵$R\in\mathbb R^{(T+1)\times(T+1)}$，元素$R(i,j)$存储前缀$X_i$和$Z_j$的最长公共子序列的长度。</p>
<p>为了找到前缀$X_i$和$Z_j$的LCS，首先比较$X_i$和$Z_j$ 。</p>
<p>（1）如果它们相等，则计算的公共子序列由该元素扩展，因此$R(i,j)=R(i-1,j-1)+1$。</p>
<p>（2）如果它们不相等，则保留之前计算的$R(i,j)$的最大长度。</p>
<p>在WSAL任务中，由于一对片段不可能完全相同，即使是相同的动作类型，因此作者采用它们的相似性来计算两个序列的累积软长度(accumulated soft length )。因此，我们设计了LCS建模的递归公式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220728235211878.png" alt="image-20220728235211878"></p>
<p>其中τ是个阈值，决定视频X的第i段和视频Z的第j段是否匹配。$c_(i,j)=cos⁡(X_i,Z_j)$是$X_i$和$Z_j$的余弦相似性。作者最终使用交叉熵损失作为LCS的约束</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220728235223980.png" alt="image-20220728235223980"></p>
<p>其中$r=R(T,T)$表示两个视频之间的最长公共子序列的软长度。$\delta_{xz}$ 为ground truth，代表X和Z之间是否具有相同动作类别。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220728235311479.png" alt="image-20220728235311479"></p>
<h2 id="Train"><a href="#Train" class="headerlink" title="Train"></a><strong>Train</strong></h2><p>上述两个目标可以无缝集成到现有的WSAL框架中，并相互协作。为了优化整个模型，作者将分类损失和两个对比损失组成：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220728235254199.png" alt="image-20220728235254199"></p>
<p>由于作者提出的方法是模型不可知和非侵入性的，通过用不同类型的损失函数和主干替换$L_cls$，这两种对比损失可以很好地与任何其他弱监督动作定位目标协作。</p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>时序动作定位</tag>
        <tag>弱监督</tag>
      </tags>
  </entry>
  <entry>
    <title>OadTR Online Action Detection with Transformers</title>
    <url>/2021/10/24/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/OadTR%20Online%20Action%20Detection%20with%20Transformers/</url>
    <content><![CDATA[<h1 id="OadTR-Online-Action-Detection-with-Transformers"><a href="#OadTR-Online-Action-Detection-with-Transformers" class="headerlink" title="OadTR: Online Action Detection with Transformers"></a>OadTR: Online Action Detection with Transformers</h1><h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h2><p>该论文是解决的问题是在线动作检测。</p>
<p>在线动作检测的任务是在实时视频流当中，当事件发生时，检测事件开始的帧，以及事件的类型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024213242335.png" alt="image-20211024213242335"></p>
<span id="more"></span>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>论文模型如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024213410882.png" alt="image-20211024213410882"></p>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214014119.png" alt="image-20211024214014119"></p>
<p>给定视频$V={f<em>t}</em>{t=-T}^0$，使用特征提取器通过压缩空间维度提取到一维特征序列，然后再使用线性投影层，得到$F={token<em>t }</em>{t=-T}^0∈R^{ (T+1)×D}$</p>
<p>在encoder里面，将可学习的$token_class∈R^D$扩展到嵌入的特征序列</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214048739.png" alt="image-20211024214048739"></p>
<p>直观上，如果不存在token_class ，那么其他token获得的最终特征表示将不可避免地偏向于该指定的token作为一个整体，因此不能用来表示该学习任务(即图3中无任务token)。如下图，黄色部分就是有task token，绿色部分就是没有task token</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214123237.png" alt="image-20211024214123237"></p>
<p>由于encoder中没有帧顺序信息，所以需要另外嵌入位置编码。位置编码有两种形式:正弦输入和可训练嵌入。我们添加了位置编码$E_{pos}∈R^{(T+2)×D)}$</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214248786.png" alt="image-20211024214248786"></p>
<p>多头自注意(MSA)是变压器的核心部件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214335863.png" alt="image-20211024214335863"></p>
<p>其中</p>
<p><img src="新建文件夹/image-20211024214352649.png" alt="image-20211024214352649"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214406093.png" alt="image-20211024214406093"></p>
<p>随后，头的输出$H_1,H_2,…$被连接并馈入一个线性层</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214431145.png" alt="image-20211024214431145"></p>
<p>其中$W_d$是一个线性映射</p>
<p>接着，使用前馈网络(FFN)与GELU[19]激活。最后的公式可以表示为</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214457660.png" alt="image-20211024214457660"></p>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>OadTR的decoder利用对过去信息的观察来预测在不久的将来将要发生的动作，从而更好地学习更具甄别性的特征</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214531988.png" alt="image-20211024214531988"></p>
<p>预测查询</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214729945.png" alt="image-20211024214729945"></p>
<p>也是可学习的，其中$\acute{D}$是查询频道数量,最终得到输出</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214738930.png" alt="image-20211024214738930"></p>
<h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><p>对于当前帧块的分类任务，先将编码器中与任务相关的特征与解码器中池化的预测特征连接起来。然后生成的特征通过一个完整的连接层和一个softmax操作进行动作分类:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214822475.png" alt="image-20211024214822475"></p>
<p>其中$W_c$表示用于分类的全连接层参数，$p_0∈R^{c+1}$。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214904213.png" alt="image-20211024214904213"></p>
<p>除了估计当前动作外，OadTR还为下一步time步骤输出预测功能。由于离线训练时可以获得未来的信息，为了保证学习到好的特征表达式，我们还对未来预测特征进行了有监督的训练:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214917897.png" alt="image-20211024214917897"></p>
<p>因此，最后的训练损失为:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211024214935836.png" alt="image-20211024214935836"></p>
<p>其中CE是交叉熵损失,下一步的实际行动类别是什么$\tilde{y_i}$</p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>transformer</tag>
        <tag>在线动作检测</tag>
      </tags>
  </entry>
  <entry>
    <title>RefineLoc Iterative Refinement for Weakly-Supervised Action Localization</title>
    <url>/2021/09/11/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/RefineLoc%20Iterative%20Refinement%20for%20Weakly-Supervised%20Action%20Localization/</url>
    <content><![CDATA[<h1 id="RefineLoc-Iterative-Refinement-for-Weakly-Supervised-Action-Localization"><a href="#RefineLoc-Iterative-Refinement-for-Weakly-Supervised-Action-Localization" class="headerlink" title="RefineLoc Iterative Refinement for Weakly-Supervised Action Localization"></a>RefineLoc Iterative Refinement for Weakly-Supervised Action Localization</h1><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>在目标检测领域，使用pseudo ground truth（类似于伪标签）进行细化大大减少了完全监督和弱监督对象检测之间的性能差距，因为时间动作定位很多内容是从目标检测当中引用过来的，那么是否能把使用pseudo ground truth这个方法引用到时间动作定位当中呢。</p>
<p>pseudo ground truth的概念是指来自弱监督模型的一组采样对象预测，在下一次细化迭代中将其假定为实际对象位置。</p>
<h2 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h2><p>提出RefineLoc模型，一种弱监督的时间定位方法，它通过利用pseudo ground truth实况来评估迭代细化策略</p>
<span id="more"></span>
<h2 id="怎么做的"><a href="#怎么做的" class="headerlink" title="怎么做的"></a>怎么做的</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210911184214062.png" alt="image-20210911184214062"></p>
<h3 id="Snippet-Level-Classification-Module"><a href="#Snippet-Level-Classification-Module" class="headerlink" title="Snippet-Level Classification Module"></a>Snippet-Level Classification Module</h3><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210912211014735.png" alt="image-20210912211014735"></p>
<p>这个模块接受特征图F，然后产生T×N的类别激活图C（类激活序列的概念，在时间动作定位当中很常见，自行进行了解）</p>
<p>它由一个多层感知器 (MLP) 组成，其中 L 个全连接 (FC) 层与 ReLU 激活函数交错</p>
<h3 id="Background-Foreground-Attention-Module"><a href="#Background-Foreground-Attention-Module" class="headerlink" title="Background-Foreground Attention Module"></a>Background-Foreground Attention Module</h3><p>该模块的目标是学习每个片段的注意力权重，从而达到抑制背景的作用。</p>
<p>这个模块接受特征图F，然后产生T×2的类别激活图A（因为是背景，所以维度是$T\times 2$,和前面模块的的$T\times N$对比一下）</p>
<p>它由一个多层感知器 (MLP) 组成，其中 L 个全连接 (FC) 层与 ReLU 激活函数交错</p>
<p>别人的注意力模块仅受视频级别标签的监督，以改善视频分类，而本论文的注意力则由视频级标签和一组伪背景-前景标签，目的是提高动作片段的定位我们选择这样做是因为我们的方法直接对注意力值使用监督。因此，论文不是通过逻辑回归损失来学习注意力，而是将其作为二元分类问题来学习。我们将通过逻辑回归学习标量注意力与我们在补充材料中提出的二维注意力进行比较</p>
<h3 id="Video-Label-Prediction-Module"><a href="#Video-Label-Prediction-Module" class="headerlink" title="Video Label Prediction Module"></a>Video Label Prediction Module</h3><p>该模块结合 C 和 A 为视频标签生成 N 维概率向量 $\hat{y}$</p>
<p>具体来说，我们将 C 通过一个 softmax 层以获得$\bar{C}$,并将A通过两个 softmax 层。第一个softmax 层在background-foreground维度生成$\bar{A}^{bf}$,而第二个softmax 层是在$\bar{A}^{bf}$时间维度生成$\bar{A}^{time}$</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210912212420180.png" alt="image-20210912212420180"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210912212428662.png" alt="image-20210912212428662"></p>
<p>别人的注意力模块仅受视频级别标签的监督，以改善视频分类，而我们的注意力则由视频级标签和一组伪背景-前景标签，目的是提高动作片段的定位</p>
<p>我们选择这样做是因为我们的方法直接对注意力值使用监督。因此，我们不是通过逻辑回归损失来学习注意力，而是将其作为二元分类问题来学习。我们将通过逻辑回归学习标量注意力与我们在补充材料中提出的二维注意力进行比较i = 1 指的是背景，而 i = 2 指的是前景</p>
<h3 id="Action-Segment-Prediction-Module"><a href="#Action-Segment-Prediction-Module" class="headerlink" title="Action Segment Prediction Module."></a>Action Segment Prediction Module.</h3><p>该模块后处理$\bar{A}^{bf}$和$\bar{C}$以产生一组动作片段预测P</p>
<p>首先，我们过滤掉背景注意力值大于阈值$\alpha_A$的片段。然后，我们只考虑$\hat{y}$中的 top-k 类。对于每个类别n，我们过滤掉片段分类分数低于$\alpha_c$</p>
<p>对于片段$(t_1,t_2)$</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210912213225224.png" alt="image-20210912213225224"></p>
<h3 id="Iterative-Refinement-Process"><a href="#Iterative-Refinement-Process" class="headerlink" title="Iterative Refinement Process"></a>Iterative Refinement Process</h3><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210912212825938.png" alt="image-20210912212825938"></p>
<p>让$g^(M<em>η )$作为pseudo ground truth生成函数，使用来自$M</em>η$的信息(η迭代后训练的WSTAL基模型)将每个片段映射到伪背景-前景标签。在η+1迭代时，我们训练了一个新的WSTAL基模型Mη+1，用于计算视频级标签和片段级伪地面真标签的联合损失。具体地说，我们用下面的方法计算给定视频上的Mη+1的损失</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210912213355698.png" alt="image-20210912213355698"></p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>时序动作定位</tag>
        <tag>弱监督</tag>
      </tags>
  </entry>
  <entry>
    <title>Two-Stream Consensus Network for Weakly-Supervised Temporal</title>
    <url>/2022/07/19/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/Two-Stream%20Consensus%20Network%20for%20Weakly-Supervised%20Temporal/</url>
    <content><![CDATA[<h1 id="Two-Stream-Consensus-Network-for-Weakly-Supervised-Temporal"><a href="#Two-Stream-Consensus-Network-for-Weakly-Supervised-Temporal" class="headerlink" title="Two-Stream Consensus Network for Weakly-Supervised Temporal"></a>Two-Stream Consensus Network for Weakly-Supervised Temporal</h1><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>文章发表在<strong>ECCV2020</strong>上，文章提出了一个双流共识网络(TSCN)，采用迭代细化训练方法，迭代更新帧级的<strong>伪真实值</strong>，并用于提供帧级监督，以改进模型训练和消除假积极动作建议。此外，文章提出了一种新的<strong>注意归一化损失</strong>，以鼓励预测的注意充当二进制选择，并促进动作实例边界的精确定位。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719122157159.png" alt="image-20220719122157159"></p>
<span id="more"></span>
<h2 id="论文动机"><a href="#论文动机" class="headerlink" title="论文动机"></a>论文动机</h2><p>1.弱监督时间动作定位(W-TAL)的目标是在视频级别监督下对未裁剪视频中所以动作实例进行分类和定位。然而由于没有帧级别的注释，W-TAL方法很难识别<strong>false positive</strong> action proposals。比如：模型可能仅通过检查场景中是否存在水来错误定位动作“游泳”。因此，<strong>有必要利用更细粒度的监督来指导学习过程</strong>。</p>
<p>2.另一个问题在于action proposals的生成，之前都是使用经验预设的<strong>固定阈值</strong>对激活序列进行阈值化来生成的。比如：<strong>高阈值</strong>可能导致行动建议不完整，而<strong>低阈值</strong>可能带来更多误报。</p>
<p>针对上面的问题，作者提出一个双流共识网络(TSCN)。TSCN采用迭代精细化训练的方法，迭代更新帧级别的标签，并用于提供帧级别监督改进的模型训练和<strong>false positive</strong> <strong>proposals</strong>消除。此外，作者提出了一种新的注意力归一化损失，以鼓励预测的注意向二进制选择一样行为，并促进动作实例边界的精确定位</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719122314776.png" alt="image-20220719122314776"></p>
<h2 id="思路和研究方法"><a href="#思路和研究方法" class="headerlink" title="思路和研究方法"></a>思路和研究方法</h2><p>提出的双流一致性网络，包括三部分：（1）利用预训练模型提取RGB和光流片段级特征；（2）使用这些RGB和光流特征分别训练两个流基模型；（3）从两流延迟融合注意序列生成帧级伪ground truth，进而为两个流基模型提供帧级监督 </p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719122543177.png" alt="image-20220719122543177"></p>
<h3 id="Feature-Extraction"><a href="#Feature-Extraction" class="headerlink" title="Feature Extraction"></a>Feature Extraction</h3><p>使用预训练号的网络分别从不重叠的固定长度的RGB帧片段和光流片段中提取RGB、光流特征。它们提供了相应片段的高级外观和运动信息。形式上，给定一个具有T个不重叠片段的视频，作者分别表示RGB特征个光流特征为${f<em>{RGB}}</em>{i=1}^T$和${f<em>{flow} }</em>{i=1}^T$，其中$f<em>{RGB,i},f</em>{flow,i}\in R^D$分别代表第$i$帧RGB和光流特征表示，$D$表示通道维数。</p>
<h3 id="Two-Stream-Base-Models"><a href="#Two-Stream-Base-Models" class="headerlink" title="Two-Stream Base Models"></a>Two-Stream Base Models</h3><p>在获得RGB和光流特征后，作者首先使用双流基础模型进行视频级的动作分类，然后用帧级别的伪标签对基础模型进行迭代细化。</p>
<p>两种模式特征分别输入到两个独立的基本模型中，两个基本模型使用相同的架构，但不共享参数（后面省略RGB、flow）。</p>
<p>作者将输入特征${f<em>i}</em>{i=1}^T$ 连接起来，并使用一组时间卷积生成新特征${x<em>i }</em>{i=1}^T$，其中$x_i\in R^D$，$D$表示输出特征维度。</p>
<p>由于视频可能包含背景片段，为了执行视频级别分类，作者需要选择可能包含动作实例片段，同时过滤掉可能包含背景的片段。为此，全连接(FC)层给出一个用于衡量第i个包含动作的片段的可能性的注意值$A_i \in (0,1):$</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719124205244.png" alt="image-20220719124205244"></p>
<p>公式中$\sigma(),W_A,b_A$分别为sigmoid函数、权重向量和偏差。然后，作者对特征序列进行注意力加权池化，生成单个前景特征，并将其输入FC、softmax层，获得视频级别预测：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719124409241.png" alt="image-20220719124409241"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719124422377.png" alt="image-20220719124422377"></p>
<p>其中$\hat{y}_c$为视频包含第c个动作概率。</p>
<p>有了$\hat{y}<em>c$后可以定义分类损失函数$L</em>{cls}$ 为标准交叉熵损失：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719124547523.png" alt="image-20220719124547523"></p>
<p>理想情况下，注意力值应为二进制，其中1表示存在动作，0表示背景。在这项工作中，作者没有使用背景分类，而是引入了注意力归一化项，以迫使注意力接近极端值： </p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719124601551.png" alt="image-20220719124601551"></p>
<p>这种归一化损失旨在最大化平均top-l注意力值和平均bottom-l注意力值之间的差异，并强制前景注意力为1，背景注意力为0。</p>
<p>因此，基本模型训练的总损失是分类损失和注意力归一化项的加权和： </p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719124627631.png" alt="image-20220719124627631"></p>
<p>此外，通过在所有片段上滑动分类FC softmax层来生成（其实就是使用${x<em>i }</em>{i=1}^T$在FC层上滑动生成的），时间类激活图（T-CAM）${s<em>i }</em>{i=}^T,s_i\in R^c$ ：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719124730731.png" alt="image-20220719124730731"></p>
<h3 id="Pseudo-Ground-Truth-Generation"><a href="#Pseudo-Ground-Truth-Generation" class="headerlink" title="Pseudo Ground Truth Generation"></a>Pseudo Ground Truth Generation</h3><p>作者使用帧级<strong>pseudo ground truth</strong>对两个流基模型进行迭代优化。由于没有真正的注释，既不能衡量<strong>pseudo ground truth</strong>的质量，也不能保<strong>pseudo ground truth</strong>可以帮助基础模型实现更高的性能。</p>
<p>受双流后期融合的启发，作者引入了一种简单而有效的方法来生成伪地面真值。直觉上，两个流具有<strong>高激活</strong>的位置可能包含ground truth动作实例；只有一个流具有高激活率的位置很可能是只有一个流可以检测到的false positive action proposals或真实动作实例；两个流都具有<strong>低激活</strong>的位置可能是背景。</p>
<p>根据上诉的直觉，作者在细化迭代n时使用使用融合注意力序列${A<em>{fuse}^{(n)} )}</em>{i=1}^T$来生成pseudo ground truth${G<em>i^{(n+1)} )}</em>{i=1}^T$用于细化迭代n+1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719125259220.png" alt="image-20220719125259220"></p>
<p><strong>Soft Pseudo Ground Truth</strong>。直接使用融合注意力值作为伪标签的方法：$G<em>i^{(n+1)}=A</em>{fuse}^{(n)}$ <strong>。</strong>软伪标签包含片段作为前景动作的概率，但也给模型增加了不确定性。</p>
<p><strong>Hard Pseudo Ground Truth</strong>。阈值注意力序列以生成二进制序列：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719125437953.png" alt="image-20220719125437953"></p>
<p>硬伪标签消除了不确定性，提供了更强的监督，但引入了超参数。</p>
<p>在生成帧级伪地面真值后，作者强制每个流生成的注意力序列与伪地面真值相似，具有均方误差（MSE）损失：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719125458866.png" alt="image-20220719125458866"></p>
<p>在细化迭代n+1时，每个流的总损失为</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719125559579.png" alt="image-20220719125559579"></p>
<p>实验中最好的结果是使用Hard Pseudo Ground Truth</p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>在THUMOS’14和ActivityNet-1.2、ActivityNet-1.3上进行了实验</p>
<p>这里就展示了THUMOS’14的结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719125802125.png" alt="image-20220719125802125"></p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>时序动作定位</tag>
        <tag>弱监督</tag>
      </tags>
  </entry>
  <entry>
    <title>Self-Supervised Learning for Semi-Supervised Temporal Action Proposal</title>
    <url>/2021/10/24/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/Self-Supervised%20Learning%20for%20Semi-Supervised%20Temporal%20Action%20Proposal/</url>
    <content><![CDATA[<h1 id="Self-Supervised-Learning-for-Semi-Supervised-Temporal-Action-Proposal"><a href="#Self-Supervised-Learning-for-Semi-Supervised-Temporal-Action-Proposal" class="headerlink" title="Self-Supervised Learning for Semi-Supervised Temporal Action Proposal"></a>Self-Supervised Learning for Semi-Supervised Temporal Action Proposal</h1><p>论文使用自监督的方法来改造半监督行为建议区域生成。</p>
<p>作者专门设计了一个Self-supervised Semi-supervised Temporal Action Proposal (SSTAP) 网络结构，后面简称SSTAP。SSTAP包含两个分支temporal-aware semi-supervised branch 和relation-aware self-supervised branch，简单理解就是一个半监督分支和一个自监督分支。半监督分支是加入特征偏移和特征翻转在the mean teacher frame-work上，自监督分支则是定义了两个任务masked feature reconstruction 和 clip-order prediction</p>
<span id="more"></span>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210624205135966.png" alt="image-20210624205135966"></p>
<h3 id="1-Problem-Description"><a href="#1-Problem-Description" class="headerlink" title="1.Problem Description"></a>1.Problem Description</h3><p>问题的定义是，给一段未裁剪$S={s<em>n}^{ls}</em>{n=1}$，假设它的长度为$l<em>s$，论文的方法的目标是在视频示例片段$\varphi_p={\xi_n=[t</em>{s,n},t<em>{e,n}]}^{M_n}</em>{n=1}$检测出动作，其中 $M<em>s$是动作实例的总数，$[t</em>{s,n},t_{e,n}]$ 分别表示动作实例$\xi_n$的起点和终点</p>
<h3 id="2-Feature-Encoding"><a href="#2-Feature-Encoding" class="headerlink" title="2.Feature Encoding"></a>2.Feature Encoding</h3><p>特征提取部分。给一段未裁剪$S={s<em>n}^{ls}</em>{n=1}$，假设它的长度为$l<em>s$，我们首先将其划分为不重叠的短片段，每个片段包含 $\sigma$帧，然后采用双流网络(RGB或者Flow)提取视觉特征序列$\phi={\phi</em>{t<em>n}}^T</em>{n=1}\in\mathbb R^{T\times C}$，其中$C$是特征的维度,而$T=l_s/\sigma$。</p>
<p>其实就是一个监督的特征提取。</p>
<h3 id="3-Temporal-aware-Semi-Supervised-Branch"><a href="#3-Temporal-aware-Semi-Supervised-Branch" class="headerlink" title="3.Temporal-aware Semi-Supervised Branch"></a>3.Temporal-aware Semi-Supervised Branch</h3><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210625120746578.png" alt="image-20210625120746578"></p>
<p>半监督分支当中主要有两个点，mean teacher framework和扰动，这部分是在BMN网络上进行修改</p>
<h3 id="4-Relation-aware-Self-Supervised-Branch"><a href="#4-Relation-aware-Self-Supervised-Branch" class="headerlink" title="4.Relation-aware Self-Supervised Branch"></a>4.Relation-aware Self-Supervised Branch</h3><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20210625121709195.png" alt="image-20210625121709195"></p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>时序动作定位</tag>
        <tag>自监督</tag>
      </tags>
  </entry>
  <entry>
    <title>Weakly Supervised Temporal Action Localization via Representative Snippet Knowledge Propagation</title>
    <url>/2022/07/30/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/Weakly%20Supervised%20Temporal%20Action%20Localization%20via%20Representative%20Snippet%20Knowledge%20Propagation/</url>
    <content><![CDATA[<h1 id="Weakly-Supervised-Temporal-Action-Localization-via-Representative-Snippet-Knowledge-Propagation"><a href="#Weakly-Supervised-Temporal-Action-Localization-via-Representative-Snippet-Knowledge-Propagation" class="headerlink" title="Weakly Supervised Temporal Action Localization via Representative Snippet Knowledge Propagation"></a>Weakly Supervised Temporal Action Localization via Representative Snippet Knowledge Propagation</h1><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>文章发表在<strong>CVPR2022</strong>上，作者发现许多现有弱监督时序动作定位方法试图生成伪标签以弥补分类和定位之间的差异，但目前方法通常仅利用<strong>有限</strong>的上下文信息生成伪标签。为了缓解这个问题，作者提出了一个<strong>具有代表性的片段汇总和传播</strong>框架。作者的方法试图挖掘每个视频中的代表性片段，以便在视频片段之间传播信息，从而生成更好的伪标签。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730210425343.png" alt="image-20220730210425343"></p>
<span id="more"></span>
<h2 id="论文动机"><a href="#论文动机" class="headerlink" title="论文动机"></a>论文动机</h2><p>由于在弱监督中缺乏<strong>细粒度注释</strong>，现有工作主要采用localization-by-classification的方式进行训练，使用动作类别的<strong>视频级注释</strong>训练分类器，并用于获得<strong>时间类激活图（TCAM）</strong>。再通过阈值或定位分支等方式从TCAM获得检测结果。因此，TCAM的质量决定了模型的上限。但是，分类和定位之间通常存在差异，使得模型很容易将重点放在对视频级分类贡献最大的<strong>上下文背景</strong>或<strong>区分性片段上</strong>，阻碍生成高质量TCAM。</p>
<p>因此有人提出了<strong>基于伪标签</strong>的方法来生成<strong>片段伪标签</strong>，以弥合分类和定位之间的差距。然而，现有方法都是使用每个片段中的信息来生成伪标签，这很难生成高</p>
<p>质量的伪标签。</p>
<p>在图1中，作者显示了两种方法的检测结果。第一种方法TSCN是一种基于伪标签的方法，而第二种方法STPN是一种不使用伪标签的简单基线模型。正如我们所看到的，即使TSCN和STPN相比获得了很大的增益，但这两种方法都没有成功地检测到橙色框中的困难动作实例，该框仅显示运动员的部分身体。显然，由不准确的TCAM生成的伪标签也不准确。相反，对于简单的例子，例如蓝色框中的一个，这两种方法都能准确地检测到它。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730210529001.png" alt="image-20220730210529001"></p>
<p>为此作者引入上下文信息来生成<strong>伪标签</strong>。具体来说，作者以视频内和视频间的方式传播这些代表性片段（图中的黑色和蓝色方框）的知识，以促进伪标签的生成，特别是对于那些困难的片段（图中的橙色方框）。</p>
<p>作者提出了一个<strong>具有代表性的片段汇总和传播框架</strong>。作者的方法试图挖掘每个视频中的代表性片段，以便在视频片段之间传播信息，从而<strong>生成更好的伪标签</strong>。对于每个视频，以视频内和视频间的方式传播其自身的代表片段和来自存储库的代表片段以更新输入特征。伪标签是由更新特征的时间类激活映射生成，以纠正主分支的预测</p>
<p>作者的方法概述 如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730210725403.png" alt="image-20220730210725403"></p>
<h2 id="Feature-extraction"><a href="#Feature-extraction" class="headerlink" title="Feature extraction"></a>Feature extraction</h2><p>给定一段视频，作者首先把它分为一些列不重叠片段。接下来，作者利用固定权重的backbone网络，在Kinetics-400数据集上预训练I3D模型，将外观（RGB）和运动（光流）信息编码为d=2048维特征。I3D特征通过卷积层编码到潜在嵌入F∈R^(l×d)中，其中l是视频的片段数。作者取F作为模型的输入。 </p>
<h2 id="Classification-head"><a href="#Classification-head" class="headerlink" title="Classification head"></a>Classification head</h2><p>分类头用于生成TCAM，它可以是任何现有的WSTAL方法。为了生成高质量的TCAM并改进作者方法的下限，作者使用了最新的FAC-Net作为分类头（作者经过一定的修改），因为它具有简单的管道和良好的性能。</p>
<h2 id="Representative-Snippet-Summarization"><a href="#Representative-Snippet-Summarization" class="headerlink" title="Representative Snippet Summarization"></a>Representative Snippet Summarization</h2><p>获得代表性片段的简单方法是选择<strong>预测得分高</strong>的片段，即<strong>辨别性片段</strong>。然而，如图所示，即使经过大规模的预训练，<strong>辨别性片段</strong>和同类别的其他片段之间的相似度通常较低。直观地说，代表性片段应该能够描述同一类的大多数片段，从而起到联系同一类片段进行知识传播的桥梁的作用。因此，将<strong>辨别性片段</strong>的信息直接传播到其他片段是无效的。</p>
<p>作者提出对视频片段的表示方式进行总结，得到每个视频的<strong>辨别性片段</strong>。在图中，通过<strong>聚类</strong>视频片段特征（例如，k均值、谱聚类和凝聚聚类），使用聚类中心作为代表片段，取得了更好的性能。实验表明，使用聚类方法总结代表性片段对于提高高检测性能有重要意义。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730210858240.png" alt="image-20220730210858240"></p>
<p>在这项工作中，作者使用<strong>期望最大化（EM）注意力</strong>来生成每个视频的代表性片段。EM注意力使用基于高斯混合模型（GMM）的特殊EM算法。具体来说，采用分离的GMM来捕获每个视频的特征统计信息，并将$f_i\in \mathbb R^d$($F$的第$i$个片段特征)的分布建模为一个高斯线性组合，如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730210940462.png" alt="image-20220730210940462"></p>
<p>其中$n$为高斯函数的个数，$\mu<em>k\in\mathbb R^d,\sum_k\in\mathbb R^{d\times d},Z</em>{ik}$分别表示第$k$个高斯函数的均值、协方差矩阵和权重。作者用单位矩阵<strong>I</strong>替换了协方差，在后续的方程中去掉它。(其实这里的$\mu$是高斯函数的平均值，但是也可以理解为)</p>
<p>如图（顶部）所示，EM注意力从随机初始化的均值$\mu^{(0)}\in\mathbb R^{n\times d}$开始。在第$t$次迭代中，首先执行E步骤，计算高斯的新权重$Z^{(t)}\in\mathbb R^{t\times n}$为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730211006038.png" alt="image-20220730211006038"></p>
<p>其中$\lambda$表示一个超参数，用于控制分布的平滑度。$Norm<em>2 (F)$沿F的每一行的$l2-norm$。softmax操作沿$Z$的每一行都执行。因此，$Z^{(t)}</em>{ik}$表示片段特征$f_i$由第k个高斯函数生成的概率。</p>
<p>在E步骤之后，M步骤将平均值μ进行更新为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730211054457.png" alt="image-20220730211054457"></p>
<p>其中$Norm_1(Z^{(t)})$表示$Z^t $按照列进行$l_1$ 归一化。可以看到公式更新均值实验特征F的加权求和。归一化确保更新后的$\mu$与$F$位于相同的嵌入空间中。因此，交替执行上述两个等式以非局部但更有效的方式捕获视频的全局上下文，这是因为均值$\mu^{(t)}\in\mathbb R^{n\times d}$ 的尺寸比视频特征$F\in\mathbb R^{l\times d}(l&gt;&gt;n)$小的多。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730211023456.png" alt="image-20220730211023456"></p>
<p>作者在网络中集成了两个EM迭代，以获得有希望的代表性片段（即$\mu^{(2)}$ ）。作者通过标准反向传播更新初始化均值。此外，当作者用一个（半）正交矩阵初始化$\mu^{0}$时，即使<strong>固定了初始化的均值</strong>（即图中的EM-Att w/o BP），获得的代表性片段也比其他聚类方法的聚类中心更具代表性。当作者通过<strong>标准反向传播</strong>（即图中的EM-Att）更新初始均值$\mu^{0}$时，它们可以捕获数据集的特征分布并实现最佳性能。为了使方程清晰并避免混淆，我们将在线计算的代表性片段表示为$\mu^{(a)}$ 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730210858240.png" alt="image-20220730210858240"></p>
<h2 id="Representative-Snippet-Memory-Bank"><a href="#Representative-Snippet-Memory-Bank" class="headerlink" title="Representative Snippet Memory Bank"></a>Representative Snippet Memory Bank</h2><p>在获得每个视频的代表性片段后，作者使用一个<strong>存储库</strong>来存储每个类的所有<strong>高置信度视频的代表片段</strong>。作者认为不同的视频可能包含相同的动作实例，但是具有不同的外观。因此，通过存储库以视频间的方式传播代表性片段，可以利用每个类的许多视频的巨大变化，帮助网络识别那些困难的动作实例。 </p>
<p>具体来说，作者维护了两个记忆表，分别存储代表性片段的<strong>特征</strong>及其<strong>分数</strong>。我们将代表性片段的内存表表示为$M\in\mathbb R^{c\times s\times d}$，其中c是类的数量，s表示每个类的内存插槽（代表性片段）的数量。给定视频的代表性片段，作者利用分类头中的动作分类器来获得它们的类预测。然后，将它们真实类的预测分数与存储表M中的代表性片段进行比较，预测分数较高的片段被归档到存储表M。同时，分数存储表中的相应分数也被更新。总之，作者只将分数高的代表性片段保留在内存表中。为了区别于<strong>在线</strong>代表性片段$\mu^{(a)}$ ，将<strong>离线</strong>代表性片段表示为$\mu^{(e)}$ 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730210725403.png" alt="image-20220730210725403"></p>
<h2 id="Representative-Snippet-Propagation"><a href="#Representative-Snippet-Propagation" class="headerlink" title="Representative Snippet Propagation"></a>Representative Snippet Propagation</h2><p>给定在线和离线代表性片段$\mu^{(a)}$和$\mu^{(e)}$ ，一个挑战是如何将<strong>代表性片段</strong>传播到当前视频的片段特征F。直观地说，一种直接的方法是使用亲和力$Z^∗$(∗ 是a或e），进行随机游动操作作为$Z^∗ μ^∗$ 。 实际上，作者希望更新后的特征不会偏离视频特征F太远。因此，传播过程可以公式化为$F^∗=\omega⋅Z^∗ μ^∗+(1-\omega)⋅F$，其中$\omega$表示控制特征传播和原始特征之间权衡的参数。</p>
<p>然而，即使代表性片段与同一类的大多数片段具有高度相似性，通过一次传播来完全传播代表性片段的知识也是不切实际的。作者发现，具有代表性的片段$\mu^<em>$和视频特征F实际上构成了一个完整的<strong>二部图</strong>，其亲和力由$Z^∗$表示。因此，作者提出了一个<em>*二部随机游走（BiRW）模块</em></em>，以实现多次传播，将代表性片段的知识完全融合到视频片段特征中。 </p>
<p>BiRW中有多次迭代。在第$t$次迭代中，传播过程公式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730211322392.png" alt="image-20220730211322392"></p>
<p>其中其中$F^{(0)}$和$\mu^{(0)}$分别是视频片段特征$F$和代表片段  。$\mu^{(a)}$和$\mu^{(e)}$如图（底部）所示，上述公式也可以被视为EM过程，它固定了亲和力$Z^*$交替更新$F$和$\mu^∗$  。因此，代表性片段不仅用于传播代表性知识，而且还作为桥梁在F的特征之间传播知识。由于其代表性，它们可以更好地在同一类的特征之间传播信息。这个过程可以多次进行，以充分融合代表性片段的知识。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730211023456.png" alt="image-20220730211023456"></p>
<p>为了避免展开计算图引起的梯度消失或爆炸，作者使用近似推理公式</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730211354223.png" alt="image-20220730211354223"></p>
<p>注意，我们使用等式（6）分别传播关于$\mu^{(a)}$和$\mu^{(e)}$的知识，而不是连接$\mu^{(a)}$和$\mu^{(e)}$来传播代表性片段。该设计目的是防止从F的同一视频中提取的在$\mu^{(a)}$传播中占主导地位。因此，在代表性片段传播后，我们分别获得更新的视频内特征$F^a$和更新的视频间特征$F^e$。 </p>
<h2 id="Training-Objectives"><a href="#Training-Objectives" class="headerlink" title="Training Objectives"></a>Training Objectives</h2><p>给定原始视频片段特征$F$和更新后的特征$F^a,F^e$，我们将其输入三个具有共享参数的并行分类头，分别输出其TCAM $T$、$T^a$和$T^e$。对TCAMs进行加权求$T^a$和$T^e$和，获得包含视频内和视频间代表性片段知识的TCAM $T^f$。作者将$T^f$作为在线伪标签来监控TCAM $T$</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730211430094.png" alt="image-20220730211430094"></p>
<p>其中t是片段数。总损失是损失$L<em>{kd}$、三个分类头的视频分类损失$L</em>{cls}$和只应用于主分支的注意力归一化损失$L_{att}$的总和。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220730211441366.png" alt="image-20220730211441366"></p>
<p>其中α和β是平衡参数。 </p>
<p>注意力归一化损失$L_{att}$在<a href="https://bugcat9.github.io/2022/07/19/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/Two-Stream%20Consensus%20Network%20for%20Weakly-Supervised%20Temporal/">TSCN</a>中提到过</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20220719124601551.png" alt="image-20220719124601551"></p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/78311644">https://zhuanlan.zhihu.com/p/78311644</a></li>
</ul>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>时序动作定位</tag>
        <tag>弱监督</tag>
      </tags>
  </entry>
  <entry>
    <title>Weakly-supervised Temporal Action Localization by Uncertainty Modeling</title>
    <url>/2021/12/02/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/Weakly-supervised%20Temporal%20Action%20Localization%20by%20Uncertainty%20Modeling/</url>
    <content><![CDATA[<h1 id="Weakly-supervised-Temporal-Action-Localization-by-Uncertainty-Modeling"><a href="#Weakly-supervised-Temporal-Action-Localization-by-Uncertainty-Modeling" class="headerlink" title="Weakly-supervised Temporal Action Localization by Uncertainty Modeling"></a>Weakly-supervised Temporal Action Localization by Uncertainty Modeling</h1><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>现有的Weakly-supervised Temporal Action Localization处理背景的方法存在很多问题，要不将静态帧合并合成伪背景视频，但忽略了动态背景帧，要不将背景框架划分为一个单独的类别。然而，强制所有的背景帧属于一个特定的类（背景类别其实也是不同的，因为它们不共享任何共同的语义）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202113108293.png" alt="image-20211202113108293"></p>
<p>如图a中背景其实是非常动态的（理解为摄像机在动，其中的人也是在动的），图b中展现出来的一个视频中的背景是不相同的。</p>
<span id="more"></span>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>论文的作者接受背景帧不一致的观察。一般来说，动作帧的特征比背景帧的特征有更大的幅度，如图a所示。这是因为动作帧需要为基本事实的动作类生成高对数。虽然特征量显示了背景和动作帧之间的识别相关性，但由于动作和背景的分布比较接近，直接使用特征量进行识别是不够的。因此，为了进一步鼓励特征幅度上的差异，作者建议通过增大动作特征的幅度和减小接近于零的背景特征的幅度来分离分布(图b)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202113647997.png" alt="image-20211202113647997"></p>
<p>基于上面提出的思想提出了一个不确定性建模的方法。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202113830606.png" alt="image-20211202113830606"></p>
<h3 id="Main-pipeline"><a href="#Main-pipeline" class="headerlink" title="Main pipeline"></a>Main pipeline</h3><h4 id="Feature-extraction"><a href="#Feature-extraction" class="headerlink" title="Feature extraction"></a>Feature extraction</h4><p>将视频分割成多个段，$v<em>n=\lbrace s</em>{n,l}\rbrace^{L<em>n}</em>{l=1}$，然后进行采样使得$v<em>n=\lbrace \tilde{s}</em>{n,t} \rbrace^T<em>{t=1}$。然后提取RGB特征$x^{RGB}</em>{n,t}\in \mathbb R^D$和flow光流特征$x^{flow}<em>{n,t}\in \mathbb R^D$,再拼接在一起$X_n=[x</em>{n,1},…,x_{n,T}]\in \mathbb R^{2d\times T}$</p>
<p>特征提取这一步很简单和大多数的WTAL的方法相同</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202151403440.png" alt="image-20211202151403440"></p>
<h4 id="Feature-embedding"><a href="#Feature-embedding" class="headerlink" title="Feature embedding"></a>Feature embedding</h4><p>为了将提取的特征嵌入到特定于任务的空间中，作者使用一个一维卷积层，然后使用一个ReLU函数。</p>
<script type="math/tex; mode=display">
F_n=g_{embed}(X_n;\phi_{embed})</script><p>最终得到的$F<em>n=[f</em>{n,1},…,f_{n,T}]\in\mathbb R^{2D\times T}$</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202151949445.png" alt="image-20211202151949445"></p>
<h4 id="Segment-level-classification"><a href="#Segment-level-classification" class="headerlink" title="Segment-level classification"></a>Segment-level classification</h4><p>这一步需要得到类激活序列，使用一个分类器</p>
<script type="math/tex; mode=display">
A_n=g_{cls}(F_n;\phi_{cls})</script><p>其中$g_{cls}$表示线性分类器，最终得到的$A_n\in\mathbb R^{C\times T}$</p>
<h4 id="Action-score-aggregation"><a href="#Action-score-aggregation" class="headerlink" title="Action score aggregation"></a>Action score aggregation</h4><p>遵循之前的方法，采取topk均值的方法，从而获得该类别的分数</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202152829191.png" alt="image-20211202152829191"></p>
<p>再使用softmax，可以得到对应动作c的概率</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202153204454.png" alt="image-20211202153204454"></p>
<p>这个和之前的工作类似</p>
<h3 id="Uncertainty-modeling"><a href="#Uncertainty-modeling" class="headerlink" title="Uncertainty modeling"></a>Uncertainty modeling</h3><p>上面部分，是基本的WTAL步骤，里面并没有考虑背景。考虑到背景帧的不约束和不一致性，我们将背景作为WTAL的out-<br>of-distribution和uncertainty</p>
<p>考虑到视频片段$\tilde{s}_{n,t}$属于第c个动作的概率，可以用链式法则（条件概率公式）将其分解为两部分</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202155527868.png" alt="image-20211202155527868"></p>
<p>回想起条件概率公式支配的恐惧了</p>
<script type="math/tex; mode=display">
P(A|B)=P(A,B)/P(B)</script><p>所以有</p>
<script type="math/tex; mode=display">
P(A,B)=P(A|B)P(B)</script><p>当然再推下去就是贝叶斯了，这个就不细说。</p>
<h4 id="Uncertainty-formulation"><a href="#Uncertainty-formulation" class="headerlink" title="Uncertainty formulation"></a>Uncertainty formulation</h4><p>公式当中$P(y<em>{n,t}=c|d=1, \tilde{s}</em>{n,t})$，与一般分类任务一样，采用softmax函数进行估计。此外，有必要建模一个片段属于任何动作类的概率，也就是$P(d=1| \tilde{s}_{n,t})$的概率。</p>
<p>为了解决背景辨别问题。观察到动作帧的特征通常比背景帧的特征有更大的幅度(图2)，我们通过使用特征向量的幅度来表达不确定性。具体来说，背景特征的幅度较小，接近于0，而动作特征的幅度较大。</p>
<p>然后在n个视频$( \tilde{s}_{n,t})$中的t-th段是一个动作段的概率由:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202161510271.png" alt="image-20211202161510271"></p>
<p>其中$f<em>{n,t}$表示视频$\tilde{s}</em>{n,t}$的特征，而$\lVert \cdot \rVert$是一个范数函数(这里我们使用L-2范数)，m是预定义的一个特征值，从公式我们可以得到</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202161833408.png" alt="image-20211202161833408"></p>
<h4 id="Uncertainty-learning-via-multiple-instance-learning"><a href="#Uncertainty-learning-via-multiple-instance-learning" class="headerlink" title="Uncertainty learning via multiple instance learning"></a>Uncertainty learning via multiple instance learning</h4><p>为了只通过视频级别的标签来学习不确定性，我们借用了多实例学习的概念(Maron和LozanoPérez1998)，即使用一个包(视频)而不是实例(片段)来训练模型。在这个设置中，考虑到每个未修剪的视频都包含动作帧和背景帧，我们选择伪动作/背景段来表示视频。简单来说就是选择$k^{act}$个特征幅度最大的k个片段作为伪动作片段$\lbrace \tilde{s}<em>{n,t} |i\in S^{act} \rbrace$，选择$k^{bkg}$个片段作为伪背景片段$\lbrace \tilde{s}</em>{n,t} |j\in S^{bkg} \rbrace$。</p>
<h3 id="Training-objectives"><a href="#Training-objectives" class="headerlink" title="Training objectives"></a>Training objectives</h3><p>训练的损失总共有三个</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202163725110.png" alt="image-20211202163725110"></p>
<h4 id="Video-level-classification-loss"><a href="#Video-level-classification-loss" class="headerlink" title="Video-level classification loss"></a>Video-level classification loss</h4><p>对于多标签动作分类，我们使用二叉熵损失与标准化视频级标签</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202163806830.png" alt="image-20211202163806830"></p>
<p>很简单的一个损失比较常见</p>
<h4 id="Uncertainty-modeling-loss"><a href="#Uncertainty-modeling-loss" class="headerlink" title="Uncertainty modeling loss"></a>Uncertainty modeling loss</h4><p>为了学习不确定性，我们训练模型生成大特征量的伪动作片段，而生成小特征量的伪背景片段，如图3(a)所示。形式上，不确定性建模损失的形式为:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202164237878.png" alt="image-20211202164237878"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202164312359.png" alt="image-20211202164312359"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202164646695.png" alt="image-20211202164646695"></p>
<p>这个损失的含义是将动作特征拉的更远背景特征拉的更近，可以看这个m为特征距离，蓝色部分向m之外移动，红色部分向m之内移动。</p>
<h4 id="Background-entropy-loss"><a href="#Background-entropy-loss" class="headerlink" title="Background entropy loss"></a>Background entropy loss</h4><p>虽然不确定性建模损失鼓励背景部分为所有动作生成低对数，但由于softmax功能的相对性，某些动作类的softmax得分可能较高。为了防止背景片段对任何动作类都有较高的softmax得分，我们定义了一个损失函数，使背景片段的动作概率熵最大化，即，背景段对动作类强制具有均匀概率分布，如图3(b)所示。损失计算方法如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202164356143.png" alt="image-20211202164356143"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202164432247.png" alt="image-20211202164432247"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20211202164712103.png" alt="image-20211202164712103"></p>
<p>这个损失是为了防止背景在某个动作类上的softmax得分可能较高，为了将背景分数拉平而设计的一个函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章在前人提出背景的基础上再次加深了一步研究，思想性很强不亏是微软亚洲研究院出品的，我只能称之为神仙。</p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>时序动作定位</tag>
        <tag>弱监督</tag>
      </tags>
  </entry>
  <entry>
    <title>select小例子</title>
    <url>/2022/07/14/Linux/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/select%E5%B0%8F%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<h1 id="select小例子"><a href="#select小例子" class="headerlink" title="select小例子"></a>select小例子</h1><p>编写了一个客户端发字母过来，然后服务器把字母转成大写发送回去的例子，其中使用了select。</p>
<span id="more"></span>
<h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><p>客户端代码比较简单，就是连接服务器，然后发送到服务器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid port,please check out port&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> client_sockfd;</span><br><span class="line">    <span class="type">int</span> len,n;    </span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span> <span class="comment">//服务器端网络地址结构体</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    client_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//建立客户端socket</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    address.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    len = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="comment">//进行链接</span></span><br><span class="line">    result = connect(client_sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;address, len);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------connect ok----------------\n&quot;</span>);</span><br><span class="line">    <span class="comment">//从屏幕（标准输入）得到输入字母</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, BUF_SIZE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        write(client_sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        n = read(client_sockfd, buf, BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;the other side has been closed.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            write(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    close(client_sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h2><p>服务器端代码略微复杂一些，但是只要弄清select函数的参数以及相关的参数还是比较简单的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfdp, fd_set *readset, fd_set *writeset, fd_set *exceptset,<span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<p>maxfdp：被监听的文件描述符的总数，它比所有文件描述符集合中的文件描述符的最大值大1，因为文件描述符是从0开始计数的。</p>
<p>readfds、writefds、exceptset：分别指向可读、可写和异常等事件对应的描述符集合，这三个参数都是传入传出参数，都会作为结果传出。</p>
<p>timeout:用于设置select函数的超时时间，即告诉内核select等待多长时间之后就放弃等待。timeout == NULL 表示等待无限长的时间，也就是阻塞。</p>
<p>timeval结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span>      </span><br><span class="line">    <span class="type">long</span> tv_sec;   <span class="comment">/*秒 */</span></span><br><span class="line">    <span class="type">long</span> tv_usec;  <span class="comment">/*微秒 */</span>   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>返回值：超时返回0;失败返回-1；成功返回大于0的整数，这个整数表示就绪描述符的数目。</p>
<p>以下介绍与select函数相关的常见的几个宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span>   </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ZERO</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;   <span class="comment">//一个 fd_set类型变量的所有位都设为 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;  <span class="comment">//清除某个位时可以使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *fd_set)</span>;   <span class="comment">//设置变量的某个位置位</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>; <span class="comment">//测试某个位是否被置位</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>服务器代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid port,please check out port&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> server_sockfd, client_sockfd;</span><br><span class="line">    <span class="type">int</span> server_len, client_len;</span><br><span class="line">    <span class="type">int</span> fd_max, n;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE], str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="comment">// c中结构体使用，必须加struct</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    fd_set readfds, tempfds;</span><br><span class="line">    <span class="comment">//创建 服务器端 socket</span></span><br><span class="line">    server_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//准备地址</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_address, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_address));</span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_address.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    server_len = <span class="keyword">sizeof</span>(server_address);</span><br><span class="line">    <span class="comment">//设置绑定和监听</span></span><br><span class="line">    <span class="keyword">if</span> (bind(server_sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_address, server_len) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(server_sockfd, <span class="number">128</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server waiting\n&quot;</span>);</span><br><span class="line">    FD_ZERO(&amp;readfds);</span><br><span class="line">    FD_SET(server_sockfd, &amp;readfds); <span class="comment">//将服务器端socket 监听描述符加入到集合中</span></span><br><span class="line">    fd_max = server_sockfd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将需要监听的描述符复制给 tempfds</span></span><br><span class="line">        tempfds = readfds;</span><br><span class="line">        <span class="comment">// select第二个参数是传入传出参数，所以开始才需要复制</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 情况1.设置timeout的等待时间</span></span><br><span class="line">        timeout.tv_sec = <span class="number">3</span>;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// (fd_set)*0 和 NULL 用法相同</span></span><br><span class="line">        <span class="comment">// result = select(fd_max + 1, &amp;tempfds, NULL, NULL, &amp;timeout);</span></span><br><span class="line">        <span class="comment">// result = select(fd_max + 1, &amp;tempfds, (fd_set *)0, (fd_set *)0, &amp;timeout);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//情况2.设置select 阻塞的情况</span></span><br><span class="line">        result = select(fd_max + <span class="number">1</span>, &amp;tempfds, (fd_set *)<span class="number">0</span>, (fd_set *)<span class="number">0</span>, (<span class="keyword">struct</span> timeval *)<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------next--------\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            error_handling(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> fd = <span class="number">0</span>; fd &lt; fd_max + <span class="number">1</span>; fd++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//寻找到相关文件描述符</span></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(fd, &amp;tempfds))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断是否是监听文件描述符</span></span><br><span class="line">                <span class="keyword">if</span> (fd == server_sockfd)</span><br><span class="line">                &#123;</span><br><span class="line">                    client_len = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">                    client_sockfd = accept(server_sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_len);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d on fd %d\n&quot;</span>, inet_ntop(AF_INET, &amp;client_address.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                           ntohs(client_address.sin_port), client_sockfd);</span><br><span class="line">                    <span class="comment">//新的文件描述符加入读中</span></span><br><span class="line">                    FD_SET(client_sockfd, &amp;readfds);</span><br><span class="line">                    <span class="keyword">if</span> (fd_max &lt; client_sockfd)</span><br><span class="line">                        fd_max = client_sockfd;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//说明是读描述数</span></span><br><span class="line">                    <span class="keyword">if</span> ((n = read(fd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>)</span><br><span class="line">                    &#123; <span class="comment">/* 当client关闭链接时,服务器端也关闭对应链接 */</span></span><br><span class="line">                        close(fd);</span><br><span class="line">                        FD_CLR(fd, &amp;readfds); <span class="comment">/* 解除select对此文件描述符的监控 */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                            buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                        write(fd, buf, n);</span><br><span class="line">                        write(STDOUT_FILENO, buf, n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(server_sockfd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------server finish!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><h3 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h3><p>我们先运行情况1，设置等待时间为3秒。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况1.设置timeout的等待时间</span></span><br><span class="line">timeout.tv_sec = <span class="number">3</span>;</span><br><span class="line">timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// (fd_set)*0 和 NULL 用法相同</span></span><br><span class="line">result = select(fd_max + <span class="number">1</span>, &amp;tempfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br></pre></td></tr></table></figure>
<p>可以看到他等待3秒后就向下继续运行了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/select情况1.gif" alt="select情况1"></p>
<p>运行结果显示每3秒进行一次。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220715110925008.png" alt="image-20220715110925008"></p>
<h3 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h3><p>我们设置阻塞等待。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result = select(fd_max + <span class="number">1</span>, &amp;tempfds, (fd_set *)<span class="number">0</span>, (fd_set *)<span class="number">0</span>, (<span class="keyword">struct</span> timeval *)<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果显示，每次都是阻塞在那里，知道有写描述符集的使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220715111515047.png" alt="image-20220715111515047"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>select的使用的小例子比较简单，但是深入原理目前我还未了解，先写个小例子记录一下。</p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://blog.csdn.net/hyman_c/article/details/52801947">https://blog.csdn.net/hyman_c/article/details/52801947</a></li>
<li><a href="https://blog.csdn.net/hyman_c/article/details/53991111">https://blog.csdn.net/hyman_c/article/details/53991111</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsock2/nf-winsock2-select">https://docs.microsoft.com/zh-cn/windows/win32/api/winsock2/nf-winsock2-select</a></li>
<li><a href="https://www.cnblogs.com/alantu2018/p/8612722.html">https://www.cnblogs.com/alantu2018/p/8612722.html</a></li>
<li><a href="https://www.cnblogs.com/skyfsm/p/7079458.html">https://www.cnblogs.com/skyfsm/p/7079458.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux网络编程</category>
      </categories>
      <tags>
        <tag>Linux网络编程</tag>
        <tag>select</tag>
      </tags>
  </entry>
  <entry>
    <title>socket地址信息函数</title>
    <url>/2022/08/14/Linux/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="socket地址信息函数"><a href="#socket地址信息函数" class="headerlink" title="socket地址信息函数"></a>socket地址信息函数</h1><p>学习《Linux高性能服务器编程》第五章Linux网络编程基础API，为了印象深刻一些，多动手多实践，所以记下这个笔记。这一篇主要记录Linux中socket地址信息函数。</p>
<span id="more"></span>
<p>如果我们要查询一个连接socket的本端socket地址，以及远端的socket地址，可以使用下面两个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p><code>getsockname</code>获得<code>sockfd</code>对应的本端地址（本地自己的地址），<code>getpeername</code>获得<code>sockfd</code>对应的远端地址（远端连接的地址）。两个函数都把地址存储在<code>addr</code>参数指定的内存中，将该地址的长度存放在<code>addrlen</code>当中。</p>
<p>如果实际socket地址的长度大于<code>addr</code>所指内存区的大小，那么该socket地址将被截断。两个函数成功时返回0，失败返回-1并设置<code>errno</code>。</p>
<p>我写了代码测试了一下，使用telnet进行连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 256</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(sock, (sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = accept(sock, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> remote[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN), ntohs(client.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得本端地址</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">        <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">        ret = getsockname(connfd, (sockaddr *)&amp;addr, &amp;addrlen);</span><br><span class="line">        assert(ret == <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getsockname info ip: %s and port: %d , addrlen is %d \n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;addr.sin_addr, remote, INET_ADDRSTRLEN), ntohs(addr.sin_port), addrlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得远端地址</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr2</span>;</span></span><br><span class="line">        <span class="type">socklen_t</span> addrlen2 = <span class="keyword">sizeof</span>(addr2);</span><br><span class="line">        ret = getpeername(connfd, (sockaddr *)&amp;addr2, &amp;addrlen2);</span><br><span class="line">        assert(ret == <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getpeername info ip: %s and port: %d , addrlen is %d \n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;addr2.sin_addr, remote, INET_ADDRSTRLEN), ntohs(addr2.sin_port), addrlen2);</span><br><span class="line"></span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220813163338463.png" alt="image-20220813163338463"></p>
]]></content>
      <categories>
        <category>Linux网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
        <tag>计算机网络</tag>
        <tag>Linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>socket数据读写</title>
    <url>/2022/08/14/Linux/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<h1 id="socket数据读写"><a href="#socket数据读写" class="headerlink" title="socket数据读写"></a>socket数据读写</h1><p>学习《Linux高性能服务器编程》第五章Linux网络编程基础API，为了印象深刻一些，多动手多实践，所以记下这个笔记。这一篇主要记录Linux中socket数据读写的部分，包括TCP数据读写、UDP数据读写和通用数据读写。</p>
<span id="more"></span>
<h2 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h2><p>对文件的读写操作<code>read</code>和<code>write</code>同样适用于socket。但是socket编程接口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据的读写的控制。在TCP中流数据读写的系统调用是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p><code>recv</code>读取<code>sockfd</code>上的数据，<code>buf</code>和<code>len</code>参数分别指定读缓冲区的位置和大小。</p>
<p><code>recv</code>成功读取时返回实际读取到的数据长度，它可能小于我们期望的长度<code>len</code>。因此需要多次调用<code>recv</code>才能读取到完整的数据。<code>recv</code>返回0，意味着对方已经关闭连接。<code>recv</code>出错时返回-1并设置<code>errno</code>。</p>
<p><code>send</code>发送<code>sockfd</code>上的数据。<code>buf</code>和<code>len</code>参数分别指定写缓冲区的位置和大小。</p>
<p><code>send</code>成功读取时返回实际读取到的数据长度，出错时返回-1并设置<code>errno</code>。</p>
<p><code>flags</code>用于控制数据的接收和发送，一般来说设置为0，也可以进行设置，从而进行控制。</p>
<p>控制参数可以通过man手册进行查看，这里直接截取书上的表格</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812171929139.png" alt="image-20220812171929139"></p>
<h2 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>针对UDP系统提供的是读写函数是<code>recvfrom</code>和<code>sendto</code>，其中函数<code>recvfrom</code>和<code>sendto</code>前4个参数和<code>recv</code>、<code>send</code>意义相同，最后两个是发送端/接收端的地址。因为UDP是没有连接的概念，所以调用这两个函数的时候都要指定地址。<code>recvfrom</code>和<code>sendto</code>的返回值和<code>recv</code>、<code>send</code>也相同，所以不用过多介绍。</p>
<p>除此之外，<code>recvfrom</code>和<code>sendto</code>也可以用于TCP使用，只需要把最后两个参数设置为NULL即可。</p>
<h2 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p><code>recvmsg</code>和<code>sendmsg</code>的参数中<code>sockfd</code>和<code>flags</code>比较简单，复杂一些的参数就是<code>msg</code>。<code>msg</code>的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span>                    <span class="comment">/* Scatter/gather array items */</span></span><br><span class="line">   <span class="type">void</span>  *iov_base;              <span class="comment">/* Starting address */</span></span><br><span class="line">   <span class="type">size_t</span> iov_len;               <span class="comment">/* Number of bytes to transfer */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">   <span class="type">void</span>         *msg_name;       <span class="comment">/* Optional address */</span></span><br><span class="line">   <span class="type">socklen_t</span>     msg_namelen;    <span class="comment">/* Size of address */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">/* Scatter/gather array */</span></span><br><span class="line">   <span class="type">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">   <span class="type">void</span>         *msg_control;    <span class="comment">/* Ancillary data, see below */</span></span><br><span class="line">   <span class="type">size_t</span>        msg_controllen; <span class="comment">/* Ancillary data buffer len */</span></span><br><span class="line">   <span class="type">int</span>           msg_flags;      <span class="comment">/* Flags on received message */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>msg_name</code>指向socket地址，对于TCP协议无意义，所以在TCP协议中设置为NULL，而对于UDP等其他协议就说明了发送或者接收的地址。<code>msg_namelen</code>指定socket地址的长度。</p>
<p><code>msg_iov</code>是<code>iovec</code>类型的指针，根据注释来判断应该是个数组。<code>iovec</code>结构体封装了一块内存的起始位置和长度。<code>msg_iovlen</code>指定这样的<code>iovec</code>结构对象有多少个。</p>
<p>对于<code>recvmsg</code>而言，数据将被读取并存放在<code>msg_iovlen</code>块分散的内存中，这些内存的位置和长度则由<code>msg_iov</code>指向的数组指定，这称为分散读( scatter read);对于<code>sendmsg</code>而言，<code>msg_iovlen</code>块分散内存中的数据将被一并发送，这称为集中写( gather write)。</p>
<p>为什么要有分散读和集中写呢，这其实是一个非常方便的使用，方便传输结构不同的数据。比如：发送http应答时，我们可以把前面的<strong>请求头</strong>和<strong>请求的文件</strong>分为两个buffer，但是最终一起进行写入，减少了拼接带来的麻烦。同理我接收的时候也是想<strong>请求头</strong>和<strong>请求的文件</strong>分开，所以使用分散读。</p>
<p><code>msg_flags</code>成员无须设定，它会复制<code>recvmsg/sendmsg</code>的<code>flags</code>参数的内容以影响数据读写过程。<code>recvmsg</code>还会在调用结束前，将某些更新后的标志设置到<code>msg_flags</code>中。</p>
<p><code>recvmsg/sendmsg</code>的 <code>flags</code>参数以及返回值的含义均与<code>sendrecv</code>的 <code>flags</code>参数及返回值相同。</p>
<p><code>msg_control</code>和 <code>msg_controllen</code>成员用于辅助数据的传送。目前书中并未进行讲解，后续再补充。</p>
<p><code>recvmsg</code>和<code>sendmsg</code>的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 256</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(sock, (sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = accept(sock, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> remote[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN), ntohs(client.sin_port));</span><br><span class="line">		</span><br><span class="line">        <span class="type">char</span> buffer1[<span class="number">6</span>];</span><br><span class="line">        <span class="type">char</span> buffer2[BUFFER_SIZE];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">        bzero(&amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="comment">//设置集中写</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovec_arry</span>[2];</span></span><br><span class="line">        iovec_arry[<span class="number">0</span>].iov_base = (<span class="type">void</span> *)buffer1;</span><br><span class="line">        iovec_arry[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(buffer1);</span><br><span class="line">        iovec_arry[<span class="number">1</span>].iov_base = (<span class="type">void</span> *)buffer2;</span><br><span class="line">        iovec_arry[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(buffer2);</span><br><span class="line"></span><br><span class="line">        msg.msg_iov = iovec_arry;</span><br><span class="line">        msg.msg_iovlen = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = recvmsg(connfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        assert(n != <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; have recv %d byte msg1 %s and msg2 %s \n&quot;</span>, n, buffer1, buffer2);</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sendmsg</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer1[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buffer2[] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    bzero(&amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="comment">// 因为是针对TCP，所以msg_name无意义</span></span><br><span class="line">    msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置集中写</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovec_arry</span>[2];</span></span><br><span class="line">    iovec_arry[<span class="number">0</span>].iov_base = (<span class="type">void</span> *)buffer1;</span><br><span class="line">    iovec_arry[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(buffer1);</span><br><span class="line">    iovec_arry[<span class="number">1</span>].iov_base = (<span class="type">void</span> *)buffer2;</span><br><span class="line">    iovec_arry[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(buffer2);</span><br><span class="line"></span><br><span class="line">    msg.msg_iov = iovec_arry;</span><br><span class="line">    msg.msg_iovlen = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = sendmsg(sock, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    assert(n != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; have send %d byte msg1 %s and msg2 %s \n&quot;</span>, n, buffer1, buffer2);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220813123219330.png" alt="image-20220813123219330"></p>
<p>需要注意的是<code>recvmsg</code>只有在前面的buffer使用完之后，才会使用后面的buffer。这也是为啥把<code>buffer1</code>的大小设置为6</p>
]]></content>
      <categories>
        <category>Linux网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
        <tag>计算机网络</tag>
        <tag>Linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>socket相关命令</title>
    <url>/2022/08/14/Linux/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="socket相关命令"><a href="#socket相关命令" class="headerlink" title="socket相关命令"></a>socket相关命令</h1><p>学习《Linux高性能服务器编程》第五章Linux网络编程基础API，为了印象深刻一些，多动手多实践，所以记下这个笔记。这一篇主要记录Linux中socket相关的命令，包括创建socket、命名socket、监听socket、接受连接、发起连接和关闭连接。</p>
<span id="more"></span>
<h2 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h2><p>socket使用系统调用可以创建一个socket</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>
<p><code>domain</code>参数是告诉系统使用的是那个底层协议族，一般都是使用IPv4，所以使用<code>AF_INET</code>即可。关于<code>socket</code>系统调用支持的所有协议族，可以查看man手册（虽然参数名不一样，但是并无大碍）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812095854483.png" alt="image-20220812095854483"></p>
<p><code>type</code>参数指定服务类型。服务类型主要有<code>SOCK_STREAM</code>服务（流服务）和<code>SOCK_UGRAM</code>（数据报）服务。对TCP/IP协议族而言，其值取<code>SOCK_STREAM</code>表示传输层使用TCP协议，取<code>SOCK_DGRAM</code>表示传输层使用UDP协议。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812101617247.png" alt="image-20220812101617247"></p>
<p>并且从Linux内核2.6.17起，增加了<code>SOCK_NONBLOCK</code>和<code>SOCK_CLOEXEC</code>这两个标志值，表示将新创建的socket设为非阻塞，以及fork调用创建子进程时在子进程中关闭该socket。在Linux内核2.6.17前，需要调用<code>fcntl</code>进行设置。</p>
<p><code>protocol</code>参数设置具体的协议。但是在前两个参数确定的情况下，这个参数的值基本上唯一的，所有几乎在所有情况下，我们都把这个值设置为0，表示使用默认协议。</p>
<p>socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lfd = <span class="number">0</span>;</span><br><span class="line">    lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//创建一个 socket</span></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h2><p>创建socket时，我们指定了地址族，但是并没有给定具体的地址，这样作为服务器别人是访问不到我们的。将一个socket 与socket地址绑定称为给socket命名。命名socket的系统调用是bind。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p><code>bind</code>将<code>addr</code>所指的socket地址分配给未命名的<code>sockfd</code>文件描述符，<code>addrlen</code>参数指出该socket地址的长度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812104757237.png" alt="image-20220812104757237"></p>
<p><code>bind</code>成功时返回0，失败则返回-1并设置<code>errno</code>。其中两种常见的<code>errno</code>是<code>EACCES</code>和<code>EADDRINUSE</code>，它们的含义分别是:</p>
<ul>
<li><code>EACCES</code>，被绑定的地址是受保护的地址，仅超级用户能够访问。比如普通用户将socket绑定到知名服务端口（端口号为0~1023）上时，<code>bind</code>将返回<code>EACCES</code>错误。</li>
<li><code>EADDRINUSE</code>，被绑定的地址正在使用中。比如将socket绑定到一个处于<code>TIME_WAIT</code>状态的socket地址。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812105430276.png" alt="image-20220812105430276"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> lfd = <span class="number">0</span>, cfd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clit_addr; <span class="comment">// 定义服务器地址结构 和 客户端地址结构</span></span><br><span class="line">    <span class="type">socklen_t</span> clit_addr_len;                 <span class="comment">// 客户端地址结构大小</span></span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;                <span class="comment">// IPv4</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);         <span class="comment">// 转为网络字节序的 端口号</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 获取本机任意有效IP</span></span><br><span class="line"></span><br><span class="line">    lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//创建一个 socket</span></span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)); <span class="comment">//给服务器socket绑定地址结构（IP+port)</span></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h2><p>socket被命名后，还需要调用<code>listen</code>创建一个监听队列来存放处理的客户连接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812112118847.png" alt="image-20220812112118847"></p>
<p><code>sockfd</code>参数指定被监听的socket。<code>backlog</code>参数提示内核监听队列的最大长度。监听队列的长度如果超过<code>backlog</code>，服务器将不受理新的客户连接，客户端也将收到<code>ECONNREFUSED</code>错误信息。</p>
<p>在内核版本2.2之前的Linux中，<code>backlog</code>参数是指所有处于半连接状态（<code>SYN_RCVD</code>）和完全连接状态（<code>ESTABLISHED</code>)的socket 的上限。但自内核版本2.2之后，它只表示处于完全连接状态的socket的上限，处于半连接状态的socket的上限则由<code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>内核参数定义。<code>backlog</code>参数的典型值是5。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812113608890.png" alt="image-20220812113608890"></p>
<p><code>listen</code>成功时返回0，失败则返回-1并设置<code>erron</code>。</p>
<p>本来想测试<code>backlog</code>这个参数的效果，但是怎么也成功不了，不知道原因，以后有机会再进行尝试吧。</p>
<h2 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h2><p>接受连接通过<code>accept</code>进行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812143816774.png" alt="image-20220812143816774"></p>
<p><code>sockfd</code>指执行过<code>listen</code>的监听套接字的文件描述符。</p>
<p><code>addr</code>是传出参数，用来获取接受连接的远端socket地址，地址的长度由<code>addrlen</code>参数指出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(sock, (sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = accept(sock, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> remote[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN), ntohs(client.sin_port));</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812151534158.png" alt="image-20220812151534158"></p>
<p>并且<strong>书上面的实验</strong>说明了<code>accept</code>直接从监听队列中取出连接，而不论连接处于何种状态，更不关心任何网络状况的变化。比如：客户端在服务器<code>accept</code>之前就断网了，<code>accept</code>还是可以正常进行，它并不会返回错误。</p>
<h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><p>发动连接一般是客户端进行的，通过系统调用<code>connect</code>与服务器进行连接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812154447716.png" alt="image-20220812154447716"></p>
<p><code>sockfd</code>参数由socket系统调用返回一个<code>socket</code>。<code>addr</code>参数是服务器监听的<code>socket</code>地址。<code>addrlen</code>参数指这个地址长度。</p>
<p><code>connect</code>成功时返回0。一旦成功建立连接，<code>sockfd</code>就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。<code>connect</code>失败则返回-1并设置<code>errno</code>。其中两种常见的<code>errno</code>是<code>ECONNREFUSED</code>和<code>ETIMEDOUT</code>，它们的含义如下:</p>
<ul>
<li><code>ECONNREFUSED</code>表示目标端口不存在，连接被拒绝。</li>
<li><code>ETIMEDOUT</code>表示连接超时。</li>
</ul>
<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>关闭连接一般来说使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>
<p><code>fd</code>参数是待关闭的socket。不过，<code>close</code>并不会立即关闭这个连接，而是将<code>fd</code>的引用数量减1，直到<code>fd</code>引用数量为0，才真正关闭连接。在多进程程序中，一次<code>fork</code>系统调用默认将父进程中<code>socket</code>的引用计算加1，因此必须在子进程和父进程都对该<code>socket</code>进行<code>close</code>调用才能将连接关闭。</p>
<p>如果想立刻终止连接，直接调用<code>shutdown</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812160846669.png" alt="image-20220812160846669"></p>
<p><code>sockfd</code>参数是待关闭的socket，<code>howto</code>参数决定了<code>shutdown</code>的行为。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">可选值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SHUT_RD</td>
<td style="text-align:left">关闭sockfd上读的这一半。应用程序不能再针对socket文件描述符执行读操作，并且该sockct接收缓冲区中的数据都被丢弃。</td>
</tr>
<tr>
<td style="text-align:center">SHUT_WR</td>
<td style="text-align:left">关闭sockfd上写的这一半。sockfd 的发送缓冲区中的数据会在真正关闭连接之前全部发送出去，应用程序不可再对该socket文件描述符执行写操作。这种情况下，连接处于半关闭状态。</td>
</tr>
<tr>
<td style="text-align:center">SHUT_RDWR</td>
<td style="text-align:left">同时关闭sockfd上的读和写。</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出<code>shutdown</code>可以灵活的关闭socket上的读或写。而<code>close</code>在关闭连接时只能将<code>socket</code>上的读和写同时关闭。</p>
<p><code>shutdown</code>成功时返回0，失败则返回-1并设置<code>errno</code>。</p>
]]></content>
      <categories>
        <category>Linux网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
        <tag>计算机网络</tag>
        <tag>Linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>socket选项</title>
    <url>/2022/08/14/Linux/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h1><p>读取和设置socket文件描述的方法如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure>
<p><code>sockfd</code>参数指定被操纵的目标socket，<code>level</code>参数指定要操作的协议选项，<code>optname</code>参数则指定选项的名字，<code>optval</code>和<code>optlen</code>参数分别是操作选项的值和长度。截图了一下书中的表格。</p>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/socket选项.png" alt="socket选项"></p>
<p><code>getsockopt</code>和<code>setsockopt</code>这两个函数成功时返回0，失败时返回-1并设置<code>errno</code>。</p>
<p>需要注意的是，在服务器端<code>setsockopt</code>最好在<code>listen</code>之前进行调用（因为连接socket只能由accept调用返回，而accept 从 listen 监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤）。同理，对客户端而言，这些socket选项则应该在调用connect 函数之前设置，因为connect调用成功返回之后，TC三次握手已完成。</p>
<h3 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h3><p>设置服务器可以立即重启，不需要等待<code>TIME_WAIT</code>状态过去，可以使用<code>SO_REUSEADDR</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sock = socket( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">assert( sock &gt;= <span class="number">0</span> );</span><br><span class="line"><span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">setsockopt( sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>( reuse ) );</span><br></pre></td></tr></table></figure>
<p>经过setsockopt的设置之后，即使sock处于TIME_WAIT状态，与之绑定的socket地址也可以立即被重用。</p>
<h3 id="SO-RCVBUF和SO-SNDBUF"><a href="#SO-RCVBUF和SO-SNDBUF" class="headerlink" title="SO_RCVBUF和SO_SNDBUF"></a>SO_RCVBUF和SO_SNDBUF</h3><p><code>SO_RCVBUF</code>和<code>SO_SNDBUF</code>分别设置TCP接收缓冲区和发送缓冲区的大小。但是，当我们使用<code>setsockopt</code>设置TCP缓冲区大小时，系统都会将其值进行加倍，并且不会小于某个值。TCP接收缓冲区最小值是256字节，发送缓冲区最小是2048字节。小值是2048字节(不过，不同的系统可能有不同的默认最小值)。系统这样做的目的，主要是确保一个TCP连接拥有足够的空闲缓冲区来处理拥塞（比如快速重传算法就期望TCP接收缓冲区能至少容纳4个大小为SMSS的TCP报文段)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number receive_buffer_size\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> recvbuf = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(recvbuf);</span><br><span class="line">    setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line">    getsockopt(sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, (<span class="type">socklen_t</span> *)&amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the receive buffer size after settting is %d\n&quot;</span>, recvbuf);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sendbuf = atoi(argv[<span class="number">4</span>]);</span><br><span class="line">    len = <span class="keyword">sizeof</span>(sendbuf);</span><br><span class="line">    setsockopt(sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, <span class="keyword">sizeof</span>(sendbuf));</span><br><span class="line">    getsockopt(sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, (<span class="type">socklen_t</span> *)&amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the tcp send buffer size after setting is %d\n&quot;</span>, sendbuf);</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220813180440008.png" alt="image-20220813180440008"></p>
<p>emmm不知道为啥大小是这样，后续再看看。</p>
]]></content>
      <categories>
        <category>Linux网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
        <tag>计算机网络</tag>
        <tag>Linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>socket网络信息查询API</title>
    <url>/2022/08/14/Linux/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2API/</url>
    <content><![CDATA[<h1 id="socket网络信息查询API"><a href="#socket网络信息查询API" class="headerlink" title="socket网络信息查询API"></a>socket网络信息查询API</h1><p>学习《Linux高性能服务器编程》第五章Linux网络编程基础API，为了印象深刻一些，多动手多实践，所以记下这个笔记。这一篇主要记录Linux中socket网络信息查询API，包括gethostbyname和gethostbyaddr、getservbyname和getservbyport、getaddrinfo、getnameinfo。</p>
<p>socket当中两要素：IP和端口号，都是用数值表示的。但是有时候我们可以使用主机名代替IP，使用服务名代替端口号。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">telnet 127.0.0.1 80</span><br><span class="line">telnet localhost www</span><br></pre></td></tr></table></figure>
<p>这个功能就是使用网络信息API实现的。</p>
<span id="more"></span>
<h2 id="gethostbyname和gethostbyaddr"><a href="#gethostbyname和gethostbyaddr" class="headerlink" title="gethostbyname和gethostbyaddr"></a>gethostbyname和gethostbyaddr</h2><p><code>gethostbyname</code>函数根据主机名称获取主机的完整信息，<code>gethostbyaddr</code>函数根据IP地址获取主机的完整信息。<code>gethostbyname</code>函数通常先在本地的<code>/etc/hosts</code>配置文件中查找主机，如果没有找到，再去访问DNS服务器。这两个函数的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> h_errno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>       <span class="comment">/* for AF_INET */</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">socklen_t</span> len, <span class="type">int</span> type)</span>;</span><br></pre></td></tr></table></figure>
<p><code>name</code>参数表示目标主机的主机名。</p>
<p><code>addr</code>参数指定目标主机的IP地址，<code>len</code>参数指定<code>addr</code>的所指定IP的长度</p>
<p><code>type</code>参数指定IP地址的类型，比如<code>AF_INET</code>等</p>
<p>其中<code>hostent</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">   <span class="type">char</span>  *h_name;            <span class="comment">/* official name of host */</span></span><br><span class="line">   <span class="type">char</span> **h_aliases;         <span class="comment">/* alias list */</span></span><br><span class="line">   <span class="type">int</span>    h_addrtype;        <span class="comment">/* host address type */</span></span><br><span class="line">   <span class="type">int</span>    h_length;          <span class="comment">/* length of address */</span></span><br><span class="line">   <span class="type">char</span> **h_addr_list;       <span class="comment">/* list of addresses */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数介绍</p>
<p><code>h_name</code>:主机名<br><code>h_aliases</code>:主机别名列表，可能有多个<br><code>h_addrtype</code>:地址类型（地址族）<br><code>h_length</code>:地址长度<br><code>h_addr_list</code>:按网络字节序列出的主机IP地址列表</p>
<p>从网上找了个图显示了一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/Center.png" alt="img"></p>
<p><code>gethostbyname</code>举例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Use example: %s www.baidu.com\n&quot;</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hptr</span>;</span></span><br><span class="line"></span><br><span class="line">    hptr = gethostbyname(name);</span><br><span class="line">    <span class="keyword">if</span> (hptr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gethostbyname error for host: %s: %s\n&quot;</span>, name, hstrerror(h_errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出主机名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tofficial: %s\n&quot;</span>, hptr-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出主机的别名</span></span><br><span class="line">    <span class="type">char</span> **pptr;</span><br><span class="line">    <span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">for</span> (pptr = hptr-&gt;h_aliases; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\talias: %s\n&quot;</span>, *pptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出ip地址</span></span><br><span class="line">    <span class="keyword">switch</span> (hptr-&gt;h_addrtype)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> AF_INET:</span><br><span class="line">        pptr = hptr-&gt;h_addr_list;</span><br><span class="line">        <span class="keyword">for</span> (; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\taddress: %s\n&quot;</span>,</span><br><span class="line">                   inet_ntop(hptr-&gt;h_addrtype, *pptr, str, <span class="keyword">sizeof</span>(str)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unknown address type\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814105118617.png" alt="image-20220814105118617"></p>
<p><code>gethostbyaddr</code>举例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Use example: %s 127.0.0.1\n&quot;</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, ip, &amp;addr);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hptr</span>;</span></span><br><span class="line"></span><br><span class="line">    hptr = gethostbyaddr(&amp;addr, <span class="keyword">sizeof</span>(addr), AF_INET);</span><br><span class="line">    <span class="keyword">if</span> (hptr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gethostbyaddr error for host: %s: %s\n&quot;</span>, ip, hstrerror(h_errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出主机名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tofficial: %s\n&quot;</span>, hptr-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出主机的别名</span></span><br><span class="line">    <span class="type">char</span> **pptr;</span><br><span class="line">    <span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">for</span> (pptr = hptr-&gt;h_aliases; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\talias: %s\n&quot;</span>, *pptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出ip地址</span></span><br><span class="line">    <span class="keyword">switch</span> (hptr-&gt;h_addrtype)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> AF_INET:</span><br><span class="line">        pptr = hptr-&gt;h_addr_list;</span><br><span class="line">        <span class="keyword">for</span> (; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\taddress: %s\n&quot;</span>,</span><br><span class="line">                   inet_ntop(hptr-&gt;h_addrtype, *pptr, str, <span class="keyword">sizeof</span>(str)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unknown address type\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814105222471.png" alt="image-20220814105222471"></p>
<h2 id="getservbyname和getservbyport"><a href="#getservbyname和getservbyport" class="headerlink" title="getservbyname和getservbyport"></a>getservbyname和getservbyport</h2><p><code>getservbyname</code>函数根据名称获取某个服务的完整信息，<code>getservbyport</code>函数根据端口号获取某个服务的完整信息。它们实际上都是通过读取<code>/etc/services</code>文件来获取服务的信息的。这两个函数的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyport</span><span class="params">(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br></pre></td></tr></table></figure>
<p><code>name</code>参数指定目标服务的名字。</p>
<p><code>port</code>参数指定目标服务对应的端口号。</p>
<p><code>proto</code>参数指定服务类型，给它传递“tcp”表示获取流服务，给它传递“udp”表示获取数据报服务，给它传递NULL则表示获取所有类型的服务。</p>
<p>函数返回的<code>servent</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">   <span class="type">char</span>  *s_name;       <span class="comment">/* official service name */</span></span><br><span class="line">   <span class="type">char</span> **s_aliases;    <span class="comment">/* alias list */</span></span><br><span class="line">   <span class="type">int</span>    s_port;       <span class="comment">/* port number */</span></span><br><span class="line">   <span class="type">char</span>  *s_proto;      <span class="comment">/* protocol to use */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>s_name</code>：服务名称</p>
<p><code>s_aliases</code>：服务别名列表，可能有多个</p>
<p><code>s_port</code>：端口号</p>
<p><code>s_proto</code>：服务类型，通常是tcp或者udp</p>
<p><code>getservbyname</code>举例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">servent</span> *<span class="title">servinfo</span> =</span> getservbyname(<span class="string">&quot;ssh&quot;</span>, <span class="string">&quot;tcp&quot;</span>);</span><br><span class="line">    assert(servinfo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>, servinfo-&gt;s_name);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> **pptr;</span><br><span class="line">    <span class="keyword">for</span> (pptr = servinfo-&gt;s_aliases; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alias: %s\n&quot;</span>, *pptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;port is %d\n&quot;</span>, ntohs(servinfo-&gt;s_port));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;protocol is %s\n&quot;</span>, servinfo-&gt;s_proto);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814141312451.png" alt="image-20220814141312451"></p>
<p><code>getservbyport</code>举例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> port = <span class="number">80</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">servent</span> *<span class="title">servinfo</span> =</span> getservbyport(htons(port), <span class="string">&quot;tcp&quot;</span>);</span><br><span class="line">    assert(servinfo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>, servinfo-&gt;s_name);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> **pptr;</span><br><span class="line">    <span class="keyword">for</span> (pptr = servinfo-&gt;s_aliases; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alias: %s\n&quot;</span>, *pptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;port is %d\n&quot;</span>, ntohs(servinfo-&gt;s_port));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;protocol is %s\n&quot;</span>, servinfo-&gt;s_proto);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814142922859.png" alt="image-20220814142922859"></p>
<p>需要指出的是，上面讨论的4个函数都是不可重入的，即非线程安全的。不过<code>netdb.h</code>头文件给出了它们的可重入版本。正如Linux下所有其他函数的可重入版本的命名规则那样，这些函数的函数名是在原函数名尾部加上_<code>r (re-entrant)</code>。</p>
<h2 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h2><p><code>getaddrinfo</code>函数既能通过主机名获得IP地址（内部使用的是<code>gethostbyname</code>函数),也能通过服务名获得端口号（内部使用的是<code>getservbyname</code>函数)。它是否可重人取决于其内部调用的<code>gethostbyname</code>和<code>getservbyname</code>函数是否是它们的可重入版本。该函数的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *node, <span class="type">const</span> <span class="type">char</span> *service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **res)</span>;</span><br></pre></td></tr></table></figure>
<p><code>node</code>参数可以接收主机名，也可以接收字符串表示的IP地址，用点分十分制。</p>
<p><code>service</code>参数可以接收服务名，也可以接收字符串表示的十进制端口。</p>
<p><code>hints</code>参数是给<code>getaddrinfo</code>的一个提示，以对<code>getaddrinfo</code>的输出进行更精确的控制。<code>hints</code>参数可以设置为NULL，表示允许<code>getaddrinfo</code>反馈任何可用的结果。</p>
<p><code>res</code>参数返回一个链表，这个链表用于存储<code>getaddrinfo</code>反馈的结果。</p>
<p>除此之外，在我们调用完<code>getaddrinfo</code>之后，需要使用<code>freeaddrinfo</code>对res进行内存释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo *res)</span>;</span><br></pre></td></tr></table></figure>
<p><code>addrinfo</code>的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">   <span class="type">int</span>              ai_flags;</span><br><span class="line">   <span class="type">int</span>              ai_family;</span><br><span class="line">   <span class="type">int</span>              ai_socktype;</span><br><span class="line">   <span class="type">int</span>              ai_protocol;</span><br><span class="line">   <span class="type">socklen_t</span>        ai_addrlen;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span></span><br><span class="line">   <span class="type">char</span>            *ai_canonname;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ai_family</code>：地址族，比如：<code>AF_INET</code></p>
<p><code>ai_socktype</code>：服务类型，比如：<code>SOCK_STREAM</code></p>
<p><code>ai_protocol</code>：指具体的网络协议</p>
<p><code>ai_addrlen</code>：地址<code>ai_addr</code>的长度</p>
<p><code>ai_addr</code>：指向socket的地址</p>
<p><code>ai_canonname</code>：主机的别名</p>
<p><code>ai_next</code>：链表的下一个对象</p>
<p><code>ai_flags</code>可以取下表中标志</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814160248251.png" alt="image-20220814160248251"></p>
<p>当我们使用hints参数的时候，可以设置其<code>ai_flags</code>，<code>ai_family</code>，<code>ai_socktype</code>和<code>ai_protocol</code>四个字段，其他字段则必须被设置为NULL。</p>
<p><strong>根据主机名获取IP地址：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Use example: %s www.baidu.com\n&quot;</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">res</span>, *<span class="title">cur</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">char</span> ipbuf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_INET;   <span class="comment">/* Allow IPv4 */</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE; <span class="comment">/* For wildcard IP address */</span></span><br><span class="line">    hints.ai_protocol = <span class="number">0</span>;       <span class="comment">/* Any protocol */</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line"></span><br><span class="line">    ret = getaddrinfo(name, <span class="literal">NULL</span>, &amp;hints, &amp;res);</span><br><span class="line">    assert(ret &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (cur = res; cur != <span class="literal">NULL</span>; cur = cur-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        addr = (<span class="keyword">struct</span> sockaddr_in *)cur-&gt;ai_addr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip: %s\n&quot;</span>, inet_ntop(AF_INET, &amp;addr-&gt;sin_addr, ipbuf, cur-&gt;ai_addrlen));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alias: %s\n&quot;</span>, cur-&gt;ai_canonname);</span><br><span class="line">    &#125;</span><br><span class="line">    freeaddrinfo(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814165923059.png" alt="image-20220814165923059"></p>
<p>不过不知道为啥别名为null</p>
<p><strong>根据主机名和端口号获取地址信息：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Use example: %s 80\n&quot;</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *port = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> *hostname = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">res</span>, *<span class="title">cur</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">char</span> ipbuf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_UNSPEC; <span class="comment">/* Allow IPv4 */</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE; <span class="comment">/* For wildcard IP address */</span></span><br><span class="line">    hints.ai_protocol = <span class="number">0</span>;       <span class="comment">/* Any protocol */</span></span><br><span class="line">    hints.ai_socktype = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = getaddrinfo(hostname, port, &amp;hints, &amp;res);</span><br><span class="line"></span><br><span class="line">    assert(ret &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (cur = res; cur != <span class="literal">NULL</span>; cur = cur-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        addr = (<span class="keyword">struct</span> sockaddr_in *)cur-&gt;ai_addr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip: %s\n&quot;</span>, inet_ntop(AF_INET, &amp;addr-&gt;sin_addr, ipbuf, cur-&gt;ai_addrlen));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;port: %d\n&quot;</span>, ntohs(addr-&gt;sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alias: %s\n&quot;</span>, cur-&gt;ai_canonname);</span><br><span class="line">    &#125;</span><br><span class="line">    freeaddrinfo(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814170106763.png" alt="image-20220814170106763"></p>
<p>不过不知道为啥别名为null</p>
<h2 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h2><p><code>getnameinfo</code>函数能通过socket地址同时获得以字符串表示的<strong>主机名</strong>（内部使用的是<code>gethostbyaddr</code>函数）和<strong>服务名</strong>（内部使用的是<code>getservbyport</code>函数)。它是否可重入取决于其内部调用的gethostbyaddr和 getservbyport函数是否是它们的可重入版本。该函数的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen,<span class="type">char</span> *host, <span class="type">socklen_t</span> hostlen,</span></span><br><span class="line"><span class="params">                <span class="type">char</span> *serv, <span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p><code>getnameinfo</code>将返回的主机名存储在host参数指向的缓存中，将服务名存储在serv参数指向的缓存中，<code>hostlen</code>和 <code>servlen</code>参数分别指定这两块缓存的长度。flags参数控制<code>getnameinfo</code>的行为，它可以接收下表中的选项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814171842523.png" alt="image-20220814171842523"></p>
<p><code>getaddrinfo</code>和 <code>getnameinfo</code>函数成功时返回0，失败则返回错误码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Use example: %s 127.0.0.1 80\n&quot;</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">char</span> hostname[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> servername[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_dst</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_dst, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_dst));</span><br><span class="line">    addr_dst.sin_family = AF_INET;</span><br><span class="line">    addr_dst.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line">    addr_dst.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = getnameinfo((<span class="keyword">struct</span> sockaddr *)&amp;addr_dst, <span class="keyword">sizeof</span>(addr_dst), hostname, <span class="keyword">sizeof</span>(hostname), servername, <span class="keyword">sizeof</span>(servername), <span class="number">0</span>);</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hostname IP: %s \n&quot;</span>, hostname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;servername : %s \n&quot;</span>, servername);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814181037933.png" alt="image-20220814181037933"></p>
]]></content>
      <categories>
        <category>Linux网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
        <tag>计算机网络</tag>
        <tag>Linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始构建muduo（一）</title>
    <url>/2023/01/03/Linux/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAmuduo/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAmuduo%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="从0开始构建muduo（一）"><a href="#从0开始构建muduo（一）" class="headerlink" title="从0开始构建muduo（一）"></a>从0开始构建muduo（一）</h1><p>学习了陈硕老师的《Linux 多线程服务端编程：使用 muduo C++ 网络库》，想自己动手写一个玩具，模仿陈硕老师的muduo库。muduo库大概10000行，本人自己写的肯定简略很多（毕竟只是玩具），只是为了自己熟悉这个网络库的实现。</p>
<span id="more"></span>
<h2 id="使用epoll"><a href="#使用epoll" class="headerlink" title="使用epoll"></a>使用epoll</h2><p>使用epoll构建第一个版本，是个echo服务器。</p>
<p>代码只有一个<code>main.cpp</code>，大概有100多行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定义epoll_event 数组</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;epoll_event&gt; EventList;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_EXIT(m)     \</span></span><br><span class="line"><span class="meta">  do                    \</span></span><br><span class="line"><span class="meta">  &#123;                     \</span></span><br><span class="line"><span class="meta">    perror(m);          \</span></span><br><span class="line"><span class="meta">    exit(EXIT_FAILURE); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/***</span></span><br><span class="line"><span class="comment">   * 屏蔽 SIGPIPE SIGCHLD 信号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line">  <span class="built_in">signal</span>(SIGCHLD, SIG_IGN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/***</span></span><br><span class="line"><span class="comment">   * 打开一个文件描述符，解决EMFILE错误</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> idlefd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> listenfd;</span><br><span class="line">  <span class="keyword">if</span> ((listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/***</span></span><br><span class="line"><span class="comment">   * 设置端口重用，无需 TIME_WAIT</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="built_in">sizeof</span>(on)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd, SOMAXCONN) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; clients;</span><br><span class="line">  <span class="type">int</span> epollfd;</span><br><span class="line">  epollfd = <span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">  event.data.fd = listenfd;</span><br><span class="line">  event.events = EPOLLIN <span class="comment">/* | EPOLLET*/</span>;</span><br><span class="line">  <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, listenfd, &amp;event);</span><br><span class="line"></span><br><span class="line">  <span class="function">EventList <span class="title">events</span><span class="params">(<span class="number">16</span>)</span></span>;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peeraddr;</span><br><span class="line">  <span class="type">socklen_t</span> peerlen;</span><br><span class="line">  <span class="type">int</span> connfd;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> nready;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    nready = <span class="built_in">epoll_wait</span>(epollfd, &amp;*events.<span class="built_in">begin</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events.<span class="built_in">size</span>()), <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nready == <span class="number">0</span>) <span class="comment">// 什么都没有发生</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 当nready达到events的大小，说明可能有更多的事件触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">size_t</span>)nready == events.<span class="built_in">size</span>())</span><br><span class="line">      events.<span class="built_in">resize</span>(events.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nready; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (events[i].data.fd == listenfd)</span><br><span class="line">      &#123;</span><br><span class="line">        peerlen = <span class="built_in">sizeof</span>(peeraddr);</span><br><span class="line">        connfd = <span class="built_in">accept4</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;peeraddr,</span><br><span class="line">                         &amp;peerlen, SOCK_NONBLOCK | SOCK_CLOEXEC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (errno == EMFILE)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">/***</span></span><br><span class="line"><span class="comment">             * 发生EMFILE时的处理方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">close</span>(idlefd);</span><br><span class="line">            idlefd = <span class="built_in">accept</span>(listenfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">close</span>(idlefd);</span><br><span class="line">            idlefd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;accept4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ip=&quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(peeraddr.sin_addr) &lt;&lt; <span class="string">&quot; port=&quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(peeraddr.sin_port) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        clients.<span class="built_in">push_back</span>(connfd);</span><br><span class="line"></span><br><span class="line">        event.data.fd = connfd;</span><br><span class="line">        event.events = EPOLLIN <span class="comment">/* | EPOLLET*/</span>;</span><br><span class="line">        <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, connfd, &amp;event);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">      &#123;</span><br><span class="line">        connfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">read</span>(connfd, buf, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">          <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/***</span></span><br><span class="line"><span class="comment">           * 说明对方断开了连接</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;client close&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">          <span class="built_in">close</span>(connfd);</span><br><span class="line">          event = events[i];</span><br><span class="line">          <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, connfd, &amp;event);</span><br><span class="line">          clients.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(clients.<span class="built_in">begin</span>(), clients.<span class="built_in">end</span>(), connfd), clients.<span class="built_in">end</span>());</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; buf;</span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         * 写回对应的 内容，成为echo服务器</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">write</span>(connfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CMakeLists.txt</code>里面的配置</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(tinyMuduo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CXX_FLAGS -g -Wall)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;g++&quot;</span>)</span><br><span class="line"><span class="keyword">string</span>(REPLACE <span class="string">&quot;;&quot;</span> <span class="string">&quot; &quot;</span> CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CXX_FLAGS&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>build.sh</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"></span><br><span class="line">SOURCE_DIR=`<span class="built_in">pwd</span>`</span><br><span class="line">BUILD_DIR=<span class="variable">$&#123;BUILD_DIR:-build&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$BUILD_DIR</span> \</span><br><span class="line">  &amp;&amp; <span class="built_in">cd</span> <span class="variable">$BUILD_DIR</span> \</span><br><span class="line">  &amp;&amp; cmake <span class="variable">$SOURCE_DIR</span> \</span><br><span class="line">  &amp;&amp; make $*</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20230103221627821.png" alt="image-20230103221627821"></p>
<h2 id="程序需要注意的点"><a href="#程序需要注意的点" class="headerlink" title="程序需要注意的点"></a>程序需要注意的点</h2><h3 id="屏蔽信息"><a href="#屏蔽信息" class="headerlink" title="屏蔽信息"></a>屏蔽信息</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 屏蔽 SIGPIPE SIGCHLD 信号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line"><span class="built_in">signal</span>(SIGCHLD, SIG_IGN);</span><br></pre></td></tr></table></figure>
<p>屏蔽了<code>SIGPIPE</code>和<code>SIGCHLD</code>这两个信号。<code>SIGPIPE</code>信号是往读端被关闭的管道或者 socket 连接中写数据，默认是会终止进程，所以为了防止这种事情出现我们需要屏蔽这个信息。</p>
<h3 id="解决EMFILE错误"><a href="#解决EMFILE错误" class="headerlink" title="解决EMFILE错误"></a>解决EMFILE错误</h3><p>EMFILE错误是进程描述符用完的错误，在陈硕老师的视频中有专门讲解这个问题。目前的解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.调高进程文件描述符数目</span><br><span class="line">2.死等</span><br><span class="line">3.退出程序</span><br><span class="line">4.关闭监听套接字。那什么时候重新打开呢？</span><br><span class="line">5.如果是epoll模型，可以改用edge trigger。问题是如果漏掉了一次accept(2)，程序再也不会收到新连接。</span><br><span class="line">6.准备一个空闲的文件描述符。遇到这种情况，先关闭这个空闲文件，获得一个文件描述符名额;再accept(2)拿到socket连接的文件描述符；随后立刻close(2)，这样就优雅地断开了与客户端的连接；最后重新打开空闲文件，把“坑”填上，以备再次出现这种情况时使用。</span><br></pre></td></tr></table></figure>
<p>很显然推荐的方法是6，代码中使用的也是这种方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (errno == EMFILE)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/***</span></span><br><span class="line"><span class="comment">   * 发生EMFILE时的处理方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(idlefd);</span><br><span class="line">  idlefd = <span class="built_in">accept</span>(listenfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">close</span>(idlefd);</span><br><span class="line">  idlefd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;accept4&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="采取LT模式"><a href="#采取LT模式" class="headerlink" title="采取LT模式"></a>采取LT模式</h3><p>epoll需要采取LT模型，并且以<strong>非阻塞</strong>状态进行。为什么不采取ET模式呢，ET模式下EMFILE错误处理要复杂一些，为了简化代码，所以我们采取这种LT模式。</p>
<p>模式的过程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20230103221058350.png" alt="image-20230103221058350"></p>
<p>需要注意的是对于EPOLLOUT事件我们这里并没有处理，只是简单的直接写回，理论上应该加一层应用层缓冲区，这是后续需要改进的地方。</p>
<p>代码仓库：<a href="https://github.com/bugcat9/tinyMuduo/tree/v0.01">https://github.com/bugcat9/tinyMuduo/tree/v0.01</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始构建muduo（三）</title>
    <url>/2023/02/03/Linux/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAmuduo/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAmuduo%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="从0开始构建muduo（三）"><a href="#从0开始构建muduo（三）" class="headerlink" title="从0开始构建muduo（三）"></a>从0开始构建muduo（三）</h1><p>加入net模块相关代码，net模块相关代码是muduo库的精髓，后面看了一下其实也比较简洁，容易看懂。</p>
<p>首先是将之前main中大大的while循环进行封装，编程EventLoop</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!looping_);</span><br><span class="line">    <span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    looping_ = <span class="literal">true</span>;</span><br><span class="line">    quit_ = <span class="literal">false</span>; <span class="comment">// <span class="doctag">FIXME:</span> what if someone calls quit() before loop() ?</span></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;EventLoop &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; start looping&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!quit_)</span><br><span class="line">    &#123;</span><br><span class="line">        activeChannels_.<span class="built_in">clear</span>();</span><br><span class="line">        pollReturnTime_ = poller_-&gt;<span class="built_in">poll</span>(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">        ++iteration_;</span><br><span class="line">        <span class="keyword">if</span> (Logger::<span class="built_in">logLevel</span>() &lt;= Logger::TRACE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printActiveChannels</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO sort channel by priority</span></span><br><span class="line">        eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Channel *channel : activeChannels_)</span><br><span class="line">        &#123;</span><br><span class="line">            currentActiveChannel_ = channel;</span><br><span class="line">            currentActiveChannel_-&gt;<span class="built_in">handleEvent</span>(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line">        currentActiveChannel_ = <span class="literal">NULL</span>;</span><br><span class="line">        eventHandling_ = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;EventLoop &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; stop looping&quot;</span>;</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将那些文件描述符封装成<code>Channel</code>类，整个结构就比较简单明了。</p>
<p>对于<strong>Reactor</strong>模型封装了EventLoopThread、EventLoopThreadPool 专门处理io线程，也就是那些连接以及读写相关的线程。</p>
<p>对于应用层的发送和接收封装了buffer类。</p>
<p>最后将这一切封装在TcpServer类中。</p>
<p>所以我们实现echo也比较简单，这里面直接使用muduo自带的内容</p>
<p>echo.h:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ECHO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ECHO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net/TcpServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RFC 862</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EchoServer</span>(tinyMuduo::net::EventLoop *loop,</span><br><span class="line">               <span class="type">const</span> tinyMuduo::net::InetAddress &amp;listenAddr);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>; <span class="comment">// calls server_.start();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> tinyMuduo::net::TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> tinyMuduo::net::TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                   tinyMuduo::net::Buffer *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                   tinyMuduo::Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    tinyMuduo::net::TcpServer server_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _ECHO_H</span></span></span><br></pre></td></tr></table></figure>
<p>echo.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;echo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/Logging.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net/EventLoop.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace tinyMuduo;</span></span><br><span class="line"><span class="comment">// using namespace tinyMuduo::net;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; <span class="string">&quot;pid = &quot;</span> &lt;&lt; <span class="built_in">getpid</span>();</span><br><span class="line">  tinyMuduo::net::EventLoop loop;</span><br><span class="line">  tinyMuduo::<span class="function">net::InetAddress <span class="title">listenAddr</span><span class="params">(<span class="number">2007</span>)</span></span>;</span><br><span class="line">  <span class="function">EchoServer <span class="title">server</span><span class="params">(&amp;loop, listenAddr)</span></span>;</span><br><span class="line">  server.<span class="built_in">start</span>();</span><br><span class="line">  loop.<span class="built_in">loop</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;echo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/Logging.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net/EventLoop.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace tinyMuduo;</span></span><br><span class="line"><span class="comment">// using namespace tinyMuduo::net;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; <span class="string">&quot;pid = &quot;</span> &lt;&lt; <span class="built_in">getpid</span>();</span><br><span class="line">  tinyMuduo::net::EventLoop loop;</span><br><span class="line">  tinyMuduo::<span class="function">net::InetAddress <span class="title">listenAddr</span><span class="params">(<span class="number">2007</span>)</span></span>;</span><br><span class="line">  <span class="function">EchoServer <span class="title">server</span><span class="params">(&amp;loop, listenAddr)</span></span>;</span><br><span class="line">  server.<span class="built_in">start</span>();</span><br><span class="line">  loop.<span class="built_in">loop</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体差不多就是这样，感觉muduo书和视频讲的太好了，感觉也没什么好多说，没有让人写的欲望。后面可以加一下数据库和http服务，改成web服务器算了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始构建muduo（二）</title>
    <url>/2023/02/03/Linux/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAmuduo/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAmuduo%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="从0开始构建muduo（二）"><a href="#从0开始构建muduo（二）" class="headerlink" title="从0开始构建muduo（二）"></a>从0开始构建muduo（二）</h1><p>加入base模块下相关的代码，主要是和进程线程相关的操作封装，包括：原子类操作、线程操作、互斥锁、条件变量、日志类。这些原版都是是使用pthread相关实现的，自己实现的话可以通过C++11进行实现一下。</p>
<p>加入base模块之后，可以将echo的处理改成多线程(使用线程池)。</p>
<p>我这里实现是将接收到的消息进行了一个简单的翻转。</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/ThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/CurrentThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/Logging.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/LogFile.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定义epoll_event 数组</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;epoll_event&gt; EventList;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_EXIT(m)     \</span></span><br><span class="line"><span class="meta">  do                    \</span></span><br><span class="line"><span class="meta">  &#123;                     \</span></span><br><span class="line"><span class="meta">    perror(m);          \</span></span><br><span class="line"><span class="meta">    exit(EXIT_FAILURE); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;tinyMuduo::LogFile&gt; g_logFile;</span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::string&gt; buf_map;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outputFunc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  g_logFile-&gt;<span class="built_in">append</span>(msg, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flushFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  g_logFile-&gt;<span class="built_in">flush</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Set the Logger object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setLogger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  g_logFile.<span class="built_in">reset</span>(<span class="keyword">new</span> tinyMuduo::<span class="built_in">LogFile</span>(<span class="string">&quot;epoll&quot;</span>, <span class="number">500</span> * <span class="number">1000</span> * <span class="number">1000</span>, <span class="literal">false</span>));</span><br><span class="line">  tinyMuduo::Logger::<span class="built_in">setOutput</span>(outputFunc);</span><br><span class="line">  tinyMuduo::Logger::<span class="built_in">setFlush</span>(flushFunc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strFunc</span><span class="params">(std::string s, <span class="type">const</span> <span class="type">int</span> epollfd, <span class="type">const</span> <span class="type">int</span> connfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; <span class="string">&quot;tid=&quot;</span> &lt;&lt; tinyMuduo::CurrentThread::<span class="built_in">tid</span>() &lt;&lt; s;</span><br><span class="line">  <span class="comment">// 字符串翻转，相当于是处理计算任务</span></span><br><span class="line">  <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">  buf_map[connfd] = s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加读取事件</span></span><br><span class="line">  epoll_event event;</span><br><span class="line">  event.data.fd = connfd;</span><br><span class="line">  event.events = EPOLLOUT;</span><br><span class="line">  <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_MOD, connfd, &amp;event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 设置日志</span></span><br><span class="line">  <span class="built_in">setLogger</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/***</span></span><br><span class="line"><span class="comment">   * 屏蔽 SIGPIPE SIGCHLD 信号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line">  <span class="built_in">signal</span>(SIGCHLD, SIG_IGN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/***</span></span><br><span class="line"><span class="comment">   * 打开一个文件描述符，解决EMFILE错误</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> idlefd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> listenfd;</span><br><span class="line">  <span class="keyword">if</span> ((listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/***</span></span><br><span class="line"><span class="comment">   * 设置端口重用，无需 TIME_WAIT</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="built_in">sizeof</span>(on)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd, SOMAXCONN) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; clients;</span><br><span class="line">  <span class="type">int</span> epollfd;</span><br><span class="line">  epollfd = <span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">  event.data.fd = listenfd;</span><br><span class="line">  event.events = EPOLLIN <span class="comment">/* | EPOLLET*/</span>;</span><br><span class="line">  <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, listenfd, &amp;event);</span><br><span class="line"></span><br><span class="line">  <span class="function">EventList <span class="title">events</span><span class="params">(<span class="number">16</span>)</span></span>;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peeraddr;</span><br><span class="line">  <span class="type">socklen_t</span> peerlen;</span><br><span class="line">  <span class="type">int</span> connfd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程池相关设置</span></span><br><span class="line">  <span class="function">tinyMuduo::ThreadPool <span class="title">pool</span><span class="params">(<span class="string">&quot;pool&quot;</span>)</span></span>;</span><br><span class="line">  pool.<span class="built_in">start</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> nready;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    nready = <span class="built_in">epoll_wait</span>(epollfd, &amp;*events.<span class="built_in">begin</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events.<span class="built_in">size</span>()), <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nready == <span class="number">0</span>) <span class="comment">// 什么都没有发生</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 当nready达到events的大小，说明可能有更多的事件触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">size_t</span>)nready == events.<span class="built_in">size</span>())</span><br><span class="line">      events.<span class="built_in">resize</span>(events.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nready; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (events[i].data.fd == listenfd)</span><br><span class="line">      &#123;</span><br><span class="line">        peerlen = <span class="built_in">sizeof</span>(peeraddr);</span><br><span class="line">        connfd = <span class="built_in">accept4</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;peeraddr,</span><br><span class="line">                         &amp;peerlen, SOCK_NONBLOCK | SOCK_CLOEXEC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (errno == EMFILE)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">/***</span></span><br><span class="line"><span class="comment">             * 发生EMFILE时的处理方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">close</span>(idlefd);</span><br><span class="line">            idlefd = <span class="built_in">accept</span>(listenfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">close</span>(idlefd);</span><br><span class="line">            idlefd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;accept4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用日志</span></span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">&quot;ip=&quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(peeraddr.sin_addr) &lt;&lt; <span class="string">&quot; port=&quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(peeraddr.sin_port);</span><br><span class="line"></span><br><span class="line">        clients.<span class="built_in">push_back</span>(connfd);</span><br><span class="line"></span><br><span class="line">        event.data.fd = connfd;</span><br><span class="line">        event.events = EPOLLIN <span class="comment">/* | EPOLLET*/</span>;</span><br><span class="line">        <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, connfd, &amp;event);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">      &#123;</span><br><span class="line">        connfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">read</span>(connfd, buf, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">          <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/***</span></span><br><span class="line"><span class="comment">           * 说明对方断开了连接</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          LOG_INFO &lt;&lt; <span class="string">&quot;client close&quot;</span>;</span><br><span class="line">          <span class="built_in">close</span>(connfd);</span><br><span class="line">          event = events[i];</span><br><span class="line">          <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, connfd, &amp;event);</span><br><span class="line">          clients.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(clients.<span class="built_in">begin</span>(), clients.<span class="built_in">end</span>(), connfd), clients.<span class="built_in">end</span>());</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG_INFO &lt;&lt; buf;</span><br><span class="line">        <span class="comment">// 放入线程池中运行</span></span><br><span class="line">        <span class="comment">// strFunc(std::string(buf), epollfd, connfd);</span></span><br><span class="line">        pool.<span class="built_in">run</span>(std::<span class="built_in">bind</span>(strFunc, std::<span class="built_in">string</span>(buf), epollfd, connfd));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">      &#123;</span><br><span class="line">        connfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf_map.<span class="built_in">count</span>(connfd))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 读取处理好的缓存</span></span><br><span class="line">          std::string s = buf_map[connfd];</span><br><span class="line">          <span class="type">const</span> <span class="type">char</span> *buf = s.<span class="built_in">c_str</span>();</span><br><span class="line">          <span class="built_in">write</span>(connfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">          <span class="comment">// 删除缓存</span></span><br><span class="line">          buf_map.<span class="built_in">erase</span>(connfd);</span><br><span class="line">          <span class="comment">// 写完后将事件改为监听</span></span><br><span class="line">          event = events[i];</span><br><span class="line">          event.events = EPOLLIN;</span><br><span class="line">          <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_MOD, connfd, &amp;event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          LOG_ERROR &lt;&lt; <span class="string">&quot;connfd &quot;</span> &lt;&lt; connfd &lt;&lt; <span class="string">&quot;dont have buf&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLite学习</title>
    <url>/2021/08/23/Android%E5%AD%A6%E4%B9%A0/SQLite%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="SQLite学习"><a href="#SQLite学习" class="headerlink" title="SQLite学习"></a>SQLite学习</h1><p>SQLite是Android自带的数据库，是学习<code>Android</code>所必须了解的内容之一。</p>
<p>由于JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，会消耗太多的系统资源，对于手机这种内存受限设备来说并不合适。因此Android 提供了一些新的 API 来使用 SQLite 数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库存储在 data/data/&lt; 项目文件夹 &gt;/databases/ 下。</span><br></pre></td></tr></table></figure>
<p>为了比较好的学习该部分内容我们需要举个例子，所以我们以学生表格(学生表格平时，平时学习最多)为例来学习该内容。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>_id</th>
<th>uuid</th>
<th>name</th>
<th>birth_date</th>
<th>gender</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>12154453131</td>
<td>zhangsan</td>
<td>1309564646</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>87478478994</td>
<td>lisi</td>
<td>1235465487</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<span id="more"></span>
<h2 id="定义表格架构"><a href="#定义表格架构" class="headerlink" title="定义表格架构"></a>定义表格架构</h2><p>定义表格的话我们先创建学生类，学生类当中有对应的<code>get</code>和<code>set</code>函数，整个类比较简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UUID mUUID;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> Date mBirthDate;</span><br><span class="line">    <span class="keyword">private</span> Boolean mGender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UUID <span class="title function_">getUUID</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mUUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUUID</span><span class="params">(UUID UUID)</span> &#123;</span><br><span class="line">        mUUID = UUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getBirthDate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBirthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirthDate</span><span class="params">(Date birthDate)</span> &#123;</span><br><span class="line">        mBirthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mGender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(Boolean mgender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mGender = mgender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于数据库我们创建<code>StudentSchema</code>类，将需要的表名和表字段放在一起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.sqlitelearn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentSchema</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StudentTable</span> &#123;</span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         * 数据库表名</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TABLE_NAME</span> <span class="operator">=</span> <span class="string">&quot;Student&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         *定义数据表字段</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cols</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UUID</span> <span class="operator">=</span> <span class="string">&quot;uuid&quot;</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;name&quot;</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BIRTH_DATE</span> <span class="operator">=</span> <span class="string">&quot;birth_date&quot;</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GENDER</span> <span class="operator">=</span> <span class="string">&quot;gender&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为啥这样放呢，我看官方的例子和《Android权威编程指南》上使用的类都是这样，上面的解释是说有了这些数据表元素，就可以在Java代码中安全地引用，比如：<code>StudentTable.Cols.NAME</code>就是指向<code>student</code>的<code>name</code>字段，并且这还给修改字段名称或新增表元素带来了方便。</p>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><h3 id="编写建表语句"><a href="#编写建表语句" class="headerlink" title="编写建表语句"></a>编写建表语句</h3><p>创建数据库需要先写对应的语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 创建数据表语句</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SQL_CREATE_ENTRIES</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;CREATE TABLE &quot;</span> + StudentTable.TABLE_NAME + <span class="string">&quot; (&quot;</span> +</span><br><span class="line">                <span class="string">&quot;_id integer primary key autoincrement,&quot;</span> +</span><br><span class="line">                StudentTable.Cols.UUID + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">                StudentTable.Cols.NAME + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">                StudentTable.Cols.BIRTH_DATE + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">                StudentTable.Cols.GENDER + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 删除数据表语句</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SQL_DELETE_ENTRIES</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;DROP TABLE IF EXISTS &quot;</span> + StudentTable.TABLE_NAME;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="继承SQLiteDatabase"><a href="#继承SQLiteDatabase" class="headerlink" title="继承SQLiteDatabase"></a>继承<code>SQLiteDatabase</code></h3><p>编写数据库语句之后我们需要创建一个<code>SQLiteDatabase</code>实例，然后才能进行数据库相关得创建和操作，这个可以使用<code>Android</code>提供的<code>Context</code>底层方法<code>openOrCreateDatabase(...)</code>和<code>databaseList()</code>，打开数据库文件并将其转化为<code>SQLiteDatabase</code>实例，但是推荐的做法是使用<code>SQLiteOpenHelper</code>来辅助我们完成数据库表的创建和删除。</p>
<p><code>SQLiteOpenHelper</code>是一个抽象类，我们创建<code>StudentBaseHelper</code>来继承它。继承之后必须完成构造函数 、<code>onCreate</code>和<code>onUpgrade</code></p>
<p>函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentBaseHelper</span> <span class="keyword">extends</span> <span class="title class_">SQLiteOpenHelper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VERSION</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DATABASE_NAME</span> <span class="operator">=</span> <span class="string">&quot;studentBase.db&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 创建数据表语句</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SQL_CREATE_ENTRIES</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;CREATE TABLE &quot;</span> + StudentTable.TABLE_NAME + <span class="string">&quot; (&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;_id integer primary key autoincrement,&quot;</span> +</span><br><span class="line">                    StudentTable.Cols.UUID + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">                    StudentTable.Cols.NAME + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">                    StudentTable.Cols.BIRTH_DATE + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">                    StudentTable.Cols.GENDER + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 删除数据表语句</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SQL_DELETE_ENTRIES</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;DROP TABLE IF EXISTS &quot;</span> + StudentTable.TABLE_NAME;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentBaseHelper</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, DATABASE_NAME, <span class="literal">null</span>, VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(SQLiteDatabase db)</span> &#123;</span><br><span class="line">        db.execSQL(SQL_CREATE_ENTRIES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="type">int</span> oldVersion, <span class="type">int</span> newVersion)</span> &#123;</span><br><span class="line">        <span class="comment">//先删除再创建</span></span><br><span class="line">        <span class="keyword">if</span> (oldVersion &lt; newVersion) &#123;</span><br><span class="line">            db.execSQL(SQL_DELETE_ENTRIES);</span><br><span class="line">            onCreate(db);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onCreate(SQLiteDatabase)</code>方法负责创建初始数据库,代码比较简单。</p>
<p><code>onUpgrade(SQLiteDatabase, int, int)</code>方法负责与升级相关的工作，比如：我们后续如果后续如果升级了软件的版本，就需要调用这个方法，在这里我们采取的方法是先删除再创建，这样会把原来的表删除再创建一个，这样的话会使用原来的数据消失，不过在这里是给定一个例子所以不用考虑这么多，现实中开发的话，数据也会在后端保存在数据库上，在<code>Android</code>部分也只起到一个缓存作用所以不需要担心。</p>
<p>目前我想实验调用<code>onUpgrade</code>方法，但是改变版本号之后该方法也没有被调用不知道是为啥，可能需要手动调用</p>
<p>接着我们在<code>MainActivity</code>中实例化<code>SQLiteOpenHelper</code>，然后创建<code>SQLiteDatabase</code>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase mDatabase;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//创建SQLiteDatabase实例</span></span><br><span class="line">        mDatabase = <span class="keyword">new</span> <span class="title class_">StudentBaseHelper</span>(<span class="built_in">this</span>).getWritableDatabase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>运行程序之后</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210824165234403.png" alt="image-20210824165234403"></p>
<p>可以查看到<code>studentBase.db</code>生成了</p>
<h2 id="插入数据库"><a href="#插入数据库" class="headerlink" title="插入数据库"></a>插入数据库</h2><p>数据的增删改查操作，先讲解插入操作</p>
<h3 id="使用-ContentValues"><a href="#使用-ContentValues" class="headerlink" title="使用 ContentValues"></a>使用 <code>ContentValues</code></h3><p>负责处理数据库写入和更新操作的辅助类是<code>ContentValues</code>。它是一个键值存储类，类似于 <code>Java</code>的<code>HashMap</code>和前面用过的<code>Bundle</code>。不同的是，<code>ContentValues</code>只能用于处理<code>SQLite</code>数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ContentValues <span class="title function_">getContentValues</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">    <span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">    values.put(StudentTable.Cols.UUID, student.getUUID().toString());</span><br><span class="line">    values.put(StudentTable.Cols.NAME, student.getName());</span><br><span class="line">    values.put(StudentTable.Cols.BIRTH_DATE, student.getBirthDate().getTime());</span><br><span class="line">    values.put(StudentTable.Cols.GENDER, student.getGender() ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写插入代码"><a href="#编写插入代码" class="headerlink" title="编写插入代码"></a>编写插入代码</h3><p>插入调用<code>insert(String, String, ContentValues)</code>方法就行，方法的第一和第三个参数很重要，第二个很少用到。传入的第一个参数是数据表名（StudentTable.TABLE_NAME），第三个是要写入的数据。第二个参数使用可以参考官方文档👉<a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase#insert(java.lang.String,%20java.lang.String,%20android.content.ContentValues">https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase#insert(java.lang.String,%20java.lang.String,%20android.content.ContentValues</a>)</p>
<p><code>insert(String, String, ContentValues)</code>方法的返回值是long类型，代表新插入行的行 ID，并且如果发生错误，则返回-1</p>
<p>我们可以写出该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">    <span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> getContentValues(student);</span><br><span class="line">    <span class="type">long</span> <span class="variable">newRowId</span> <span class="operator">=</span> mDatabase.insert(StudentTable.TABLE_NAME, <span class="literal">null</span>, values);</span><br><span class="line">    <span class="keyword">return</span> newRowId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>onCreate</code>中进行调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_main);</span><br><span class="line">      <span class="comment">//创建SQLiteDatabase实例</span></span><br><span class="line">      mDatabase = <span class="keyword">new</span> <span class="title class_">StudentBaseHelper</span>(<span class="built_in">this</span>).getWritableDatabase();</span><br><span class="line"></span><br><span class="line">      <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">      student.setUUID(UUID.randomUUID());</span><br><span class="line">      student.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">      student.setBirthDate(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">      student.setGender(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//添加学生</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> addStudent(student);</span><br><span class="line">      <span class="keyword">if</span> (id == -<span class="number">1</span>) &#123;</span><br><span class="line">          Log.d(TAG, <span class="string">&quot;add student fail&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Log.d(TAG, <span class="string">&quot;add student success and id=&quot;</span> + id);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210824224153789.png" alt="image-20210824224153789"></p>
<p>使用<code>SQLiteStudio</code>进行查看生成的db文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210824225156765.png" alt="image-20210824225156765"></p>
<h2 id="从数据库中读取信息"><a href="#从数据库中读取信息" class="headerlink" title="从数据库中读取信息"></a>从数据库中读取信息</h2><h3 id="query函数"><a href="#query函数" class="headerlink" title="query函数"></a><code>query</code>函数</h3><p>读取数据需要用到<code>SQLiteDatabase.query(...)</code>方法。这个方法有好几个重载版本，具体的需要查询官方提供的文档，该方法会返回一个<code>Cursor</code>类型。我们本次使用的使用的<code>query</code>是下面那个版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">( </span></span><br><span class="line"><span class="params"> String table, //数据库表名</span></span><br><span class="line"><span class="params"> String[] columns, //查询的列名，如果为<span class="literal">null</span>，则返回所以列</span></span><br><span class="line"><span class="params"> String where, //where条件语句，其中有?作为占位符</span></span><br><span class="line"><span class="params"> String[] whereArgs, //对应占位符相应的内容</span></span><br><span class="line"><span class="params"> String groupBy, //分组</span></span><br><span class="line"><span class="params"> String having, </span></span><br><span class="line"><span class="params"> String orderBy, //排序</span></span><br><span class="line"><span class="params"> String limit)</span> </span><br></pre></td></tr></table></figure>
<p>如果学过数据库，应该对上面这些参数都比较熟悉，具体需要向数据库方面细讲，这里就不展开了。</p>
<h3 id="编写对应的函数"><a href="#编写对应的函数" class="headerlink" title="编写对应的函数"></a>编写对应的函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Cursor <span class="title function_">queryStudents</span><span class="params">(String whereClause, String[] whereArgs)</span> &#123;</span><br><span class="line">    <span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> mDatabase.query(</span><br><span class="line">            StudentTable.TABLE_NAME,</span><br><span class="line">            <span class="literal">null</span>, <span class="comment">// Columns - null selects all columns</span></span><br><span class="line">            whereClause,</span><br><span class="line">            whereArgs,</span><br><span class="line">            <span class="literal">null</span>, <span class="comment">// groupBy</span></span><br><span class="line">            <span class="literal">null</span>, <span class="comment">// having</span></span><br><span class="line">            <span class="literal">null</span> <span class="comment">// orderBy</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> cursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候需要这样使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> queryStudents(StudentTable.Cols.NAME + <span class="string">&quot;=?&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;zhangsan&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="使用CursorWrapper"><a href="#使用CursorWrapper" class="headerlink" title="使用CursorWrapper"></a>使用<code>CursorWrapper</code></h3><p><code>Cursor</code>在我理解看来有点类似于数据库中的游标，由于从<code>Curor</code>中提取的代码都类似基本上都是调用<code>cursor.getColumnIndex</code>方法，所以我们可以考虑使用<code>CursorWrapper</code>里面提供一些封装好了函数，方便我们使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentCursorWrapper</span> <span class="keyword">extends</span> <span class="title class_">CursorWrapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a cursor wrapper.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cursor The underlying cursor to wrap.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentCursorWrapper</span><span class="params">(Cursor cursor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cursor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uuidString</span> <span class="operator">=</span> getString(getColumnIndex(StudentTable.Cols.UUID));</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getString(getColumnIndex(StudentTable.Cols.NAME));</span><br><span class="line">        <span class="type">long</span> <span class="variable">date</span> <span class="operator">=</span> getLong(getColumnIndex(StudentTable.Cols.BIRTH_DATE));</span><br><span class="line">        <span class="type">int</span> <span class="variable">gender</span> <span class="operator">=</span> getInt(getColumnIndex(StudentTable.Cols.GENDER));</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setUUID(UUID.fromString(uuidString));</span><br><span class="line">        student.setName(name);</span><br><span class="line">        student.setBirthDate(<span class="keyword">new</span> <span class="title class_">Date</span>(date));</span><br><span class="line">        student.setGender(gender != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h3><p>我们在<code>onCreate</code>中调用这个代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//创建SQLiteDatabase实例</span></span><br><span class="line">        mDatabase = <span class="keyword">new</span> <span class="title class_">StudentBaseHelper</span>(<span class="built_in">this</span>).getWritableDatabase();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Student student = new Student();</span></span><br><span class="line"><span class="comment">//        student.setUUID(UUID.randomUUID());</span></span><br><span class="line"><span class="comment">//        student.setName(&quot;zhangsan&quot;);</span></span><br><span class="line"><span class="comment">//        student.setBirthDate(new Date());</span></span><br><span class="line"><span class="comment">//        student.setGender(true);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        long id = addStudent(student);</span></span><br><span class="line"><span class="comment">//        if (id == -1) &#123;</span></span><br><span class="line"><span class="comment">//            Log.d(TAG, &quot;add student fail&quot;);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Log.d(TAG, &quot;add student success and id=&quot; + id);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> queryStudents(StudentTable.Cols.NAME + <span class="string">&quot;=?&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;zhangsan&quot;</span>&#125;);</span><br><span class="line">        <span class="type">StudentCursorWrapper</span> <span class="variable">cursorWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentCursorWrapper</span>(cursor);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor.getCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;查无此人&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cursorWrapper.moveToFirst();</span><br><span class="line">                <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> cursorWrapper.getStudent();</span><br><span class="line">                <span class="comment">//打印uuid</span></span><br><span class="line">                Log.d(TAG, student.getUUID().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            cursorWrapper.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们查询<code>zhangsan</code>并打印他的<code>uuid</code>，结合前面使用<code>SQLiteStudio</code>查看的信息，发现是一样的，也说明了我们访问到了数据库中的信息，如果需要访问不要信息，只需要写不同的where语句就行，这部分自行查阅数据库知识。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210825155657523.png" alt="image-20210825155657523"></p>
<h2 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h2><h3 id="update函数"><a href="#update函数" class="headerlink" title="update函数"></a><code>update</code>函数</h3><p>更新数据库信息使用的是<code>update</code>函数，该函数有点类似于<code>insert()</code>函数，但是其中的<code>whereClause</code>和<code>whereArgs</code>有点类似于<code>query()</code>函数，简单理解就是通过<code>whereClause</code>和<code>whereArgs</code>查询对应的数据，并把他们更改为<code>values</code>，这个<code>int</code>类型的返回值代表影响了多少行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span> <span class="params">(String table, </span></span><br><span class="line"><span class="params">                ContentValues values, </span></span><br><span class="line"><span class="params">                String whereClause, </span></span><br><span class="line"><span class="params">                String[] whereArgs)</span></span><br></pre></td></tr></table></figure>
<h3 id="编写更新代码"><a href="#编写更新代码" class="headerlink" title="编写更新代码"></a>编写更新代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">updateStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">uuidString</span> <span class="operator">=</span> student.getUUID().toString();</span><br><span class="line">    <span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> getContentValues(student);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mDatabase.update(StudentTable.TABLE_NAME, values,</span><br><span class="line">            StudentTable.Cols.UUID + <span class="string">&quot;=?&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;uuidString&#125;);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-3"><a href="#运行结果-3" class="headerlink" title="运行结果"></a>运行结果</h3><p>我们查找zhangsan并且把他名字改为lisi</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//创建SQLiteDatabase实例</span></span><br><span class="line">        mDatabase = <span class="keyword">new</span> <span class="title class_">StudentBaseHelper</span>(<span class="built_in">this</span>).getWritableDatabase();</span><br><span class="line"><span class="comment">//        Student student = new Student();</span></span><br><span class="line"><span class="comment">//        student.setUUID(UUID.randomUUID());</span></span><br><span class="line"><span class="comment">//        student.setName(&quot;zhangsan&quot;);</span></span><br><span class="line"><span class="comment">//        student.setBirthDate(new Date());</span></span><br><span class="line"><span class="comment">//        student.setGender(true);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        long id = addStudent(student);</span></span><br><span class="line"><span class="comment">//        if (id == -1) &#123;</span></span><br><span class="line"><span class="comment">//            Log.d(TAG, &quot;add student fail&quot;);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Log.d(TAG, &quot;add student success and id=&quot; + id);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> queryStudents(StudentTable.Cols.NAME + <span class="string">&quot;=?&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;zhangsan&quot;</span>&#125;);</span><br><span class="line">        <span class="type">StudentCursorWrapper</span> <span class="variable">cursorWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentCursorWrapper</span>(cursor);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor.getCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;查无此人&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cursorWrapper.moveToFirst();</span><br><span class="line">                student = cursorWrapper.getStudent();</span><br><span class="line">                Log.d(TAG, student.getUUID().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            cursorWrapper.close();</span><br><span class="line">        &#125;</span><br><span class="line">        student.setName(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        updateStudent(student);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到更改成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210825164221338.png" alt="image-20210825164221338"></p>
<h2 id="删除数据库中相关信息"><a href="#删除数据库中相关信息" class="headerlink" title="删除数据库中相关信息"></a>删除数据库中相关信息</h2><p>删除函数调用的是<code>delete()</code>函数，看了前面的查找和更新后删除函数还是比较简单的，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span> <span class="params">(String table, </span></span><br><span class="line"><span class="params">                String whereClause, </span></span><br><span class="line"><span class="params">                String[] whereArgs)</span></span><br></pre></td></tr></table></figure>
<h3 id="编写删除代码"><a href="#编写删除代码" class="headerlink" title="编写删除代码"></a>编写删除代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">deleteStudent</span><span class="params">(String whereClause, String[] whereArgs)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mDatabase.delete(StudentTable.TABLE_NAME, whereClause, whereArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-4"><a href="#运行结果-4" class="headerlink" title="运行结果"></a>运行结果</h3><p>我们运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">deleteStudent(</span><br><span class="line">        StudentTable.Cols.NAME + <span class="string">&quot;=?&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;lisi&quot;</span>&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210825165546907.png" alt="image-20210825165546907"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SQLite数据库的增删改查总算大功告成，自己照着书上学的写也学到一些知识，不过现在官方好像推荐使用Room进行持久化，等有空再研究一下这个</p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://developer.android.com/training/data-storage/sqlite">https://developer.android.com/training/data-storage/sqlite</a></li>
<li>《Android权威编程指南》</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Andorid编程权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title>Volley学习</title>
    <url>/2021/08/29/Android%E5%AD%A6%E4%B9%A0/Volley%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Volley学习"><a href="#Volley学习" class="headerlink" title="Volley学习"></a>Volley学习</h1><p><code>Volley</code>是一个可让 <code>Android</code>应用更轻松、（最重要的是）更快捷地联网的 HTTP 库，是谷歌官方使用异步http网络请求库，所以为了连接网络还是需要学习一下这个玩意。总所周知Android主线程是不能访问网络的，但是Volley是可以直接在主线程上使用，因为他底层帮我们实现了开线程这些事情。</p>
<p>目前查看了一下<code>Volley</code>和相关的资料，发现其实介绍的都挺好的，这里的话就介绍一下简单的使用吧，如果想了解更多一些可以查看官方教程和郭霖的教程：</p>
<p><a href="https://developer.android.com/training/volley">https://developer.android.com/training/volley</a></p>
<p><a href="https://blog.csdn.net/guolin_blog/article/details/17482095">https://blog.csdn.net/guolin_blog/article/details/17482095</a></p>
<p>首先需要访问网络所以我们需要在<code>AndroidManifest</code>中加入权限</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="StringRequest、JsonObjectRequest、ImageRequest使用"><a href="#StringRequest、JsonObjectRequest、ImageRequest使用" class="headerlink" title="StringRequest、JsonObjectRequest、ImageRequest使用"></a>StringRequest、JsonObjectRequest、ImageRequest使用</h2><h3 id="设置界面"><a href="#设置界面" class="headerlink" title="设置界面"></a>设置界面</h3><p>创建一个简单项目在主界面的<code>xml</code>里面放一个<code>TextView</code>和一个<code>ImageView</code>,<code>TextView</code>用来接收收到的文字，<code>imageview</code>用来接收图片。</p>
<p>布局使用<code>ConstraintLayout</code>，简单布局一下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:srcCompat</span>=<span class="string">&quot;@tools:sample/avatars&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="StringRequest介绍"><a href="#StringRequest介绍" class="headerlink" title="StringRequest介绍"></a>StringRequest介绍</h3><p><code>StringRequest</code>是发送一个<code>http</code>请求后将收到的内容，全都转化为String进行显示</p>
<p><code>StringRequest</code>的构造函数如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> method,//请求方法，如get、post</span></span><br><span class="line"><span class="params">        String url,//请求的地址</span></span><br><span class="line"><span class="params">        Listener&lt;String&gt; listener,//请求成功的监听器</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> ErrorListener errorListener//请求失败的监听器</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>
<p>我们编写一个代码向百度进行请求，然后将内容显示出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> StringRequest <span class="title function_">getStringRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://www.baidu.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request a string response from the provided URL.</span></span><br><span class="line">    <span class="type">StringRequest</span> <span class="variable">stringRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRequest</span>(Request.Method.GET, url,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Response</span>.Listener&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(String response)</span> &#123;</span><br><span class="line">                    <span class="comment">// Display the first 500 characters of the response string.</span></span><br><span class="line">                    Log.d(TAG, response);</span><br><span class="line">                    <span class="comment">// 对应界面上的TextView</span></span><br><span class="line">                    mTextView.setText(<span class="string">&quot;Response is: &quot;</span> + response.substring(<span class="number">0</span>, <span class="number">500</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> <span class="title class_">Response</span>.ErrorListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onErrorResponse</span><span class="params">(VolleyError error)</span> &#123;</span><br><span class="line">            Log.e(TAG, error.getMessage(), error);</span><br><span class="line">              <span class="comment">// 对应界面上的TextView</span></span><br><span class="line">            mTextView.setText(<span class="string">&quot;That didn&#x27;t work!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> stringRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看的出<code>StringRequest</code>使用起来比较简单，设置两个监听器，分别是监听请求成功和请求失败，再对其中的内容进行具体的操作就行。</p>
<p>我们在<code>MainActivity</code>中写下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">       mTextView = findViewById(R.id.text);</span><br><span class="line">       mImageView = findViewById(R.id.imageView);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Instantiate the RequestQueue.</span></span><br><span class="line">       <span class="type">RequestQueue</span> <span class="variable">queue</span> <span class="operator">=</span> Volley.newRequestQueue(<span class="built_in">this</span>);</span><br><span class="line">       <span class="type">StringRequest</span> <span class="variable">request</span> <span class="operator">=</span> getStringRequest();</span><br><span class="line">       <span class="comment">// Add the request to the RequestQueue.</span></span><br><span class="line">       queue.add(request);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>运行之后，等待一会，结果如图所示，可以看到我们得到了百度返回的请求，并且把请求显示在了TextView之上。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210906202925419.png" alt="image-20210906202925419"></p>
<h3 id="JsonObjectRequest介绍"><a href="#JsonObjectRequest介绍" class="headerlink" title="JsonObjectRequest介绍"></a>JsonObjectRequest介绍</h3><p>网络当中使用json传输数据是很普遍的事情，Volley当中也有接收json回复的叫做<code>JsonObjectRequest</code>,使用起来和<code>StringRequest</code>一样比较简单。</p>
<p><code>JsonObjectRequest</code>的主要构造函数是，其他的构造函数都和这个类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">JsonObjectRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> method,// 请求的方法，是个可选参数有许多重载的构造函数</span></span><br><span class="line"><span class="params">        String url,//请求的网址</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> JSONObject jsonRequest,//post请求时带的json对象，如果为<span class="literal">null</span>代表没有</span></span><br><span class="line"><span class="params">        Listener&lt;JSONObject&gt; listener,//成功的监听器</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> ErrorListener errorListener//失败的监听器</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是我们在这里调用的是上面讲解的构造函数的其中一个重载的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> JsonObjectRequest <span class="title function_">getJsonObjectRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://www.weather.com.cn/data/sk/101010100.html&quot;</span>;</span><br><span class="line">        <span class="type">JsonObjectRequest</span> <span class="variable">jsonObjectRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonObjectRequest</span>(url, <span class="literal">null</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Response</span>.Listener&lt;JSONObject&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(JSONObject response)</span> &#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;TAG&quot;</span>, response.toString());</span><br><span class="line">                        mTextView.setText(<span class="string">&quot;Response is: &quot;</span> + response.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> <span class="title class_">Response</span>.ErrorListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onErrorResponse</span><span class="params">(VolleyError error)</span> &#123;</span><br><span class="line">                Log.e(<span class="string">&quot;TAG&quot;</span>, error.getMessage(), error);</span><br><span class="line">                mTextView.setText(<span class="string">&quot;That didn&#x27;t work!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> jsonObjectRequest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们采取同样的方法，生成一个<code>JsonObjectRequest</code>对象然后进行返回。</p>
<p>这里我们的请求是请求了天气数据，具体的可以参考这篇文章：<a href="https://www.cnblogs.com/Jimc/p/10250861.html">https://www.cnblogs.com/Jimc/p/10250861.html</a></p>
<p>这里的天气数据是个http请求，因为http请求被视为不安全，所以在高版本的<code>Android</code>当中我们调用<code>http</code>请求需要在<code>AndroidManifest</code>中的<code>application</code>标签下面加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android:usesCleartextTraffic=&quot;true&quot;</span><br></pre></td></tr></table></figure>
<p>然后我们在<code>MainActivity</code>代码中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    mTextView = findViewById(R.id.text);</span><br><span class="line">    mImageView = findViewById(R.id.imageView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the RequestQueue.</span></span><br><span class="line">    <span class="type">RequestQueue</span> <span class="variable">queue</span> <span class="operator">=</span> Volley.newRequestQueue(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">JsonObjectRequest</span> <span class="variable">request</span> <span class="operator">=</span> getJsonObjectRequest();</span><br><span class="line">    <span class="comment">// Add the request to the RequestQueue.</span></span><br><span class="line">    queue.add(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果，可以看到把天气数据进行了显示</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210907203713536.png" alt="image-20210907203713536"></p>
<h3 id="ImageRequest介绍"><a href="#ImageRequest介绍" class="headerlink" title="ImageRequest介绍"></a>ImageRequest介绍</h3><p><code>ImageRequest</code>是请求一张图片，他比前面两个稍微复杂一些，但是使用起来实际还是比较简便的</p>
<p><code>ImageRequest</code>的构造函数如下，它会创建一个新的<code>ImageRequest</code>，解码到最大指定的宽度和高度。如果宽度和高度都为零，图像将被解码为其自然大小。如果其中一个非零，则该尺寸将被固定，而另一个将被设置为保持图像的长宽比。如果宽度和高度都非零，图像将被解码为适合宽度x高度的矩形，同时保持其高宽比。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ImageRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">        String url,</span></span><br><span class="line"><span class="params">        Response.Listener&lt;Bitmap&gt; listener,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> maxWidth,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> maxHeight,</span></span><br><span class="line"><span class="params">        ScaleType scaleType,//ImageViews ScaleType用于计算所需的图像大小</span></span><br><span class="line"><span class="params">        Config decodeConfig,//解码位图的格式</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Response.ErrorListener errorListener)</span></span><br></pre></td></tr></table></figure>
<p>我们仿照前面的两个<code>Request</code>写下下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ImageRequest <span class="title function_">getImageRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/avatar/zhouning.jpg&quot;</span>;</span><br><span class="line">    <span class="type">ImageRequest</span> <span class="variable">imageRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageRequest</span>(</span><br><span class="line">            url,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Response</span>.Listener&lt;Bitmap&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Bitmap response)</span> &#123;</span><br><span class="line">                    mImageView.setImageBitmap(response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>, <span class="number">0</span>, ImageView.ScaleType.CENTER_INSIDE, Bitmap.Config.RGB_565,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Response</span>.ErrorListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onErrorResponse</span><span class="params">(VolleyError error)</span> &#123;</span><br><span class="line">                    mTextView.setText(<span class="string">&quot;That didn&#x27;t work!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">return</span> imageRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>MainActivity</code>中进行调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    mTextView = findViewById(R.id.text);</span><br><span class="line">    mImageView = findViewById(R.id.imageView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the RequestQueue.</span></span><br><span class="line">    <span class="type">RequestQueue</span> <span class="variable">queue</span> <span class="operator">=</span> Volley.newRequestQueue(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">ImageRequest</span> <span class="variable">request</span> <span class="operator">=</span> getImageRequest();</span><br><span class="line">    <span class="comment">// Add the request to the RequestQueue.</span></span><br><span class="line">    queue.add(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以得到，下面图片的显示，其中的图片是我自己博客的头像，显示在上面</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210908200246145.png" alt="image-20210908200246145"></p>
<h2 id="自定义Request"><a href="#自定义Request" class="headerlink" title="自定义Request"></a>自定义Request</h2><p>学习了上面三个简单的<code>Request</code>使用之后，我们发现其实他们的构造方法都有些类似，并且他们的实现部分其实也是类似的都是继承自<code>Request</code>类</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210908202151443.png" alt="image-20210908202151443"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210908202210668.png" alt="image-20210908202210668"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210908202225771.png" alt="image-20210908202225771"></p>
<p>所以基于这三种类的学习其实我们也可以实现自定义类别。根据官网的教程，如果我们需要实现自定义请求，我们需要实现下面两点操作：</p>
<ul>
<li>扩展 <code>Request&lt;T&gt;</code> 类，其中 <code>&lt;T&gt;</code> 表示请求期望的已解析响应的类型。因此，例如，如果已解析的响应是字符串，请通过扩展 <code>Request&lt;String&gt;</code> 创建自定义请求。</li>
<li>实现抽象方法 <code>parseNetworkResponse()</code> 和 <code>deliverResponse()</code>，详细说明如下所示。</li>
</ul>
<h3 id="parseNetworkResponse"><a href="#parseNetworkResponse" class="headerlink" title="parseNetworkResponse()"></a><code>parseNetworkResponse()</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Response&lt;T&gt; <span class="title function_">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span>;</span><br></pre></td></tr></table></figure>
<p><code>parseNetworkResponse</code>对服务器响应的数据进行解析，然后返回一个对应类型的<code>Response</code>对象，<code>parseNetworkResponse</code>将<code>NetworkResponse</code>作为参数，在该参数当中包含了响应负载作为字节 []、HTTP 状态代码以及响应标头。除此之外我们实现返回的Response\<T>，其中包含您输入的响应对象和缓存元数据或错误，例如解析失败时出现的错误。</p>
<p>我们可以学习一下<code>StringRequest</code>中的例子，对应着上面的讲解可以很清楚的看懂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;DefaultCharset&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title function_">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> &#123;</span><br><span class="line">    String parsed;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsed = <span class="keyword">new</span> <span class="title class_">String</span>(response.data, HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// Since minSdkVersion = 8, we can&#x27;t call</span></span><br><span class="line">        <span class="comment">// new String(response.data, Charset.defaultCharset())</span></span><br><span class="line">        <span class="comment">// So suppress the warning instead.</span></span><br><span class="line">        parsed = <span class="keyword">new</span> <span class="title class_">String</span>(response.data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="deliverResponse"><a href="#deliverResponse" class="headerlink" title="deliverResponse()"></a><code>deliverResponse()</code></h3><p>Volley在<code>deliverResponse</code>中返回的对象在主线程上进行回调。简单理解就是在这个方法当中处理解析出来返回的对象，一般来说在这里面，直接调用回调接口，也就是调用监听器就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">deliverResponse</span><span class="params">(T response)</span>;</span><br></pre></td></tr></table></figure>
<p>例如<code>StringRequest</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">deliverResponse</span><span class="params">(String response)</span> &#123;</span><br><span class="line">    Response.Listener&lt;String&gt; listener;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        listener = mListener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">        listener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义XMLRequest"><a href="#自定义XMLRequest" class="headerlink" title="自定义XMLRequest"></a>自定义XMLRequest</h3><p>这部分内容借鉴博客：<a href="https://blog.csdn.net/guolin_blog/article/details/17612763">https://blog.csdn.net/guolin_blog/article/details/17612763</a></p>
<p><code>xml</code>也是网上传输比较多的格式之一，所以先定义一个<code>XMLRequest</code>练练手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.volleylearn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.android.volley.*;</span><br><span class="line"><span class="keyword">import</span> com.android.volley.toolbox.HttpHeaderParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParser;</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParserException;</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParserFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLRequest</span> <span class="keyword">extends</span> <span class="title class_">Request</span>&lt;XmlPullParser&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Response.Listener&lt;XmlPullParser&gt; mListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XMLRequest</span><span class="params">(<span class="type">int</span> method, String url, Response.Listener&lt;XmlPullParser&gt; listener,</span></span><br><span class="line"><span class="params">                      Response.ErrorListener errorListener)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(method, url, errorListener);</span><br><span class="line">        mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XMLRequest</span><span class="params">(String url, Response.Listener&lt;XmlPullParser&gt; listener, Response.ErrorListener errorListener)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Method.GET, url, listener, errorListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Response&lt;XmlPullParser&gt; <span class="title function_">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">xmlString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(response.data,</span><br><span class="line">                    HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">            <span class="type">XmlPullParserFactory</span> <span class="variable">factory</span> <span class="operator">=</span> XmlPullParserFactory.newInstance();</span><br><span class="line">            <span class="type">XmlPullParser</span> <span class="variable">xmlPullParser</span> <span class="operator">=</span> factory.newPullParser();</span><br><span class="line">            xmlPullParser.setInput(<span class="keyword">new</span> <span class="title class_">StringReader</span>(xmlString));</span><br><span class="line">            <span class="keyword">return</span> Response.success(xmlPullParser, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.error(<span class="keyword">new</span> <span class="title class_">ParseError</span>(e));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.error(<span class="keyword">new</span> <span class="title class_">ParseError</span>(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">deliverResponse</span><span class="params">(XmlPullParser response)</span> &#123;</span><br><span class="line">        mListener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到代码比较简单，实现了<code>parseNetworkResponse</code>和<code>deliverResponse</code>方法，然后最终返回的是一个<code>XmlPullParser</code>对象</p>
<p>然后我们可以仿照前面的例子，写下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> XMLRequest <span class="title function_">getXmlRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://flash.weather.com.cn/wmaps/xml/china.xml&quot;</span>;</span><br><span class="line">    <span class="type">XMLRequest</span> <span class="variable">xmlRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLRequest</span>(url, <span class="keyword">new</span> <span class="title class_">Response</span>.Listener&lt;XmlPullParser&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(XmlPullParser response)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">eventType</span> <span class="operator">=</span> response.getEventType();</span><br><span class="line">                <span class="keyword">while</span> (eventType != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">                        <span class="keyword">case</span> XmlPullParser.START_TAG:</span><br><span class="line">                            <span class="type">String</span> <span class="variable">nodeName</span> <span class="operator">=</span> response.getName();</span><br><span class="line">                            <span class="keyword">if</span> (<span class="string">&quot;city&quot;</span>.equals(nodeName)) &#123;</span><br><span class="line">                                <span class="type">String</span> <span class="variable">pName</span> <span class="operator">=</span> response.getAttributeValue(<span class="number">0</span>);</span><br><span class="line">                                Log.d(TAG, <span class="string">&quot;pName is &quot;</span> + pName);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    eventType = response.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">new</span> <span class="title class_">Response</span>.ErrorListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onErrorResponse</span><span class="params">(VolleyError error)</span> &#123;</span><br><span class="line">            Log.e(TAG, error.getMessage(), error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> xmlRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 “<a href="http://flash.weather.com.cn/wmaps/xml/china.xml&quot;是一些天气数据，可以自己访问之后查看一下">http://flash.weather.com.cn/wmaps/xml/china.xml&quot;是一些天气数据，可以自己访问之后查看一下</a></p>
<p>接着我们可以进行调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    mTextView = findViewById(R.id.text);</span><br><span class="line">    mImageView = findViewById(R.id.imageView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the RequestQueue.</span></span><br><span class="line">    <span class="type">RequestQueue</span> <span class="variable">queue</span> <span class="operator">=</span> Volley.newRequestQueue(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">XMLRequest</span> <span class="variable">request</span> <span class="operator">=</span> getXmlRequest();</span><br><span class="line">    <span class="comment">// Add the request to the RequestQueue.</span></span><br><span class="line">    queue.add(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到结果，其中乱码部分其实是省份（中文），但是不知道什么原因乱码了，自己也采取了一些方法但是都没有用，日后解决了再写个文章。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210909203722103.png" alt="image-20210909203722103"></p>
<h3 id="自定义GsonRequest"><a href="#自定义GsonRequest" class="headerlink" title="自定义GsonRequest"></a>自定义GsonRequest</h3><p>Gson是Android当中常用的一个用来解析json的库，Volley中默认并不支持使用自家的GSON来解析数据，所以我们自定义一个GsonRequest</p>
<p>我们访问的网址是<a href="http://www.weather.com.cn/data/sk/101010100.html这个接口，他可以得到一段JSON格式的天气数据，如下所示：">http://www.weather.com.cn/data/sk/101010100.html这个接口，他可以得到一段JSON格式的天气数据，如下所示：</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;weatherinfo&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;北京&quot;</span><span class="punctuation">,</span><span class="attr">&quot;cityid&quot;</span><span class="punctuation">:</span><span class="string">&quot;101010100&quot;</span><span class="punctuation">,</span><span class="attr">&quot;temp&quot;</span><span class="punctuation">:</span><span class="string">&quot;19&quot;</span><span class="punctuation">,</span><span class="attr">&quot;WD&quot;</span><span class="punctuation">:</span><span class="string">&quot;南风&quot;</span><span class="punctuation">,</span><span class="attr">&quot;WS&quot;</span><span class="punctuation">:</span><span class="string">&quot;2级&quot;</span><span class="punctuation">,</span><span class="attr">&quot;SD&quot;</span><span class="punctuation">:</span><span class="string">&quot;43%&quot;</span><span class="punctuation">,</span><span class="attr">&quot;WSE&quot;</span><span class="punctuation">:</span><span class="string">&quot;2&quot;</span><span class="punctuation">,</span><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span><span class="string">&quot;19:45&quot;</span><span class="punctuation">,</span><span class="attr">&quot;isRadar&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;Radar&quot;</span><span class="punctuation">:</span><span class="string">&quot;JC_RADAR_AZ9010_JB&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>接下来我们使用对象的方式将这段JSON字符串表示出来。新建一个Weather类，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Weather</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> WeatherInfo weatherinfo;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> WeatherInfo <span class="title function_">getWeatherinfo</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> weatherinfo;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeatherinfo</span><span class="params">(WeatherInfo weatherinfo)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.weatherinfo = weatherinfo;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Weather类中只是引用了WeatherInfo这个类。接着新建WeatherInfo类，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCity</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTemp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTemp</span><span class="params">(String temp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temp = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTime</span><span class="params">(String time)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WeatherInfo类中含有city、temp、time这几个字段。</p>
<p>接着我们依照惯例写下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> GsonRequest&lt;Weather&gt; <span class="title function_">getGsonRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://www.weather.com.cn/data/sk/101010100.html&quot;</span>;</span><br><span class="line">    GsonRequest&lt;Weather&gt; gsonRequest = <span class="keyword">new</span> <span class="title class_">GsonRequest</span>&lt;Weather&gt;(</span><br><span class="line">            url, Weather.class,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Response</span>.Listener&lt;Weather&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Weather weather)</span> &#123;</span><br><span class="line">                    <span class="type">WeatherInfo</span> <span class="variable">weatherInfo</span> <span class="operator">=</span> weather.getWeatherinfo();</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;city is &quot;</span> + weatherInfo.getCity());</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;temp is &quot;</span> + weatherInfo.getTemp());</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;time is &quot;</span> + weatherInfo.getTime());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> <span class="title class_">Response</span>.ErrorListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onErrorResponse</span><span class="params">(VolleyError error)</span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>, error.getMessage(), error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> gsonRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    mTextView = findViewById(R.id.text);</span><br><span class="line">    mImageView = findViewById(R.id.imageView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the RequestQueue.</span></span><br><span class="line">    <span class="type">RequestQueue</span> <span class="variable">queue</span> <span class="operator">=</span> Volley.newRequestQueue(<span class="built_in">this</span>);</span><br><span class="line">    GsonRequest&lt;Weather&gt; request = getGsonRequest();</span><br><span class="line">    <span class="comment">// Add the request to the RequestQueue.</span></span><br><span class="line">    queue.add(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/android/image-20210911204452119.png" alt="image-20210911204452119"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>编写Volley，使用了很久时间，这期间经历了回学校等众多事情，最终算是写完了，也学习到Volley使用的很多知识，加油！生活会更好的。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Andorid编程权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器规范</title>
    <url>/2022/08/18/Linux/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="Linux服务器规范"><a href="#Linux服务器规范" class="headerlink" title="Linux服务器规范"></a>Linux服务器规范</h1><p>学习《Linux高性能服务器编程》第七章Linux服务器规范，为了印象深刻一些，多动手多实践，所以记下这个笔记。这一篇主要记录Linux中日志、用户信息、进程关系、改变工作目录和根目录。</p>
<span id="more"></span>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="Linux系统日志"><a href="#Linux系统日志" class="headerlink" title="Linux系统日志"></a>Linux系统日志</h3><p>Linux上使用<code>rsyslogd</code>守护进程接收<strong>用户进程</strong>输出的日志和接收<strong>内核</strong>日志。</p>
<p>用户进程是通过<code>syslogd</code>函数生成系统日志。该函数将日志输出到一个UNIX本地域socket类型(AF_UNIX）的文件<code>/dev/log</code>中，<code>rsyslogd</code>则监听该文件以获取用户进程的输出。</p>
<p>内核日志是如何进行管理的，在这里我们不进行关系。</p>
<p><code>rsyslogd</code>守护进程在接收到<strong>用户进程</strong>或<strong>内核输入</strong>的日志后，会把它们输出至某些特定的日志文件。默认情况下，调试信息会保存至<code>/var/log/debug</code>文件，普通信息保存至<code>/var/log/messages</code>文件，内核消息则保存至<code>/var/log/kern.log</code>文件。</p>
<p>不过，日志信息具体如何分发，可以在<code>rsyslogd</code>的配置文件中设置。<code>rsyslogd</code>的主配置文件是<code>/etc/rsyslog.conf</code>，其中主要可以设置的项包括:内核日志输入路径，是否接收UDP日志及其监听端口（默认是514，见<code>/etc/services</code>文件)，是否接收TCP日志及其监听端口，日志文件的权限，包含哪些子配置文件(比如 <code>/etc/rsyslog.d/*.conf</code>)。<code>rsyslogd</code>的子配置文件则指定各类日志的目标存储文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220818105707879.png" alt="image-20220818105707879"></p>
<p><code>rsyslogd</code>系统日志功能比较复杂，有facility、priority、action等概念。还有Input模块、Filetr模块、Output模块等模块内容，目前还未弄清楚相关的知识。</p>
<p>查看了一下<code>/etc/rsyslog.conf</code>的配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/rsyslog.conf configuration file <span class="keyword">for</span> rsyslog</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># For more information install rsyslog-doc and see</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/usr/share/doc/rsyslog-doc/html/configuration/index.html</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Default logging rules can be found in /etc/rsyslog.d/50-default.conf</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### MODULES ####</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################</span></span></span><br><span class="line"></span><br><span class="line">module(load=&quot;imuxsock&quot;) # provides support for local system logging</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">module(load=<span class="string">&quot;immark&quot;</span>)  <span class="comment"># provides --MARK-- message capability</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides UDP syslog reception</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">module(load=<span class="string">&quot;imudp&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">input(<span class="built_in">type</span>=<span class="string">&quot;imudp&quot;</span> port=<span class="string">&quot;514&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides TCP syslog reception</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">module(load=<span class="string">&quot;imtcp&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">input(<span class="built_in">type</span>=<span class="string">&quot;imtcp&quot;</span> port=<span class="string">&quot;514&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides kernel logging support and <span class="built_in">enable</span> non-kernel klog messages</span></span><br><span class="line">module(load=&quot;imklog&quot; permitnonkernelfacility=&quot;on&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### GLOBAL DIRECTIVES ####</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Use traditional timestamp format.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">To <span class="built_in">enable</span> high precision timestamps, comment out the following line.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$ActionFileDefaultTemplate</span> RSYSLOG_TraditionalFileFormat</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Filter duplicated messages</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">RepeatedMsgReduction on</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Set the default permissions for all log files.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$FileOwner</span> syslog</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FileGroup adm</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FileCreateMode 0640</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DirCreateMode 0755</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Umask 0022</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PrivDropToUser syslog</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PrivDropToGroup syslog</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Where to place spool and state files</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$WorkDirectory</span> /var/spool/rsyslog</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Include all config files in /etc/rsyslog.d/</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到模块<code>module(load=&quot;imuxsock&quot;)</code>，这是一个输入模块</p>
<p>然后看到默认规则在<code>/etc/rsyslog.d/50-default.conf</code>，查看一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> Default rules <span class="keyword">for</span> rsyslog.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#                       For more information see rsyslog.conf(5) and /etc/rsyslog.conf</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># First some standard log files.  Log by facility.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">auth,authpriv.*                 /var/log/auth.log</span></span><br><span class="line">*.*;auth,authpriv.none          -/var/log/syslog</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cron.*                         /var/log/cron.log</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">daemon.*                       -/var/log/daemon.log</span></span><br><span class="line">kern.*                          -/var/log/kern.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lpr.*                          -/var/log/lpr.log</span></span><br><span class="line">mail.*                          -/var/log/mail.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">user.*                         -/var/log/user.log</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Logging for the mail system.  Split it up so that</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">it is easy to write scripts to parse these files.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#mail.info                      -/var/log/mail.info</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mail.warn                      -/var/log/mail.warn</span></span><br><span class="line">mail.err                        /var/log/mail.err</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Some &quot;catch-all&quot; log files.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">*.=debug;\</span></span><br><span class="line"><span class="language-bash"><span class="comment">#       auth,authpriv.none;\</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       news.none;mail.none     -/var/log/debug</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">*.=info;*.=notice;*.=warn;\</span></span><br><span class="line"><span class="language-bash"><span class="comment">#       auth,authpriv.none;\</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       cron,daemon.none;\</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       mail,news.none          -/var/log/messages</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Emergencies are sent to everybody logged in.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">*.emerg                         :omusrmsg:*</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># I like to have messages displayed on the console, but only on a virtual</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">console I usually leave idle.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#daemon,mail.*;\</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       news.=crit;news.=err;news.=notice;\</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       *.=debug;*.=info;\</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       *.=notice;*.=warn       /dev/tty8</span></span></span><br></pre></td></tr></table></figure>
<p>其中<code>auth</code>这种就是facility（设施），<code>mail.err</code>这种就是priority（等级），而这种设置日志记录的位置就是action</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.*;auth,authpriv.none          -/var/log/syslog</span><br></pre></td></tr></table></figure>
<p>从上面这一个action可以看出普通的日志（<code>&quot;.&quot;</code>），设置日志记录位置是<code>/var/log/syslog</code>，前面<code>-</code>表示异步写入</p>
<p>我们使用<code>logger</code>命令测试一下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">logger -i -t <span class="string">&quot;my_test&quot;</span> <span class="string">&quot;test_log&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用vim查看<code>/var/log/syslog</code>可以看到我们的<code>logger</code>的结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220818172612033.png" alt="image-20220818172612033"></p>
<p><code>rsyslogd</code>的内容比较多，后续再补。</p>
<h3 id="syslog函数"><a href="#syslog函数" class="headerlink" title="syslog函数"></a>syslog函数</h3><p>应用程序使用<code>syslog</code>函数和<code>rsyslogd</code>守护进程进行通讯。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> option, <span class="type">int</span> facility)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><code>openlog</code>用于改变<code>syslog</code>默认的输出方式，进行日志结构化</p>
<p><code>ident</code>参数指定的字符串将被添加到日志消息的日期和时间之后，它通常被设置为程序的名字。</p>
<p><code>option</code>参数对后续<code>syslog</code>调用的行为进行配置，它可取下列的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_PID		0x01	<span class="comment">/* log the pid with each message */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_CONS	0x02	<span class="comment">/* log on the console if errors in sending */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_ODELAY	0x04	<span class="comment">/* delay open until first syslog() (default) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_NDELAY	0x08	<span class="comment">/* don&#x27;t delay open */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_NOWAIT	0x10	<span class="comment">/* don&#x27;t wait for console forks: DEPRECATED */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_PERROR	0x20	<span class="comment">/* log to stderr as well */</span></span></span><br></pre></td></tr></table></figure>
<p><code>facility</code>参数可以修改<code>syslog</code>函数中的默认设施值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* facility codes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_KERN	(0&lt;&lt;3)	<span class="comment">/* kernel messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_USER	(1&lt;&lt;3)	<span class="comment">/* random user-level messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_MAIL	(2&lt;&lt;3)	<span class="comment">/* mail system */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_DAEMON	(3&lt;&lt;3)	<span class="comment">/* system daemons */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_AUTH	(4&lt;&lt;3)	<span class="comment">/* security/authorization messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_SYSLOG	(5&lt;&lt;3)	<span class="comment">/* messages generated internally by syslogd */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LPR		(6&lt;&lt;3)	<span class="comment">/* line printer subsystem */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_NEWS	(7&lt;&lt;3)	<span class="comment">/* network news subsystem */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_UUCP	(8&lt;&lt;3)	<span class="comment">/* UUCP subsystem */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_CRON	(9&lt;&lt;3)	<span class="comment">/* clock daemon */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_AUTHPRIV	(10&lt;&lt;3)	<span class="comment">/* security/authorization messages (private) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_FTP		(11&lt;&lt;3)	<span class="comment">/* ftp daemon */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* other codes through 15 reserved for system use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL0	(16&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL1	(17&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL2	(18&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL3	(19&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL4	(20&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL5	(21&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL6	(22&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_LOCAL7	(23&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br></pre></td></tr></table></figure>
<p><code>syslog</code>用于输出日志。</p>
<p><code>priority</code>参数是<strong>设施值和日志级别</strong>的按位与，默认是<code>LOG_USER</code>。日志级别有下面几个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_EMERG	0	<span class="comment">/* system is unusable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_ALERT	1	<span class="comment">/* action must be taken immediately */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_CRIT	2	<span class="comment">/* critical conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_ERR		3	<span class="comment">/* error conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_WARNING	4	<span class="comment">/* warning conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_NOTICE	5	<span class="comment">/* normal but significant condition */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_INFO	6	<span class="comment">/* informational */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LOG_DEBUG	7	<span class="comment">/* debug-level messages */</span></span></span><br></pre></td></tr></table></figure>
<p>第二个参数<code>message</code>和第三个参数<code>...</code>来结构化输出。</p>
<p><code>closelog</code>用于关闭日志</p>
<p>小例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    openlog(argv[<span class="number">0</span>], LOG_CONS | LOG_PID, LOG_USER);</span><br><span class="line">    syslog(LOG_DEBUG, <span class="string">&quot;This is a syslog test message generated by program &#x27;%s&#x27;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    closelog();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220818183131617.png" alt="image-20220818183131617"></p>
<h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><h3 id="UID、EUID、GID和EGID"><a href="#UID、EUID、GID和EGID" class="headerlink" title="UID、EUID、GID和EGID"></a>UID、EUID、GID和EGID</h3><p>Linux中id真是太多了进程有pid，然后用户还有UID这种，真是有点绕。</p>
<p>在Linux当中一个进程（程序）拥有四个ID:真实用户<code>UID</code>、有效用户<code>EUID</code>、真实组<code>GID</code>和有效组<code>EGID</code>。</p>
<p>这里以真实用户<code>UID</code>和有效用户<code>EUID</code>为例，真实组<code>GID</code>和有效组<code>EGID</code>道理是相同的。</p>
<p><code>EUID</code>存在的目的是<strong>方便资源访问</strong>:它使得运行程序的用户拥有该程序的有效用户的权限（太过官方这种说法感觉）。<code>EUID</code>确定进程对某些资源和文件的访问权限。在大多数情况下，进程的<code>UID</code>和<code>EUID</code>是一样的，但是对于一些程序如<code>su</code>、<code>passwd</code>这种<code>set-user-id</code>程序，它们有可能是不相同的。对于<code>set-user-id</code>程序而言，程序的<code>EUID</code>会变成<strong>程序的所有者</strong>的<code>UID</code>，也就是说程序执行时，是以<strong>程序的所有者身份</strong>进行运行的。</p>
<p>以<code>passwd</code>为例。<code>passwd</code>允许用户修改自己的登录密码，这个<strong>程序的所有者</strong>是<code>root</code>，<code>passwd</code>权限中有<code>s</code>，表明这是一个<code>set-user-id</code>程序。<code>passwd</code>命令需要修改<code>/etc/shadow</code>文件，对于<code>/etc/shadow</code>文件，普通用户是不可写（只有读权限）的，那么用户怎么能够通过<code>passwd</code>修改自己的密码呢，<code>set-user-id</code>程序的标志<code>s</code>就起到了作用，它在程序运行时将<code>EUID</code>会变成<strong>程序的所有者</strong>的<code>UID</code>，那么程序有效的用户就会变成<strong>程序的所有者</strong>，在这里是<code>root</code>用户，理所当然的可以进行<code>/etc/shadow</code>文件的修改。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819104851240.png" alt="image-20220819104851240"></p>
<p>再比如<code>su</code>程序允许任何用户都可以使用它来修改自己的账户信息，但修改账户时程序不得不访问文件<code>/etc/passwd</code>文件，而访问该文件是需要<code>root</code>权限的。那么以<strong>普通用户身份</strong>启动的<code>su</code>程序如何能访问<code>/etc/passwd</code>文件呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819130924743.png" alt="image-20220819130924743"></p>
<p><code>su</code>程序的所有者是<code>root</code>，并且它被设置了<code>set-user-id</code>标志。和上面<code>passwd</code>一样，<code>set-user-id</code>标志表示任何普通用户运行<code>su</code>程序时，其有效用户就是该程序的<strong>所有者</strong><code>root</code>。</p>
<p>获取和设置真实用户<code>UID</code>、有效用户<code>EUID</code>、真实组<code>GID</code>和有效组<code>EGID</code>的函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">geteuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getegid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">seteuid</span><span class="params">(<span class="type">uid_t</span> euid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setegid</span><span class="params">(<span class="type">gid_t</span> egid)</span>;</span><br></pre></td></tr></table></figure>
<p>为了测试上面所说，我们先创建一个普通用户<code>bugcat</code>，目前已经有普通用户<code>ubuntu</code>。</p>
<p>可以看到<code>bugcat</code>的uid是<code>1002</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819140826977.png" alt="image-20220819140826977"></p>
<p>我们写下读取程序<code>uid</code>和<code>euid</code>的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uid_t</span> uid = getuid();</span><br><span class="line">    <span class="type">uid_t</span> euid = geteuid();</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;userid is %d, effective userid is: %d\n&quot;</span>, uid, euid );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将其编译一下，然后查看查看文件属性，再运行程序，可以看到<code>uid</code>和<code>euid</code>输出相同，表示<strong>真实用户</strong>和<strong>有效用户</strong>都是<code>ubuntu</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819141010532.png" alt="image-20220819141010532"></p>
<p>接着再将程序的所有者改为<code>root</code>，再加上<code>s</code>权限，再运行程序，可以看到<code>uid</code>和<code>euid</code>输出不相同，表示<strong>真实用户</strong>是<code>ubuntu</code>，<strong>有效用户</strong>是<code>root</code>（符合<code>set-user-id</code>程序特点）</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819141209028.png" alt="image-20220819141209028"></p>
<p>然后将程序的所有者改为<code>bugcat</code>（s权限不知道为啥自动取消了），再加上<code>s</code>权限，再运行程序，可以看到<code>uid</code>和<code>euid</code>输出不相同，表示<strong>真实用户</strong>是<code>ubuntu</code>，<strong>有效用户</strong>是<code>bugcat</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819141405860.png" alt="image-20220819141405860"></p>
<p>最后我们去掉<code>s</code>权限，运行程序，可以看到<code>uid</code>和<code>euid</code>输出相同，表示<strong>真实用户</strong>和<strong>有效用户</strong>都是<code>ubuntu</code>，也从反面说明<code>s</code>权限的作用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220819142209993.png" alt="image-20220819142209993"></p>
<h2 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>Linux下每个进程都隶属于一个进程组，因此它们除了PID信息外，还有进程组ID(<code>PGID</code>)。我们可以用如下函数来获取指定进程<code>PGID</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数成功时返回进程pid所属进程组的<code>PGID</code>，失败则返回-1并设置<code>errno</code>。</p>
<p>每个进程组都有一个首领进程，其<code>PGID</code>和<code>PID</code>相同。进程组将一直存在，直到其中所有进程都退出，或者加入到其他进程组。下面的函数用于设置<code>PGID</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数将<code>PID</code>为<code>pid</code>的进程的<code>PGID</code>设置为<code>pgid</code>。</p>
<p>如果<code>pid</code>和 <code>pgid</code>相同，则由<code>pid</code>指定的进程将被设置为进程组首领；</p>
<p>如果<code>pid</code>为0，则表示设置当前进程的<code>PGID</code>为<code>pgid</code>；</p>
<p>如果<code>pgid</code>为0，则使用<code>pid</code>作为目标<code>PGID</code>。</p>
<p><code>setpgid</code>函数成功时返回0，失败则返回-1并设置<code>errno</code>.</p>
<p>一个进程只能设置<strong>自己</strong>或者<strong>其子进程</strong>的<code>PGID</code>。并且，当子进程调用<code>exec</code>系列函数后，我们也不能再在父进程中对它设置<code>PGID</code>。</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>一些有关联的进程组将形成一个会话(session)。下面的函数用于创建一个会话:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>该进程不能由<strong>进程组的首领</strong>进程进行调用，会报错。</p>
<p>对于非进程组首领的进程，调用该函数不仅创建新会话，还会：</p>
<ul>
<li>调用进程成为会话的首领，此时该进程是新会话的唯一成员。</li>
<li>新建一个进程组，其<code>PGID</code>就是调用进程的<code>PID</code>，调用进程成为该组的首领。</li>
<li>调用进程将失去终端</li>
</ul>
<p>该函数成功时返回新的进程组的<code>PGID</code>，失败则返回-1并设置<code>errno</code>。</p>
<p>Linux进程并未提供所谓<strong>会话ID (SID）</strong>的概念，但Linux系统认为它等于<strong>会话首领</strong>所在的<strong>进程组的PGID</strong>，并提供了如下函数来读取<code>SID</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用ps命令查看进程之间的关系"><a href="#使用ps命令查看进程之间的关系" class="headerlink" title="使用ps命令查看进程之间的关系"></a>使用ps命令查看进程之间的关系</h3><p>在终端输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -o pid,ppid,pgid,sid,comm | less</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220821164503929.png" alt="image-20220821164503929"></p>
<p>它们之间的关系如下图</p>
<p>从单独的进程角度看，zsh是ps和less的父进程</p>
<p>从组的角度看，zsh是一个组（组里面只有zsh，所以zsh是进程组首领），ps和less是一个组（ps是进程组首领）</p>
<p>从会话的角度看，会话里面有两个关联的进程组，其实zsh是会话的首领</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220821165830395.png" alt="image-20220821165830395"></p>
<h2 id="改变工作目录和根目录"><a href="#改变工作目录和根目录" class="headerlink" title="改变工作目录和根目录"></a>改变工作目录和根目录</h2><p>进程有工作目录和根目录。</p>
<p>工作目录：进程在哪个路径下被运行起来哪个路径就是进程的工作目录(Current Woring Directory, CWD)</p>
<p>根目录：就是”/“</p>
<p>工作目录和根目录可以通过<code>/proc/PID/cwd</code>和<code>/proc/PID/root</code>进行查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220821175748810.png" alt="image-20220821175748810"></p>
<p>工作目录和根目录都可以进行更改，获取进程当前工作目录和改变进程工作目录的函数分别是:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>
<p><code>buf</code>参数指向的内存用于存储进程当前工作目录的绝对路径名，其大小由<code>size</code>参数指定。</p>
<p>如果当前工作目录的绝对路径的长度（再加上一个空结束字符“\0”)超过了<code>size</code>，则<code>getcwd</code>将返回<code>NULL</code>，并设置<code>errno</code>为<code>ERANGE</code>。</p>
<p>如果<code>buf</code>为<code>NULL</code>并且<code>size</code>非0，则<code>getcwd</code>可能在内部使用<code>malloc</code>动态分配内存，并将进程的当前工作目录存储在其中。如果是这种情况，则我们必须自己来释放<code>getcwd</code>在内部创建的这块内存。</p>
<p><code>getcwd</code>函数成功时返回一个指向目标存储区（<code>buf</code>指向的缓存区或是<code>getcwd</code>在内部动态创建的缓存区）的指针，失败则返回<code>NULL</code>并设置<code>errno</code>。</p>
<p><code>chdir</code>函数的<code>path</code>参数指定要切换到的目标目录。它成功时返回0，失败时返回-1并设置<code>errno</code>。</p>
<p>改变进程根目录可以使用<code>chroot</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chroot</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>
<p><code>path</code>参数指定要切换到的目标根目录。它成功时返回0，失败时返回-1并设置<code>errno</code>。</p>
<p><code>chroot</code><strong>并不改变</strong>进程的当前工作目录。</p>
<p>改变进程的根目录之后，程序可能无法访问类似<code>/dev</code>的文件（和目录)，因为这些文件（和目录〉并非处于新的根目录之下。不过好在调用<code>chroot</code>之后，进程原先打开的文件描述符依然生效，所以我们可以利用这些早先打开的文件描述符来访问调用<code>chroot</code>之后不能直接访问的文件（和目录)，尤其是一些日志文件。此外，只有<strong>特权进</strong>程才能改变根目录。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程</title>
    <url>/2022/09/18/Linux/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><p>学习《Linux高性能服务器编程》第十四章多线程编程，里面介绍了各种Linux编程中多线程编程的内容，为了印象深刻一些，多动手多实践，所以记下这个笔记。</p>
<p>这一章分为创建线程和结束线程、线程属性、Posix信号量、互斥锁、条件变量。</p>
<span id="more"></span>
<h2 id="创建线程和结束线程"><a href="#创建线程和结束线程" class="headerlink" title="创建线程和结束线程"></a>创建线程和结束线程</h2><h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><p>创建一个线程使用<code>pthread_create</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>
<p><code>thread</code>参数是新线程的标识符，后续<code>pthread_*</code>函数通过它来引入新线程。</p>
<p>其类型<code>pthread_r</code>定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Thread identifiers.  The structure of the attribute type is not</span></span><br><span class="line"><span class="comment">   exposed on purpose.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_t</code>是一个整型类型。实际上，Linux 上几乎所有的资源标识符都是一个整型数，比如<code>socket</code>、各种<code>System V IPC</code>标识符等。</p>
<p><code>attr</code>参数用于设置新线程的属性。给它<code>NULL</code>表示使用默认线程属性。线程拥有众多属性。</p>
<p><code>start_routine</code>和<code>arg</code>参数分别指定新线程将运行的函数以及其参数。</p>
<p><code>pthread_create</code>成功时返回0，失败时返回错误码。一个用户可以打开的线程数量不能超过<code>RLIMIT_NPROC</code>软资源限制。此外，系统上所有用户能创建的线程总数也不得超过<code>/proc/sys/kernel/threads-max</code>内核参数所定义的值。</p>
<p>eg:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = *(<span class="type">int</span> *)arg; <span class="comment">//强转.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--I&#x27;m the thread: pid = %d, tid= %lu, arg is %d\n&quot;</span>, getpid(), pthread_self(), p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p = <span class="number">12</span>;</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, (<span class="type">void</span> *)&amp;p); <span class="comment">// i 传参采用 值传递. 借助强转.</span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: I&#x27;m Main, pid = %d, tid= %lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220922125439092.png" alt="image-20220922125439092"></p>
<h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h3><p>线程一旦被创建好，内核就可以调度内核线程来执行<code>start_routine</code>函数指针所指向的函数了。线程函数在结束时最好调用如下函数，以确保安全、干净地退出:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_exit</code>函数通过<code>retval</code>参数向线程的回收者传递其退出信息。它执行完之后不会返回到调用者，而且永远不会失败。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); <span class="comment">// 将当前线程退出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = *(<span class="type">int</span> *)arg; <span class="comment">//强转.</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// exit(0);            // 表示退出进程.</span></span><br><span class="line">        <span class="comment">// return NULL;          // 表示返回到调用者那里去.</span></span><br><span class="line">        <span class="comment">// func();</span></span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>); <span class="comment">// 将当前线程退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--I&#x27;m the thread: pid = %d, tid= %lu, arg is %d\n&quot;</span>, getpid(), pthread_self(), p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p = <span class="number">2</span>;</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, (<span class="type">void</span> *)&amp;p); <span class="comment">// i 传参采用 值传递. 借助强转.</span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: I&#x27;m Main, pid = %d, tid= %lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220922130320204.png" alt="image-20220922130320204"></p>
<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><p>一个进程中的所有线程都可以调用<code>pthread_join</code>函数来回收其他线程（前提是目标线程是可回收的)，即等待其他线程结束，这类似于回收进程的<code>wait</code>和 <code>waitpid</code>系统调用。<code>pthrcad_join</code>的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>
<p><code>thread</code>参数是目标线程的标识符，<code>retval</code>参数则是目标线程返回的退出信息。该函数会一直阻塞，直到被回收的线程结束为止。该函数成功时返回0，失败则返回错误码。可能的错误码如下表所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220920105152473.png" alt="image-20220920105152473"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">74</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> *retval;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ret = pthread_join(tid, (<span class="type">void</span> **)&amp;retval);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;pthread_join error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread exit with %d\n&quot;</span>, (<span class="type">void</span> *)retval);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220922202736277.png" alt="image-20220922202736277"></p>
<h3 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h3><p>有时候我们希望能够取消线程，可以通过<code>pthread_cancel</code>函数实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>
<p><code>thread</code>参数是目标线程的标识符。该函数成功时返回0，失败则返回错误码。不过，接收到取消请求的<strong>目标线程</strong>可以决定是否允许被取消以及如何取消，这分别由如下两个函数完成:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure>
<p>这两个函数的第一个参数分别用于设置线程的取消状态（是否允许取消）和取消类型(如何取消)，第二个参数则分别记录线程原来的取消状态和取消类型。<code>state</code>参数有两个可选值:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220920110543454.png" alt="image-20220920110543454"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread: pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: pid = %d, tid = %lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    ret = pthread_cancel(tid); <span class="comment">// 终止线程</span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_cancel error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after 5s tid = %lu is cancel\n&quot;</span>, tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220922203738758.png" alt="image-20220922203738758"></p>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p><code>pthread_attr_t</code>结构体定义了一套完整的线程属性，如下所示:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">pthread_attr_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> __size[__SIZEOF_PTHREAD_ATTR_T];</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> __align;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>各种线程属性全部包含在一个字符数组中。线程库定义了一系列函数来操作<code>pthread_attr_t</code>类型的变量，以方便我们获取和设置线程属性。这些函数包括:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程属性对象 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">/* 销毁线程属性对象。被销毁的线程属性对象只有再次初始化之后才能继续使用 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstackaddr</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstackaddr</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> **stackaddr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> *stacksize)</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>线程属性：</p>
<ul>
<li><code>detachstate</code>，线程的脱离状态。它有<code>PTHREAD_CREATE_JOINABLE</code>和<code>PTHREAD_CREATE_DETACH</code>两个可选值。前者指定线程是可以被回收的，后者使调用线程脱离与进程中其他线程的同步。脱离了与其他线程同步的线程称为“脱离线程”。脱离线程在退出时将自行释放其占用的系统资源。线程创建时该属性的默认值是<code>PTHREAD_CREATE_JOINABLE</code>。此外，我们也可以使用<code>pthread_detach</code>函数直接将线程设置为脱离线程。</li>
<li><code>stackaddr</code>和<code>stacksize</code>，线程堆栈的起始地址和大小。一般来说，我们不需要自己来管理线程堆栈，因为Linux默认为每个线程分配了足够的堆栈空间（一般是8 MB)。我们可以使用ulimt -s命令来查看或修改这个默认值。</li>
<li><code>guardsize</code>，保护区域大小。如果<code>guardsize</code>大于0，则系统创建线程的时候会在其堆栈的尾部额外分配<code>guardsize</code>字节的空间，作为保护堆栈不被错误地覆盖的区域。如果<code>guardsize</code>等于0，则系统不为新创建的线程设置堆栈保护区。如果使用者通过<code>pthread_attr_setstackaddr</code>或<code>pthread_attr_setstack</code>函数手动设置线程的堆栈，则<code>guardsize</code>属性将被忽略。</li>
<li><code>schedparam</code>，线程调度参数。其类型是<code>sched_param</code>结构体。该结构体目前还只有一个整型类型的成员:<code>sched_priority</code>，该成员表示线程的运行优先级。</li>
<li><code>schedpolicy</code>，线程调度策略。该属性有<code>SCHED_FIFO</code>、<code>SCHED_RR</code>和<code>SCHED_OTHER</code>三个可选值，其中<code>SCHED_OTHER</code>是默认值。<code>SCHED_RR</code>表示采用轮转算法(round-robin）调度，<code>SCHED_FIFO</code>表示使用先进先出的方法调度，这两种调度方法都具备实时调度功能，但只能用于以超级用户身份运行的进程。</li>
<li><code>inheritsched</code>，是否继承调用线程的调度属性。该属性有<code>PTHREAD_INHERIT_SCHED</code> 和<code>PTHREAD_EXPLICIT_SCHED</code>两个可选值。前者表示新线程沿用其创建者的线程调度参数，这种情况下再设置新线程的调度参数属性将没有任何效果。后者表示调用者要明确地指定新线程的调度参数。</li>
<li><code>scope</code>，线程间竞争CPU的范围，即线程优先级的有效范围。POSIX标准定义了该属性的<code>PTHREAD_SCOPE_SYSTEM</code>和<code>PTHREAD_SCOPE_PROCESS</code>两个可选值，前者表示目标线程与系统中所有线程一起竞争CPU的使用，后者表示目标线程仅与其他隶属于同一进程的线程竞争CPU的使用。目前Linux只支持<code>PTHREAD_SCOPE_SYSTEM</code>这一种取值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread count %d\n&quot;</span>, n);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">42</span>;</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)&amp;ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">void</span> *tret;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_attr_t</span> attr; <span class="comment">/*通过线程属性来设置游离态*/</span></span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    pthread_create(&amp;tid, &amp;attr, tfn, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        err = pthread_join(tid, &amp;tret);</span><br><span class="line">        <span class="comment">// 因为线程是游离态，所以join不会成功</span></span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;thread_join error: %s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;thread exit code %d\n&quot;</span>, *(<span class="type">int</span> *)tret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220924113718288.png" alt="image-20220924113718288"></p>
<h2 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h2><p>多线程访问相同的资源时，也存在同步的问题，所以也需要同步机制。这里的POSIX信号量就是线程同步的机制之一。POSIX信号量和多进程编程（System V IPC）当中的信号量语义上是相同的，但是并不能保证能够进行混用，所以在线程当中还是使用POSIX比较好。</p>
<p>POSIX信号量函数的名字都以<code>sem_</code>开头，并不像大多数线程函数那样以<code>pthread_</code>开头。常用的POSIX信号量函数是下面5个:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>
<p>这些函数的第一个参数sem指向被操作的信号量。</p>
<p><code>sem_init</code>函数用于初始化一个未命名的信号量(POSIX信号量API支持命名信号量，不过在书中不讨论它)。<code>pshared</code>参数指定信号量的类型。如果其值为0，就表示这个信号量是当前进程的局部信号量，否则该信号量就可以在多个进程之间共享。<code>value</code>参数指定信号量的初始值。此外，初始化一个已经被初始化的信号量将导致不可预期的结果。</p>
<p><code>sem_destroy</code>函数用于销毁信号量，以释放其占用的内核资源。如果销毁一个正被其他线程等待的信号量，则将导致不可预期的结果。</p>
<p><code>sem_wait</code>函数以原子操作的方式将信号量的值减1。如果信号量的值为0，则<code>sem_wait</code>将被阻塞，直到这个信号量具有非0值。</p>
<p><code>sem_trywait</code>与<code>sem_wait</code>函数相似，不过它始终立即返回，而不论被操作的信号量是否具有非0值，相当于<code>sem_wait</code>的非阻塞版本。当信号量的值非0时，<code>sem_trywait</code>对信号量执行减1操作。当信号量的值为0时，它将返回-1并设置<code>errno</code>为<code>EAGAIN</code>。</p>
<p><code>sem_post</code>函数以原子操作的方式将信号量的值加1。当信号量的值大于0时，其他正在调用<code>sem_wait</code>等待信号量的线程将被唤醒。</p>
<p>使用信号量完成的生产者消费者</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*信号量实现 生产者 消费者问题*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">queue</span>[NUM];                     <span class="comment">//全局数组实现环形队列</span></span><br><span class="line"><span class="type">sem_t</span> blank_number, product_number; <span class="comment">//空格子信号量, 产品信号量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;blank_number);      <span class="comment">//生产者将空格子数--,为0则阻塞等待</span></span><br><span class="line">        <span class="built_in">queue</span>[i] = rand() % <span class="number">1000</span> + <span class="number">1</span>; <span class="comment">//生产一个产品</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----Produce---%d\n&quot;</span>, <span class="built_in">queue</span>[i]);</span><br><span class="line">        sem_post(&amp;product_number); <span class="comment">//将产品数++</span></span><br><span class="line"></span><br><span class="line">        i = (i + <span class="number">1</span>) % NUM; <span class="comment">//借助下标实现环形</span></span><br><span class="line">        sleep(rand() % <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;product_number); <span class="comment">//消费者将产品数--,为0则阻塞等待</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Consume---%d\n&quot;</span>, <span class="built_in">queue</span>[i]);</span><br><span class="line">        <span class="built_in">queue</span>[i] = <span class="number">0</span>;            <span class="comment">//消费一个产品</span></span><br><span class="line">        sem_post(&amp;blank_number); <span class="comment">//消费掉以后,将空格子数++</span></span><br><span class="line"></span><br><span class="line">        i = (i + <span class="number">1</span>) % NUM;</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> pid, cid;</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;blank_number, <span class="number">0</span>, NUM); <span class="comment">//初始化空格子信号量为5, 线程间共享 -- 0</span></span><br><span class="line">    sem_init(&amp;product_number, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//产品数为0</span></span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;blank_number);</span><br><span class="line">    sem_destroy(&amp;product_number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220927143404525.png" alt="image-20220927143404525"></p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁（也称互斥量）可以用于保护关键代码段，以确保其独占式的访问，这有点像一个二进制信号量。当进入关键代码段时，我们需要获得互斥锁并将其加锁，这等价于二进制信号量的Р操作﹔当离开关键代码段时，我们需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程，这等价于二进制信号量的V操作。</p>
<h3 id="互斥锁基础API"><a href="#互斥锁基础API" class="headerlink" title="互斥锁基础API"></a>互斥锁基础API</h3><p>POSIX互斥锁的相关函数主要有如下5个:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220927204729727.png" alt="image-20220927204729727"></p>
<p>这些函数的第一个参数<code>mutex</code>指向要操作的目标互斥锁，互斥锁的类型是<code>pthread_mutex_t</code>结构体。</p>
<p><code>pthread_mutex_init</code>函数用于初始化互斥锁。<code>mutexattr</code>参数指定互斥锁的属性。如果将它设置为NULL，则表示使用默认属性。我们将在下一小节讨论互斥锁的属性。除了这个函数外，我们还可以使用如下方式来初始化一个互斥锁:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER</span><br></pre></td></tr></table></figure>
<p>宏<code>PTHREAD_MUTEX_INITIALIZER</code>实际上只是把互斥锁的各个字段都初始化为0。<code>pthread_mutex_destroy</code>函数用于销毁互斥锁，以释放其占用的内核资源。销毁一个已经加锁的互斥锁将导致不可预期的后果。<code>pthread_mutex_lock</code>函数以原子操作的方式给一个互斥锁加锁。如果目标互斥锁已经被锁上，<code>pthread_mutex_lock</code>调用将阻塞，直到该互斥锁的占有者将其解锁。</p>
<p><code>pthread_mutex_trylock</code>与<code>pthread_mutex_lock</code>函数类似，不过它始终立即返回，而不论被操作的互斥锁是否已经被加锁，相当于<code>pthread_mutex_lock</code>的非阻塞版本。当目标互斥锁未被加锁时，<code>pthread_mutex_trylock</code>对互斥锁执行加锁操作。当互斥锁已经被加锁时，<code>pthread_mutex_trylock</code>将返回错误码<code>EBUSY</code>。需要注意的是，这里讨论的<code>pthread_mutex_lock</code>和<code>pthread_mutex_trylock</code>的行为是针对普通锁而言的。后面我们将看到，对于其他类型的锁而言，这两个加锁函数会有不同的行为。</p>
<p><code>pthread_mutex_unlock</code>函数以原子操作的方式给一个互斥锁解锁。如果此时有其他线程正在等待这个互斥锁，则这些线程中的某一个将获得它。</p>
<p>上面这些函数成功时返回0，失败则返回错误码。</p>
<h3 id="互斥锁属性"><a href="#互斥锁属性" class="headerlink" title="互斥锁属性"></a>互斥锁属性</h3><p><code>pthread_mutexattr_t</code>结构体定义了一套完整的互斥锁属性。线程库提供了一系列函数来操作<code>pthread_mutexattr_t</code>类型的变量，以方便我们获取和设置互斥锁属性。这里我们列出其中一些主要的函数:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220927211449413.png" alt="image-20220927211449413"></p>
<p>本书只讨论互斥锁的两种常用属性:<code>pshared</code>和<code>type</code>。互斥锁属性<code>pshared</code>指定是否允许跨进程共享互斥锁，其可选值有两个:</p>
<ul>
<li><code>PTHREAD_PROCESS_SHARED</code>。互斥锁可以被跨进程共享。</li>
<li><code>PTHREAD_PROCESS_PRIVATE</code>。互斥锁只能被和锁的初始化线程隶属于同一个进程的线程共享。</li>
</ul>
<p>互斥锁属性type指定互斥锁的类型。Linux支持如下4种类型的互斥锁:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220928214206066.png" alt="image-20220928214206066"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*线程之间共享资源stdout*/</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_thread</span><span class="params">(<span class="type">int</span> ret, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s:%s\n&quot;</span>, str, strerror(ret));</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>); <span class="comment">/*模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;world\n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">5</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (flag--)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HELLO &quot;</span>);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WORLD\n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cancel(tid); <span class="comment">//  将子线程杀死,子线程中自带取消点</span></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// main中的return可以将整个进程退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220928214919210.png" alt="image-20220928214919210"></p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>如果说互斥锁是用于同步线程对共享数据的访问的话，那么条件变量则是用于在线程之间同步共享数据的值。条件变量提供了一种线程间的通知机制:当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程。</p>
<p>条件变量的相关函数主要有如下5个:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220929110939180.png" alt="image-20220929110939180"></p>
<p>这些函数的第一个参数<code>cond</code>指向要操作的目标条件变量，条件变量的类型是<code>pthread_cond_t</code>结构体。</p>
<p><code>pthread_cond_init</code>函数用于初始化条件变量。<code>cond_attr</code>参数指定条件变量的属性。如果将它设置为NULL，则表示使用默认属性。条件变量的属性不多，而和互斥锁的属性类型相似。除了<code>pthread_cond_init</code>函数外，我们还可以使用如下方式来初始化一个条件变量:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>
<p>宏<code>PTHREAD_COND_INITIALIZER</code>实际上只是把条件变量的各个字段都初始化为0。</p>
<p><code>pthread_cond_destroy</code>函数用于销毁条件变量，以释放其占用的内核资源。销毁一个正在被等待的条件变量将失败并返回<code>EBUSY</code>。</p>
<p><code>pthread_cond_broadcast</code>函数以广播的方式唤醒所有等待目标条件变量的线程。</p>
<p><code>pthread_cond_signal</code>函数用于唤醒一个等待目标条件变量的线程。至于哪个线程将被唤醒，则取决于线程的优先级和调度策略。有时候我们可能想唤醒一个指定的线程，但<code>pthread</code>没有对该需求提供解决方法。不过我们可以间接地实现该需求:定义一个能够唯一表示目标线程的全局变量，在唤醒等待条件变量的线程前先设置该变量为目标线程，然后采用广播方式唤醒所有等待条件变量的线程，这些线程被唤醒后都检查该变量以判断被唤醒的是否是自己，如果是就开始执行后续代码，如果不是则返回继续等待。</p>
<p><code>pthread_cond_wait</code>函数用于等待目标条件变量。<code>mutex</code>参数是用于保护条件变量的互斥锁，以确保<code>pthread_cond_wait</code>操作的原子性。在调用<code>pthread_cond_wait</code>前，必须确保互斥锁<code>mutex</code>已经加锁，否则将导致不可预期的结果。<code>pthread_cond_wait</code>函数执行时，首先把调用线程放入条件变量的等待队列中，然后将互斥锁<code>mutex</code>解锁。可见，从<code>pthread_cond_wait</code>开始执行到其调用线程被放入条件变量的等待队列之间的这段时间内，<code>pthread_cond_signal</code>和<code>pthread_cond_broadcast</code>等函数不会修改条件变量。换言之，<code>pthread_cond_wait</code>函数不会错过目标条件变量的任何变化。当<code>pthread_cond_wait</code>函数成功返回时，互斥锁<code>mutex</code>将再次被锁上。</p>
<p>上面这些函数成功时返回0，失败则返回错误码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*借助条件变量模拟 生产者-消费者 问题*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*链表作为公享数据,需被互斥量保护*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 静态初始化 一个条件变量 和 一个互斥量*/</span></span><br><span class="line"><span class="type">pthread_cond_t</span> has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="keyword">while</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123; <span class="comment">//头指针为空,说明没有节点    可以为if吗</span></span><br><span class="line">            pthread_cond_wait(&amp;has_product, &amp;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        mp = head;</span><br><span class="line">        head = mp-&gt;next; <span class="comment">//模拟消费掉一个产品</span></span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Consume %lu---%d\n&quot;</span>, pthread_self(), mp-&gt;num);</span><br><span class="line">        <span class="built_in">free</span>(mp);</span><br><span class="line">        sleep(rand() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mp = (msg *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg));</span><br><span class="line">        mp-&gt;num = rand() % <span class="number">1000</span> + <span class="number">1</span>; <span class="comment">//模拟生产一个产品</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Produce ---------------------%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        mp-&gt;next = head;</span><br><span class="line">        head = mp;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">        pthread_cond_signal(&amp;has_product); <span class="comment">//将等待在该条件变量上的一个线程唤醒</span></span><br><span class="line">        sleep(rand() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> pid, cid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220929193427533.png" alt="image-20220929193427533"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>高级I/O函数</title>
    <url>/2022/08/15/Linux/%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="高级I-O函数"><a href="#高级I-O函数" class="headerlink" title="高级I/O函数"></a>高级I/O函数</h1><p>《Linux高性能服务器编程》在第六章讲解了很多Linux提供了很多高级I/O函数，在这里做个笔记。这一章主要内容包括：pipe函数、<code>dup</code>和<code>dup2</code>函数、readv函数和writev函数、sendfile函数、mmap函数和munmap函数、splice函数、tee函数和fcntl函数。</p>
<span id="more"></span>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h3><p><code>pipe</code>函数可用于创建一个管道（匿名），以实现进程之间的通讯（主要感觉是父子进程之间）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>
<p><code>pipefd</code>是传出参数，它包含两个文件描述符。我们就是使用这两个文件描述符进行进程之间的通讯。</p>
<p><code>pipe</code>函数调用成功返回0，如果失败返回-1，并且设置<code>errno</code>。</p>
<p><code>pipe</code>函数创建的管道是单向通讯，其中<code>pipefd[0]</code>只能读，<code>pipefd[1]</code>只能写。并且默认情况下，这一对文件描述符都是阻塞的，但是也可以进行修改，变成非阻塞的。</p>
<p><code>pipe</code>函数创建的管道内部传输的数据是字节流，管道本身有一个<strong>容量限制</strong>，最多能写下<code>65536</code>个字节，但是这个大小可以使用<code>fcntl</code>进行修改。</p>
<p>如果管道的写端文件描述符<code>pipefd[1]</code>的<strong>引用计数</strong>减少至0，即没有任何进程需要往管道中写人数据，则针对该管道的读端文件描述符 <code>pipefd[0]</code>的<code>read</code>操作将返回0，即读取到了文件结束标记（End Of File，EOF);反之，如果管道的读端文件描述符<code>pipefd[0]</code>的引用计数减少至0，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符<code>pipefd[1]</code>的<code>write</code>操作将失败，并引发<code>SIGPIPE</code>信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;test for pipe\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(fd) == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;fork err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从管道的文件描述符fd[0]中将信息读出</span></span><br><span class="line">        <span class="type">int</span> len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 将读的信息写到STDOUT_FILENO上</span></span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 向管道的文件描述符fd[1]中写入</span></span><br><span class="line">        write(fd[<span class="number">1</span>], p, <span class="built_in">strlen</span>(p));</span><br><span class="line">        <span class="comment">// 回收子进程</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220905111959054.png" alt="image-20220905111959054"></p>
<h3 id="socketpair函数"><a href="#socketpair函数" class="headerlink" title="socketpair函数"></a>socketpair函数</h3><p><code>socketpair</code>函数能创建双向管道（一对套接字），并且似乎只能用于本地通讯。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socketpair</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol, <span class="type">int</span> sv[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>
<p><code>socketpair</code>前三个参数和<code>socket</code>一样。</p>
<p><code>domain</code>是协议族类型，但是因为是本地通讯所以只能是<code>AF_UNIX</code></p>
<p><code>type</code>参数指定服务类型。服务类型主要有<code>SOCK_STREAM</code>服务（流服务）和<code>SOCK_UGRAM</code>（数据报）服务。</p>
<p><code>protocol</code>参数设置具体的协议。但是在前两个参数确定的情况下，这个参数的值基本上唯一的，所有几乎在所有情况下，我们都把这个值设置为0，表示使用默认协议。</p>
<p><code>sv[2]</code>则是传出参数，和上面的<code>pipe</code>相同，里面包含着两个通讯用的文件描述符，只不过这两个文件描述符是既可以读又可以写的。</p>
<p><code>socketpair</code>函数调用成功返回0，如果失败返回-1，并且设置<code>errno</code>。</p>
<p><code>socketpair</code>用法比较简单，和上面<code>pipe</code>有一些类似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, fd))</span><br><span class="line">        sys_err(<span class="string">&quot;socketpair error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;fork err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="comment">// 从管道的文件描述符fd[0]中将信息读出</span></span><br><span class="line">        <span class="type">int</span> len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 将读的信息写到STDOUT_FILENO上</span></span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">        <span class="type">char</span> *p = <span class="string">&quot;child test for socketpair\n&quot;</span>;</span><br><span class="line">        write(fd[<span class="number">0</span>], p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="type">char</span> *p = <span class="string">&quot;parent test for socketpair\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 向管道的文件描述符fd[1]中写入</span></span><br><span class="line">        write(fd[<span class="number">1</span>], p, <span class="built_in">strlen</span>(p));</span><br><span class="line">        <span class="type">int</span> len = read(fd[<span class="number">1</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 将读的信息写到STDOUT_FILENO上</span></span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">        <span class="comment">// 回收子进程</span></span><br><span class="line"></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220905204624841.png" alt="image-20220905204624841"></p>
<h3 id="mkfifo函数"><a href="#mkfifo函数" class="headerlink" title="mkfifo函数"></a>mkfifo函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>
<p><code>mkfifo</code>会创建一个<code>fifo</code>类型的文件，然后两个进程可任意通过<code>open</code>的方式打开这个文件进行进程间的通讯。</p>
<p><code>pathname</code>表示文件名，<code>mode</code>指定了文件的读写权限。</p>
<p>函数成功调用返回0失败返回-1，并且设置<code>errno</code>。</p>
<p>下面的代码就是创建一个名为mytestfifo的fifo文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = mkfifo(<span class="string">&quot;mytestfifo&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;mkfifo error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个文件类型前面有个<code>p</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220905211906735.png" alt="image-20220905211906735"></p>
<p>管道文件读取或者写入和普通文件相同，我们都可以使用<code>open</code>对其进行操作但是需要的是注意两点：</p>
<p>1.程序<strong>不能以O_RDWR模式打开FIFO文件进行读写操作</strong>，而其行为也未明确定义，因为如一个管道以读/写方式打开，进程就会读回自己的输出，同时我们通常使用FIFO只是为了单向的数据传递。</p>
<p>2.打开FIFO文件通常有四种方式，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open(<span class="type">const</span> <span class="type">char</span> *pathname, O_RDONLY); <span class="comment">// 1</span></span><br><span class="line">open(<span class="type">const</span> <span class="type">char</span> *pathname, O_RDONLY | O_NONBLOCK); <span class="comment">// 2</span></span><br><span class="line">open(<span class="type">const</span> <span class="type">char</span> *pathname, O_WRONLY); <span class="comment">// 3</span></span><br><span class="line">open(<span class="type">const</span> <span class="type">char</span> *pathname, O_WRONLY | O_NONBLOCK); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p><code>O_NONBLOCK</code>表示阻塞。所以</p>
<ul>
<li><code>O_RDONLY</code>：open将会调用阻塞，除非有另外一个进程以写的方式打开同一个FIFO，否则一直等待。</li>
<li><code>O_WRONLY</code>：open将会调用阻塞，除非有另外一个进程以读的方式打开同一个FIFO，否则一直等待。</li>
<li><code>O_RDONLY|O_NONBLOCK</code>：如果此时没有其他进程以写的方式打开FIFO，此时open也会成功返回，此时FIFO被读打开，而不会返回错误。</li>
<li><code>O_WRONLY|O_NONBLOCK</code>：立即返回，如果此时没有其他进程以读的方式打开，open会失败打开，此时FIFO没有被打开，返回-1。</li>
</ul>
<p>例子：</p>
<p>fifo_w.cpp：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter like this: ./a.out fifoname\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_WRONLY); <span class="comment">//打开管道文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;open fifo error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello world %d\n&quot;</span>, i);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf)); <span class="comment">// 向管道写数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>fifo_r.cpp:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, len;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out fifoname\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int fd = mkfifo(&quot;testfifo&quot;, 644);</span></span><br><span class="line">    <span class="comment">// open(fd, ...);</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDONLY); <span class="comment">// 打开管道文件</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = read(fd, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 从管道的读端获取数据</span></span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220907093500990.png" alt="image-20220907093500990"></p>
<p><code>FIFO</code>文件会存在进程之间通讯的问题。比如多个进程对<code>FIFO</code>进行写，但是只有一个<code>FIFO</code>进行读取时写入的数据块会不会发生交错？</p>
<p>为了解决这个问题，<strong>系统规定：</strong>在一个以<code>O_WRONLY</code>（即阻塞方式）打开的<code>FIFO</code>中， 如果写入的数据长度小于等待<code>PIPE_BUF</code>，那么或者写入全部字节，或者一个字节都不写入。</p>
<p>所以所有的写请求都是发往一个阻塞的FIFO的，并且每个写记请求的数据长度小于等于<code>PIPE_BUF</code>字节，系统就可以确保数据决不会交错在一起。</p>
<p>其中<code>PIPE_BUF</code>是<code>FIFO</code>的长度，它在头文件<code>limits</code>.h中被定义。在linux或其他类UNIX系统中，它的值通常是4096字节。</p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://blog.csdn.net/xiajun07061225/article/details/8471777">https://blog.csdn.net/xiajun07061225/article/details/8471777</a></li>
<li><a href="https://www.cnblogs.com/52php/p/5840229.html">https://www.cnblogs.com/52php/p/5840229.html</a></li>
</ul>
<h2 id="dup和dup2函数"><a href="#dup和dup2函数" class="headerlink" title="dup和dup2函数"></a>dup和dup2函数</h2><p><code>dup</code>和<code>dup2</code>用于复制文件描述符，通常用于重定向。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure>
<p><code>dup</code>函数创建一个新的文件描述符，该新文件描述符和原有文件描述符<code>oldfd</code>指向相同的文件、管道或者网络连接。并且dup返回的文件描述符总是取系统当前可用的最小整数值。</p>
<p><code>dup2</code>和<code>dup</code>类似，不过它将返回第一个不小于<code>newfd</code>的整数值的文件描述符，并且<code>newfd</code>这个文件描述符也将会指向<code>oldfd</code>指向的文件，原来的<code>newfd</code>指向的文件将会被关闭（除非<code>newfd</code>和<code>oldfd</code>相同）。</p>
<p><code>dup</code>和<code>dup2</code>系统调用失败时返回-1并设置<code>errno</code>，成功就返回新的文件描述符。</p>
<p><strong>注意：</strong>通过dup和dup2创建的文件描述符并<strong>不继承原文件描述符的属性</strong>，比如close-on-exec和non-blocking 等</p>
<p><code>dup</code>简单，输入<code>oldfd</code>直接返回复制的文件描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;text.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    assert(fd != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd = %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd2 = dup(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd2 = %d\n&quot;</span>, fd2);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">    write(fd, str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;world\n&quot;</span>;</span><br><span class="line">    write(fd2, str2, <span class="keyword">sizeof</span>(str2));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220815171158327.png" alt="image-20220815171158327"></p>
<p><code>dup2</code>感觉复杂一些，其实<code>dup2</code>忽略第二个参数，功能是和<code>dup</code>一样的，除此之外<code>dup2</code>加了一个将返回第一个不小于<code>newfd</code>的整数值的文件描述符的功能，并且<code>newfd</code>也将指向<code>oldfd</code>指向的文件。</p>
<p>下面的代码调用<code>dup2</code>，文件描述符fd2原来指向”text2.txt”文件的，调用<code>dup2</code>后，fd2改为指向”text.txt”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220815173243219.png" alt="image-20220815173243219"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;text.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;text2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    assert(fd1 != <span class="number">-1</span>);</span><br><span class="line">    assert(fd2 != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1 = %d, fd2 = %d\n&quot;</span>, fd1, fd2);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd3 = dup2(fd1, fd2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1 = %d,fd2 = %d,fd3 = %d\n&quot;</span>, fd1, fd2, fd3);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">    write(fd1, str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;world\n&quot;</span>;</span><br><span class="line">    write(fd2, str2, <span class="keyword">sizeof</span>(str2));</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot; hello world\n&quot;</span>;</span><br><span class="line">    write(fd3, str2, <span class="keyword">sizeof</span>(str2));</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    close(fd3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220815173321291.png" alt="image-20220815173321291"></p>
<h2 id="readv函数和writev函数"><a href="#readv函数和writev函数" class="headerlink" title="readv函数和writev函数"></a>readv函数和writev函数</h2><p><code>readv</code>函数将数据从文件描述符读到分散的内存块中，即分散读; </p>
<p><code>writev</code>函数则将多块分散的内存数据一并写人文件描述符中，即集中写。它们的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br></pre></td></tr></table></figure>
<p><code>fd</code>被操作的目标文件描述符。</p>
<p><code>iov</code>是<code>iovec</code>类型的数组，在<code>recvmsg</code>和<code>sendmsg</code>中接触过。</p>
<p><code>iovcnt</code>是<code>iov</code>数组的长度。</p>
<p><code>iovec</code>结构体封装了一块内存的起始位置和长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span>                    <span class="comment">/* Scatter/gather array items */</span></span><br><span class="line">   <span class="type">void</span>  *iov_base;              <span class="comment">/* Starting address */</span></span><br><span class="line">   <span class="type">size_t</span> iov_len;               <span class="comment">/* Number of bytes to transfer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>readv</code>和 <code>writev</code>在成功时返回读出/写入<code>fd</code>的字节数，失败则返回-1并设置errno。</p>
<p><code>readv</code>和<code>writev</code>是个非常有用的函数。比如：当Web服务器解析完一个HTTP请求之后，如果目标文档存在且客户具有读取该文档的权限，那么它就需要发送一个HTTP应答来传输该文档。这个HTTP应答包含1个状态行、多个头部字段、1个空行和文档的内容。其中，前3部分的内容可能被Web服务器放置在一块内存中，而文档的内容则通常被读入到另外一块单独的内存中（通过read函数或mmap函数)。我们并不需要把这两部分内容拼接到一起再发送，而是可以使用writev函数将它们同时写出。</p>
<p>举一个man手册上<code>writev</code>函数的例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str0 = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">    <span class="type">char</span> *str1 = <span class="string">&quot;world\n&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    <span class="type">ssize_t</span> nwritten;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = str0;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(str0);</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = str1;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">strlen</span>(str1);</span><br><span class="line"></span><br><span class="line">    nwritten = writev(STDOUT_FILENO, iov, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220815180645424.png" alt="image-20220815180645424"></p>
<h2 id="sendfile函数"><a href="#sendfile函数" class="headerlink" title="sendfile函数"></a>sendfile函数</h2><p><code>sendfile</code>函数在两个文件描述符之间直接传递数据（完全在内核中操作)，从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。<code>sendfile</code>函数的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<p><code>out_fd</code>参数是待写入内容的文件描述符</p>
<p><code>in_fd</code>参数是待读取内容的文件描述符</p>
<p><code>offset</code>参数是指从读入文件流的哪个位置开始读，如果为空，则使用读入文件流默认的起始位置</p>
<p><code>count</code>参数指定在文件描述符<code>in_fd</code>和<code>out_fd</code>之间传输的字节数</p>
<p><code>sendfile</code>成功时返回传输的字节数，失败则返回-1并设置<code>errno</code>。</p>
<p>该函数的man手册明确指出，<code>in_fd</code>必须是一个支持类似<code>mmap</code>函数的文件描述符，即它必须指向真实的文件，不能是socket和管道。而<code>out_fd</code>则必须是一个socket。由此可见，<code>sendfile</code>几乎是专门为在网络上传输文件而设计的。</p>
<p>用了一个书上的例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number filename\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file_name = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> filefd = open(file_name, O_RDONLY);</span><br><span class="line">    assert(filefd &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">    fstat(filefd, &amp;stat_buf);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(sock, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = accept(sock, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);</span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sendfile(connfd, filefd, <span class="literal">NULL</span>, stat_buf.st_size);</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220815185556863.png" alt="image-20220815185556863"></p>
<h2 id="mmap函数和munmap函数"><a href="#mmap函数和munmap函数" class="headerlink" title="mmap函数和munmap函数"></a>mmap函数和munmap函数</h2><p><code>mmap</code>函数用于申请一段内存空间。可以将这段内存作为进程间通讯的共享内存，也可以将文件直接映射其中。<code>munmap</code>函数用于释放<code>mmap</code>创建的内存空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,<span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>
<p><code>addr</code>参数运行用户使用某个特定的地址作为这段内存的起始地址。如果它被设置为NULL，则系统会自动分配一个地址。</p>
<p><code>length</code>参数指定内存段的长度</p>
<p><code>prot</code>参数用来设置内存段的访问权限，可以下面几个值</p>
<ul>
<li><p><code>PROT_EXEC</code>，内存段可执行</p>
</li>
<li><p><code>PROT_READ</code>，内存段可读</p>
</li>
<li><p><code>PROT_WRITE</code>，内存段可写</p>
</li>
<li><p><code>PROT_NONE</code>，内存段不能被访问</p>
</li>
</ul>
<p><code>flags</code>参数控制内存段内容被修改后程序的行为。它常用的取值如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220815203154208.png" alt="image-20220815203154208"></p>
<p><code>fd</code>参数是被映射文件对应的文件描述符。它一般通过open系统调用获得。</p>
<p><code>offset</code>参数设置从文件的何处开始映射。</p>
<p><code>mmap</code>函数成功时返回指向目标内存区域的指针，失败则返回<code>MAP_FAILED((void*)-1)</code>并设置<code>errno</code>。</p>
<p><code>munmap</code>函数成功时返回0，失败则返回-1并设置<code>errno</code>。</p>
<h2 id="splice函数"><a href="#splice函数" class="headerlink" title="splice函数"></a>splice函数</h2><p><code>splice</code>用于在两个文件描述符之间移动数据，是零拷贝操作。看了<code>man</code>手册，发现这个<code>splice</code>函数跟pipe管道关系不浅。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816100155851.png" alt="image-20220816100155851"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span> *off_in, <span class="type">int</span> fd_out, <span class="type">loff_t</span> *off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p><code>fd_in</code>参数是待输人数据的文件描述符。如果<code>fd_in</code>是一个管道文件描述符，那么 <code>off_in</code>参数必须被设置为NULL。如果<code>fd_in</code>不是一个管道文件描述符（比如 socket)，那么<code>off_in</code>表示从输入数据流的何处开始读取数据。此时，若<code>off_in</code>被设置为NULL，则表示从输入数据流的当前偏移位置读入；若<code>off_in</code>不为NULL，则它将指出具体的偏移位置。</p>
<p><code>fd_out/off_out</code>参数的含义与<code>fd_in/off_in</code>相同，不过用于输出数据流。</p>
<p><code>len</code>参数指定移动数据的长度</p>
<p><code>flags</code>参数则控制数据如何移动，它可以被设置为下表中的某些值的按位或。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816100934412.png" alt="image-20220816100934412"></p>
<p>使用<code>splice</code>函数时，<code>fd_in</code>和<code>fd_out</code>必须至少有一个是管道文件描述符。</p>
<p><code>splice</code>函数调用成功时返回移动字节的数量。它可能返回0，表示没有数据需要移动，这发生在从管道中读取数据（<code>fd_in</code>是管道文件描述符）而该管道没有被写入任何数据时。<code>splice</code>函数失败时返回-1并设置<code>errno</code>。常见的<code>errno</code>如下表所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816101918940.png" alt="image-20220816101918940"></p>
<p>下面用了一个书中的例子，实现一个零拷贝的回射服务器，它将客户端发送的信息通过<code>splice</code>从<code>pipefd[1]</code>写入管道，再使用<code>splice</code>从<code>pipefd[0]</code>向客户端写东西，从而实现零拷贝的回射服务器（整个过程没有使用<code>read</code>或者<code>write</code>操作）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(sock, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = accept(sock, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);</span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line">        ret = pipe(pipefd);</span><br><span class="line">        ret = splice(connfd, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line">        ret = splice(pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, connfd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816102919876.png" alt="image-20220816102919876"></p>
<h2 id="tee函数"><a href="#tee函数" class="headerlink" title="tee函数"></a>tee函数</h2><p><code>tee</code>函数在两个管道描述符之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据仍然可以用于后续操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">tee</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">int</span> fd_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p><code>fd_in</code>和<code>fd_out</code>是文件描述符，但是必须是管道文件描述符</p>
<p><code>len</code>参数指定移动数据的长度</p>
<p><code>flags</code>参数则控制数据如何移动，它可以被设置为下表中的某些值的按位或，它的参数其实和<code>splice</code>函数相同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816100934412.png" alt="image-20220816100934412"></p>
<p><code>tee</code>函数成功时返回在两个文件描述符之间复制的数据数量（字节数)。返回0表示没有复制任何数据。<code>tee</code>失败时返回-1并设置<code>errno</code>。</p>
<p>书中代码利用<code>tee</code>函数和<code>splice</code>函数，实现了Linux 下<code>tee</code>程序（同时输出数据到终端和文件的程序，不要和<code>tee</code>函数混淆）的基本功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> filefd = open(argv[<span class="number">1</span>], O_CREAT | O_WRONLY | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">	assert(filefd &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pipefd_stdout[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> ret = pipe(pipefd_stdout);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pipefd_file[<span class="number">2</span>];</span><br><span class="line">	ret = pipe(pipefd_file);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// close( STDIN_FILENO );</span></span><br><span class="line">	<span class="comment">//  dup2( pipefd_stdout[1], STDIN_FILENO );</span></span><br><span class="line">	<span class="comment">// write( pipefd_stdout[1], &quot;abc\n&quot;, 4 );</span></span><br><span class="line">	ret = splice(STDIN_FILENO, <span class="literal">NULL</span>, pipefd_stdout[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	ret = tee(pipefd_stdout[<span class="number">0</span>], pipefd_file[<span class="number">1</span>], <span class="number">32768</span>, SPLICE_F_NONBLOCK);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	ret = splice(pipefd_file[<span class="number">0</span>], <span class="literal">NULL</span>, filefd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	ret = splice(pipefd_stdout[<span class="number">0</span>], <span class="literal">NULL</span>, STDOUT_FILENO, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	close(filefd);</span><br><span class="line">	close(pipefd_stdout[<span class="number">0</span>]);</span><br><span class="line">	close(pipefd_stdout[<span class="number">1</span>]);</span><br><span class="line">	close(pipefd_file[<span class="number">0</span>]);</span><br><span class="line">	close(pipefd_file[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816111052593.png" alt="image-20220816111052593"></p>
<h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><p><code>fcntl</code>函数提供了对文件描述符的各种控制操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure>
<p><code>fd</code>参数是被操作的文件描述符，<code>cmd</code>参数指定执行何种类型的操作。根据操作类型的不同，该函数可能还需要第三个可选参数 <code>arg</code>。<code>fcntl</code>函数支持的常用操作及其参数如下表所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816114524640.png" alt="image-20220816114524640"></p>
<p><code>fcntl</code>函数成功时的返回值如表中最后一列所示，失败则返回-1并设置<code>errno</code>。</p>
<p>在网络编程中，<code>fcntl</code>函数通常用来将一个文件描述符设置为非阻塞的。</p>
<p>比如：终端文件默认是阻塞读的，这里用 fcntl 将其更改为非阻塞读</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TRY <span class="string">&quot;try again\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> flags, n;</span><br><span class="line"></span><br><span class="line">    flags = fcntl(STDIN_FILENO, F_GETFL); <span class="comment">//获取stdin属性信息</span></span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="type">int</span> ret = fcntl(STDIN_FILENO, F_SETFL, flags);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n = read(STDIN_FILENO, buf, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EAGAIN)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;read /dev/tty&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            write(STDOUT_FILENO, MSG_TRY, <span class="built_in">strlen</span>(MSG_TRY));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220816115555375.png" alt="image-20220816115555375"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>python舞蹈链数独游戏</title>
    <url>/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/python%E8%88%9E%E8%B9%88%E9%93%BE%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="python舞蹈链数独游戏"><a href="#python舞蹈链数独游戏" class="headerlink" title="python舞蹈链数独游戏"></a>python舞蹈链数独游戏</h1><h2 id="数独简介"><a href="#数独简介" class="headerlink" title="数独简介"></a>数独简介</h2><p>数独游戏是一款古老的智力游戏，据说最早可以追溯到中国古代的“河图洛书”，但是真实可查的是在18世纪数学家欧拉等人发明了“拉丁方阵”等成为数独的最早的样子，后来经过日本的改进逐渐成为现代的数独游戏[1]。</p>
<p>数独游戏一共有$9 \times 9$个单元格子，在数独游戏当中，玩家需要根据已有的数字去推理出所有的剩余空格的数字，并且要保证 $9 \times 9$的单位格子中每一行、每一列以及每个$3 \times 3$的九宫格内的数字不重复。数独游戏在开始的适合叫做初盘（如图1(a)所展示），包含数字和空格，当游戏成功完成时的状态叫终盘（图1(b)所展示），只有填写完成的数字。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712105810489.png" alt="图1"></p>
<span id="more"></span>
<h2 id="数独的解法"><a href="#数独的解法" class="headerlink" title="数独的解法"></a>数独的解法</h2><p>数独的求解方法有很有很多种，比如回溯求解、基于最小候选数求解等，本次作业我们选择的方法是基于舞蹈链的数组且介方法，在本小节会着重介绍舞蹈链以及数组求解的理论知识。</p>
<h3 id="精确覆盖问题"><a href="#精确覆盖问题" class="headerlink" title="精确覆盖问题"></a>精确覆盖问题</h3><p>在一个全集$X$ 中，若干子集的集合为 $S$。精确覆盖是指，$S$的子集$S^<em>$恰好满足$X$中的每一个元素在$S^</em>$中出现一次。这样讲可能不太通俗所以下面通过一个小例子讲解一下这个问题。</p>
<p>我们给定一个由0和1组成的矩阵，希望找到一个行的集合，使得集合中每一列都恰好包含一个1，矩阵如表1所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><strong>1</strong></th>
<th style="text-align:center"><strong>2</strong></th>
<th style="text-align:center"><strong>3</strong></th>
<th style="text-align:center"><strong>4</strong></th>
<th style="text-align:center"><strong>5</strong></th>
<th style="text-align:center"><strong>6</strong></th>
<th><strong>7</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>A</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center"><strong>B</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center"><strong>C</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center"><strong>D</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center"><strong>E</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center"><strong>F</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>我们可以简单的通过回溯法得到最终的解是$S^*={ B,D,F}$，结果如表2所示:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><strong>1</strong></th>
<th style="text-align:center"><strong>2</strong></th>
<th style="text-align:center"><strong>3</strong></th>
<th style="text-align:center"><strong>4</strong></th>
<th style="text-align:center"><strong>5</strong></th>
<th style="text-align:center"><strong>6</strong></th>
<th><strong>7</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>B</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center"><strong>D</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center"><strong>F</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>但是在这个过程中涉及大量的矩阵进行缓存更改以及回溯的问题，这一过程是非常浪费系统资源的，所以如何优雅且高效的解决这个问题，减少系统开销，成为了算法大师们的一个问题。</p>
<h3 id="舞蹈链"><a href="#舞蹈链" class="headerlink" title="舞蹈链"></a>舞蹈链</h3><p>为了解决上面提到的回溯寻找精确覆盖问题，算法大师Donald Ervin Knuth提出了舞蹈链（Dancing Links）的数据结构，并且把求解过程称为X算法。舞蹈链的数据结构中每个节点都要6个指针，分别是：Left、Right、Up、Down、Col、Row，分别代表着左、右、上、下、行、列。舞蹈链中每一列都有特殊的结点，叫做列头，列头会记录这一列中的结点个数，列头互相连接构成了链表头，舞蹈链的图示可以参考图2。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712112439300.png" alt="图2"></p>
<p>有了舞蹈链的数据结构之后，我们可以使用X算法进行求解。X算法的步骤如下：</p>
<ol>
<li>如果矩阵$M$为空，没有任何列，则当前的选择为问题的解，返回成功；否则进入2。</li>
<li>选择列$c$，其中  的结点数最少的列，即1的数量最少，如果其中某一列没有1，则返回失败。</li>
<li>选择行$r$（其中的 $r$满足 $M_{r,c}=1$），并将 $r$加入到当前的解当中。</li>
<li>从矩阵$M$中删除满足 $M<em>{r,j}=1 and M</em>{i,j}=1$的第 $i$行和第$j$列，得到矩阵$\acute{M}$ </li>
<li>令$M=\acute{M}$继续进入1。</li>
</ol>
<p>这样说可能比较抽象，让我们以表1代表的矩阵为列，进行演示：</p>
<ul>
<li>首先，因为矩阵$M$不为空，还存在列，算法没有结束。</li>
<li>我们选择1数量最少的列“1”，如表3所展示。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
<th><strong>7</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td><strong>1</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td><strong>1</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712155430959.png" alt="image-20220712155430959"></p>
<ul>
<li>因为$M<em>{A,1}=1$并且$M</em>{B,1}=1$所以可以依次选取 $A,B$行。</li>
<li>先选取$A$行（将$A$行加入到当前的解中），第1、4、7列均为1，如表4所展示。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
<th><strong>7</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712155512313.png" alt="image-20220712155512313"></p>
<ul>
<li>第1列中第$A$行和第$B$行为1，第4列中第 $A,B,C$行为1，第7列中第$A,C,E,F$行和第$1、4、7$列，如表5所展示。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
<th><strong>7</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712155732882.png" alt="image-20220712155732882"></p>
<ul>
<li>得到矩阵$\acute{M}$，继续进行递归</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>D</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712155807311.png" alt="image-20220712155807311"></p>
<ul>
<li>算法递归发现第2列为0，所以返回失败，所以开始选择$A$行不是算法的解，则从解中删除 $A$</li>
<li>返回最开始的部分，将$B$行加入到当前的解中。第1、4列均为1，如表7所展示。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
<th><strong>7</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712155848091.png" alt="image-20220712155848091"></p>
<ul>
<li>第一列中$A$行和$B$行为1，第4列中第$A,B,C$行为1。所以移除第$A,B,C$行和第1、4列，如表8所示。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
<th><strong>7</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712155933356.png" alt="image-20220712155933356"></p>
<ul>
<li>最终得到矩阵如表9所展示，并且继续进行递归</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
<th><strong>7</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>D</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712160005226.png" alt="image-20220712160005226"></p>
<ul>
<li>选择1数量最少的列“5”。</li>
<li>将$D$行加入到当前的解中。第3、5、6列均为1。</li>
<li>第3列中第$D、E$行为1，第5列中第$D$行为1，第6列中第$D、E$行为1。所以移除第$D、E$行和第3、5、6列。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
<th><strong>7</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>D</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712160122977.png" alt="image-20220712160122977"></p>
<ul>
<li>最终得到矩阵如表11所展示，继续递归下去就知道这个解是成功的。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>2</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712160144320.png" alt="image-20220712160144320"></p>
<ul>
<li>所以最终解为${B,D,F}$</li>
</ul>
<p>通过这种实例展示，我们大致可以明白舞蹈链的运算过程了。这一小节如果看不太明白的可以看一下下面的链接：</p>
<p><a href="https://www.cnblogs.com/grenet/p/3145800.html">https://www.cnblogs.com/grenet/p/3145800.html</a></p>
<p><a href="https://zh.m.wikipedia.org/zh-hans/X%E7%AE%97%E6%B3%95">https://zh.m.wikipedia.org/zh-hans/X%E7%AE%97%E6%B3%95</a></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>整个数独游戏我采用python语言进行完成，界面采用pyqt进行编写。在这里小节介绍如何实现数组游戏，只介绍核心代码，其中几个类的关系如图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712160424299.png" alt="image-20220712160424299"></p>
<h3 id="舞蹈链实现DLX"><a href="#舞蹈链实现DLX" class="headerlink" title="舞蹈链实现DLX"></a>舞蹈链实现DLX</h3><p>首先是舞蹈链的结点DLXNode，我设计了主要的左、右、上、下、列头这5个指针。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 舞蹈链的结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DLXNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, row=-<span class="number">1</span>, col=-<span class="number">1</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.left = <span class="variable language_">self</span></span><br><span class="line">        <span class="variable language_">self</span>.right = <span class="variable language_">self</span></span><br><span class="line">        <span class="variable language_">self</span>.up = <span class="variable language_">self</span></span><br><span class="line">        <span class="variable language_">self</span>.down = <span class="variable language_">self</span></span><br><span class="line">        <span class="variable language_">self</span>.colHead = <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用于列头，记录结点数</span></span><br><span class="line">        <span class="variable language_">self</span>.count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 单纯的标记，方便调试</span></span><br><span class="line">        <span class="variable language_">self</span>.colId = col</span><br><span class="line">        <span class="variable language_">self</span>.rowId = row</span><br></pre></td></tr></table></figure>
<p>接着我开始实现DLX，DLX的数据初始时主要为一个head头节点以及一个col的数组，col数组用来存储链表头，在初始化的时候我们需要将整个head和col数组进行初始化，需要理清他们之间的指针连接，初始化输入是一个colnum，表示链表头的个数，即列的个数，可以参考下面的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DLX</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, colnum</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;舞蹈链初始化</span></span><br><span class="line"><span class="string">        args:</span></span><br><span class="line"><span class="string">            colnum:链表头个数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># self.count = 0</span></span><br><span class="line">        <span class="comment"># 行数</span></span><br><span class="line">        <span class="variable language_">self</span>.rownum = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 记录行字典</span></span><br><span class="line">        <span class="variable language_">self</span>.rowdict = &#123;&#125;</span><br><span class="line">        <span class="variable language_">self</span>.ans = []</span><br><span class="line">        <span class="variable language_">self</span>.head = DLXNode()</span><br><span class="line">        <span class="variable language_">self</span>.col = [DLXNode(-<span class="number">1</span>, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(colnum)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将链表头和head连接起来</span></span><br><span class="line">        <span class="variable language_">self</span>.head.left = <span class="variable language_">self</span>.col[-<span class="number">1</span>]</span><br><span class="line">        <span class="variable language_">self</span>.head.right = <span class="variable language_">self</span>.col[<span class="number">0</span>]</span><br><span class="line">        <span class="variable language_">self</span>.col[<span class="number">0</span>].left = <span class="variable language_">self</span>.head</span><br><span class="line">        <span class="variable language_">self</span>.col[<span class="number">0</span>].right = <span class="variable language_">self</span>.col[<span class="number">1</span>]</span><br><span class="line">        <span class="variable language_">self</span>.col[-<span class="number">1</span>].left = <span class="variable language_">self</span>.col[-<span class="number">2</span>]</span><br><span class="line">        <span class="variable language_">self</span>.col[-<span class="number">1</span>].right = <span class="variable language_">self</span>.head</span><br><span class="line">        <span class="comment"># 将链表头之间连接起来</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, colnum-<span class="number">1</span>):</span><br><span class="line">            <span class="variable language_">self</span>.col[i].left = <span class="variable language_">self</span>.col[i-<span class="number">1</span>]</span><br><span class="line">            <span class="variable language_">self</span>.col[i].right = <span class="variable language_">self</span>.col[i+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>DLX进行初始化之后，我们需要进行数据的插入，在这里采取的是一行一行的插入，即先插入第一行再插入第二行，所以插入的数据结点其实都是这一列最后一个结点，根据这一特点，我们进行结点上、下、左、右四个方向指针的设置，这个函数的输入是一个数组，其中元素是插入的列头id。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pushRow</span>(<span class="params">self, colList</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;插入一行数据，按照一行一行，递增的插入</span></span><br><span class="line"><span class="string">    args:</span></span><br><span class="line"><span class="string">        colList:数组，里面存着列头的id</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(colList,self.rownum)</span></span><br><span class="line">    <span class="variable language_">self</span>.rowdict[<span class="variable language_">self</span>.rownum] = colList</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对于结点，列方向上，上下指针的变动</span></span><br><span class="line">    <span class="keyword">for</span> cowId <span class="keyword">in</span> colList:</span><br><span class="line">        <span class="comment"># 每个插入的结点，都为该列最后一个结点</span></span><br><span class="line">        node = DLXNode(<span class="variable language_">self</span>.rownum, cowId)</span><br><span class="line">        node.down = <span class="variable language_">self</span>.col[cowId]</span><br><span class="line">        node.up = <span class="variable language_">self</span>.col[cowId].up</span><br><span class="line">        node.colHead = <span class="variable language_">self</span>.col[cowId]</span><br><span class="line">        <span class="variable language_">self</span>.col[cowId].up.down = node</span><br><span class="line">        <span class="variable language_">self</span>.col[cowId].up = node</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.col[cowId].count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对于结点，行方向的两个指针的变动</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(colList)):</span><br><span class="line">        <span class="variable language_">self</span>.col[colList[i]].up.left = <span class="variable language_">self</span>.col[colList[i-<span class="number">1</span>]].up</span><br><span class="line">        <span class="variable language_">self</span>.col[colList[i]].up.right = <span class="variable language_">self</span>.col[colList[(i+<span class="number">1</span>) % <span class="built_in">len</span>(colList)]].up</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.rownum += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>有了上面的两个函数，我们就可以创建一个DLX的数据结构了，下面就需要来进行对应结点的“跳舞”，也就是结点的删除和恢复。先介绍结点的删除，删除我采用的是给定一个列的列头，遍历列的结点进行对应的删除。需要注意的是我们删除采取的方式是改变结点<code>a</code>指向的结点的指针指向，但是不改变结点  的指向，这就为后续恢复结点的恢复埋下伏笔，删除函数的输入是需要删除列的列头结点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, c: DLXNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;以列为单位进行删除</span></span><br><span class="line"><span class="string">    args:</span></span><br><span class="line"><span class="string">        c:列头</span></span><br><span class="line"><span class="string">    return:</span></span><br><span class="line"><span class="string">        删除是否成功的结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># print(c.colId,&#x27;列被删除&#x27;)</span></span><br><span class="line">    <span class="comment"># 将列头从链表头中删除，只改变了c结点left、right的指向，并未改变c的指向，为恢复做准备</span></span><br><span class="line">    c.left.right = c.right</span><br><span class="line">    c.right.left = c.left</span><br><span class="line">    <span class="keyword">if</span> c.down == c:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    i = c.down</span><br><span class="line">    <span class="keyword">while</span> i != c:</span><br><span class="line">        <span class="comment">#遍历这一列，i为这一列中的结点</span></span><br><span class="line">        <span class="comment">#注意，遍历了这一列，但是并没有改变这一列结点之间的关系，为后面的恢复埋下了种子</span></span><br><span class="line">        j = i.right</span><br><span class="line">        <span class="keyword">while</span> j != i:</span><br><span class="line">            <span class="comment"># 遍历i结点这一行，将这一行的结点进行删除</span></span><br><span class="line">            <span class="comment"># 注意只是改变了j结点up、down的指向，并没有改变j的指向，为后面j的恢复做准备</span></span><br><span class="line">            j.up.down = j.down</span><br><span class="line">            j.down.up = j.up</span><br><span class="line">            j.colHead.count -= <span class="number">1</span></span><br><span class="line">            j = j.right</span><br><span class="line">        i = i.down</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>结点的恢复和结点的删除刚好相反，将对应的结点添加进原始的位置，因为之前没有改变结点的指向，所以只需要根据结点自身就能进行恢复，恢复函数输入是恢复列的列头结点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recover</span>(<span class="params">self, c: DLXNode</span>):        </span><br><span class="line">    <span class="string">&quot;&quot;&quot;以列为单位进行恢复</span></span><br><span class="line"><span class="string">    args:</span></span><br><span class="line"><span class="string">        c:列头</span></span><br><span class="line"><span class="string">    return:</span></span><br><span class="line"><span class="string">        恢复是否成功的结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># print(c.colId,&#x27;列被恢复&#x27;)</span></span><br><span class="line">    i = c.down</span><br><span class="line">    <span class="keyword">while</span> i != c:</span><br><span class="line">        <span class="comment">#遍历这一列，i为这一列结点</span></span><br><span class="line">        j = i.right</span><br><span class="line">        <span class="keyword">while</span> j != i:</span><br><span class="line">            <span class="comment"># 遍历i结点这一行，根据j结点的指向进行恢复</span></span><br><span class="line">            j.up.down = j</span><br><span class="line">            j.down.up = j</span><br><span class="line">            j.colHead.count += <span class="number">1</span></span><br><span class="line">            j = j.right</span><br><span class="line">        i = i.down</span><br><span class="line">    <span class="comment"># 根据c结点的指向，将c加入到链表头当中</span></span><br><span class="line">    c.left.right = c</span><br><span class="line">    c.right.left = c</span><br></pre></td></tr></table></figure>
<p>接着介绍一下“跳舞”需要使用的功能寻找最少结点的列的功能，因为每个列头都记录了该列的结点数量所以只需要简单的遍历这一列就可以实现这个功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 寻找count最小的</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FindMinCount</span>(<span class="params">self</span>):</span><br><span class="line">    c = <span class="variable language_">self</span>.head.right</span><br><span class="line">    minnode = c</span><br><span class="line">    <span class="keyword">while</span> c != <span class="variable language_">self</span>.head:</span><br><span class="line">        <span class="keyword">if</span> c.count &lt; minnode.count:</span><br><span class="line">            minnode = c</span><br><span class="line">        c = c.right</span><br><span class="line">    <span class="keyword">return</span> minnode</span><br></pre></td></tr></table></figure>
<p>有了上面的内容我们可以进行最终的“跳舞”了。过程可以简述为先选取结点数最少的列，然后将这一列的结点进行删除，然后选择其中一行作为解，然后把这一行对应的结点的列进行删除，然后进行递归最终得到解。具体的逻辑过程我们可以参考2.2节中舞蹈链的介绍。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Dance</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 寻找结点数最少的列</span></span><br><span class="line">    c = <span class="variable language_">self</span>.FindMinCount()</span><br><span class="line">    <span class="keyword">if</span> c == <span class="variable language_">self</span>.head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 删除结点数最少的列c</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.remove(c):</span><br><span class="line">        <span class="comment"># print(&#x27;删除失败&#x27;)</span></span><br><span class="line">        <span class="variable language_">self</span>.recover(c)</span><br><span class="line">        <span class="comment"># self.count-=1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    i = c.down</span><br><span class="line">    <span class="keyword">while</span> i != c:</span><br><span class="line">        <span class="comment"># 选择第i行为答案，需要将第i行上结点的列进行删除</span></span><br><span class="line">        <span class="comment"># print((i.rowId,i.colId),self.count)</span></span><br><span class="line">        j = i.right</span><br><span class="line">        <span class="keyword">while</span> j != i:</span><br><span class="line">            <span class="variable language_">self</span>.remove(j.colHead)</span><br><span class="line">            j = j.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.Dance():</span><br><span class="line">            <span class="comment"># print(&quot;跳舞成功&quot;)</span></span><br><span class="line">            <span class="variable language_">self</span>.ans.append(<span class="variable language_">self</span>.rowdict[i.rowId])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行回溯</span></span><br><span class="line">        j = i.right</span><br><span class="line">        <span class="keyword">while</span> j != i:</span><br><span class="line">            <span class="variable language_">self</span>.recover(j.colHead)</span><br><span class="line">            j = j.right</span><br><span class="line">        i = i.down</span><br><span class="line"></span><br><span class="line">    <span class="comment"># self.count-=1</span></span><br><span class="line">    <span class="comment"># 恢复被删除的列c</span></span><br><span class="line">    <span class="variable language_">self</span>.recover(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="数独的DLX"><a href="#数独的DLX" class="headerlink" title="数独的DLX"></a>数独的DLX</h3><p>介绍完舞蹈链的实习之后，这一小节介绍一下如何将数独问题转化为精确覆盖问题，然后使用舞蹈链进行求解。数独规则一共有四点：</p>
<ul>
<li>每个单元格需要填写一个数字</li>
<li>每行数字不能相同</li>
<li>每列数字不能相同</li>
<li>每格宫数字不能相同</li>
</ul>
<p>我们可以把矩阵每一列都定义为一个约束，在单元格内填写数字就是加一行，然后对应的列为1，最终需要找到对应的行来覆盖这个矩阵。</p>
<p>针对第一条规则，我们可以使用$1-81$列进行约束，那个单元格填写了数字，那一列就会有一个结点1，假如说那个单元格没有填数字，那么第  列中某列就不会被覆盖。</p>
<p>针对第二条规则，我们使用$82-162$列进行约束，第82列定义成：在第1行填了数字1；……；第90列定义成：在第1行填了数字9；……；第162列定义成：在第9行填了数字9。如果第一行填写了两次1，那么矩阵中列1就会有两行，再消除的时候这两个结点会被同时消除，就会导致无法完全覆盖。</p>
<p>针对第三条规则，我们使用$163-243$列进行约束，第163列定义成：在第1列填了数字1；……；第171列定义成：在第1列填了数字9；……；第243列定义成：在第9列填了数字9。</p>
<p>针对第四条规则，我们使用$82-162$列进行约束，第244列定义成：在第1宫填了数字1；……；第252列定义成：在第1宫填了数字9；……；第324列定义成：在第9宫填了数字9。</p>
<p>基于上述规则，就可以把数独转化为一个精确覆盖问题的矩阵，在数独转化的时候数独有两种情况，填写了数字的单元格和没有填写数字的单元格，针对这两中情况需要分别进行处理。</p>
<p>有数字的单元格，我们使用$N_1,N_2,N_3,N_4$对应着规则中的列，设数字在  行  列数值为  。对应的公式如下：</p>
<script type="math/tex; mode=display">
N_1=x*9+y</script><script type="math/tex; mode=display">
N_2=x*9+z+81</script><script type="math/tex; mode=display">
N_3=y*9+z+162</script><script type="math/tex; mode=display">
N_4=[x/3]*3+[y/3]*9+243</script><p>其中$[]$代表取整。</p>
<p>对于没有数字的单元格，因为我们是进行求解，所以这个格子可能会填入$1-9$中任意一个数字，所以我们把这9个填写产生的行都插入到矩阵中，最终的解肯定是这9行之一。</p>
<p>代码的实现上，创建了一个sudoku类继承DLX，sudoku的初始化，函数的输入数独的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sudoku</span>(<span class="title class_ inherited__">DLX</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, maze</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        args:</span></span><br><span class="line"><span class="string">            maze:大小9*9，内容为每个单元格填写的数字</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="number">9</span>*<span class="number">9</span>*<span class="number">4</span>)</span><br><span class="line">        <span class="comment"># 切断关系采取深复制</span></span><br><span class="line">        <span class="variable language_">self</span>.maze = copy.deepcopy(maze)</span><br></pre></td></tr></table></figure>
<p>将数独转化为精确覆盖的矩阵代码实现起来不难，遍历数独数组，再按照上面介绍的进行转化就行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pushToDLX</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            z = <span class="built_in">int</span>(<span class="variable language_">self</span>.maze[x][y])</span><br><span class="line">            colList = []</span><br><span class="line">            <span class="keyword">if</span> z != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 单元格有数字</span></span><br><span class="line">                N1 = x*<span class="number">9</span>+y</span><br><span class="line">                N2 = x*<span class="number">9</span>+z+<span class="number">80</span></span><br><span class="line">                N3 = y*<span class="number">9</span>+z+<span class="number">161</span></span><br><span class="line">                N4 = ((x//<span class="number">3</span>)*<span class="number">3</span>+(y//<span class="number">3</span>))*<span class="number">9</span>+z+<span class="number">242</span></span><br><span class="line">                colList.append(N1)</span><br><span class="line">                colList.append(N2)</span><br><span class="line">                colList.append(N3)</span><br><span class="line">                colList.append(N4)</span><br><span class="line">                <span class="variable language_">self</span>.pushRow(colList)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 单元格没有数字，将9种可能性都插入</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">                    colList = []</span><br><span class="line">                    z = i</span><br><span class="line">                    N1 = x*<span class="number">9</span>+y</span><br><span class="line">                    N2 = x*<span class="number">9</span>+z+<span class="number">80</span></span><br><span class="line">                    N3 = y*<span class="number">9</span>+z+<span class="number">161</span></span><br><span class="line">                    N4 = ((x//<span class="number">3</span>)*<span class="number">3</span>+(y//<span class="number">3</span>))*<span class="number">9</span>+z+<span class="number">242</span></span><br><span class="line">                    colList.append(N1)</span><br><span class="line">                    colList.append(N2)</span><br><span class="line">                    colList.append(N3)</span><br><span class="line">                    colList.append(N4)</span><br><span class="line">                    <span class="variable language_">self</span>.pushRow(colList)</span><br></pre></td></tr></table></figure>
<p>最后还有一个函数就是将精确覆盖的解转化为数独数组里面的值，因为解里面存的是二维数组，一行种存的是四个列的值，可以通过一下公式进行求解。</p>
<script type="math/tex; mode=display">
x=[N_1/9]</script><script type="math/tex; mode=display">
y=N1\%9</script><script type="math/tex; mode=display">
z=[N_2-81]\%9</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ans2Maze</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="variable language_">self</span>.ans:</span><br><span class="line">        x = col[<span class="number">0</span>]//<span class="number">9</span></span><br><span class="line">        y = col[<span class="number">0</span>] % <span class="number">9</span></span><br><span class="line">        z = (col[<span class="number">1</span>]-<span class="number">80</span>) % <span class="number">9</span></span><br><span class="line">        <span class="keyword">if</span> z == <span class="number">0</span>:</span><br><span class="line">            z = <span class="number">9</span></span><br><span class="line">        <span class="variable language_">self</span>.maze[x][y] = z</span><br></pre></td></tr></table></figure>
<h3 id="sudokuore介绍"><a href="#sudokuore介绍" class="headerlink" title="sudokuore介绍"></a>sudokuore介绍</h3><p>sudokuore是一个类用于管理数独游戏，比如什么提示、开始游戏、重新开始游戏等功能，在这里只介绍一下数组游戏中的生成数组。数组生成也有一系列的方法，比如自己随机生成一些数字填一下然后判断数字能否有解之类的，但是这种方法生成时间太长，所以我这里采取的是选一个已经生成的初盘数独，将其中数字进行变换，比如我们把初盘中“1”和“2”进行替换，那么这个数组还是一样的有解，实现了一个看起来和之前相比就是变化的，如图展示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712162558036.png" alt="image-20220712162558036"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sudokucore</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.Iscanchangmaze = [[<span class="literal">True</span>]*<span class="number">9</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        <span class="variable language_">self</span>.randomList = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">        <span class="comment"># levelfile 保存着初盘数组</span></span><br><span class="line">        <span class="variable language_">self</span>.LevelFile = <span class="string">&#x27;困难.txt&#x27;</span></span><br><span class="line">        <span class="variable language_">self</span>.initMaze()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.Leveldict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="variable language_">self</span>.Leveldict[<span class="number">1</span>] = <span class="string">&#x27;简单.txt&#x27;</span></span><br><span class="line">        <span class="variable language_">self</span>.Leveldict[<span class="number">2</span>] = <span class="string">&#x27;普通.txt&#x27;</span></span><br><span class="line">        <span class="variable language_">self</span>.Leveldict[<span class="number">3</span>] = <span class="string">&#x27;困难.txt&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.Iscanchangmaze)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initMaze</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.maze = []</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="variable language_">self</span>.LevelFile, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">                <span class="variable language_">self</span>.maze.append(line.strip().split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        <span class="comment"># 进行洗牌</span></span><br><span class="line">        random.shuffle(<span class="variable language_">self</span>.randomList)</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.randomList)</span><br><span class="line">        <span class="variable language_">self</span>.colDict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="variable language_">self</span>.colDict[<span class="variable language_">self</span>.randomList[i]] = i</span><br><span class="line">        <span class="comment"># 进行变换</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.colDict)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                z = <span class="built_in">int</span>(<span class="variable language_">self</span>.maze[i][j])</span><br><span class="line">                <span class="keyword">if</span> z != <span class="number">0</span>:</span><br><span class="line">                    index = <span class="variable language_">self</span>.colDict[z]</span><br><span class="line">                    <span class="comment"># 对应的数字进行变换</span></span><br><span class="line">                    <span class="variable language_">self</span>.maze[i][j] = <span class="variable language_">self</span>.randomList[(index+<span class="number">1</span>) % <span class="number">9</span>]</span><br><span class="line">                    <span class="variable language_">self</span>.Iscanchangmaze[i][j] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="运行结果展示"><a href="#运行结果展示" class="headerlink" title="运行结果展示"></a>运行结果展示</h2><p>界面运行和各个部分的功能展示，如图5所展示</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712162658587.png" alt="图5"></p>
<p>全部填写完成后结果展示如图6所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/数据结构/image-20220712162721385.png" alt="图6"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的数独小游戏，让我学习到了如何完成一个完整的小工程，也学习了舞蹈链的编写和实现，这个项目还有许多值得改进的地方，希望后续有时间再进行改进吧。</p>
<p>仓库地址：<a href="https://github.com/bugcat9/sudoku">https://github.com/bugcat9/sudoku</a></p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://zh.m.wikipedia.org/zh-hans/X%E7%AE%97%E6%B3%95">https://zh.m.wikipedia.org/zh-hans/X%E7%AE%97%E6%B3%95</a></li>
<li><a href="https://zh.m.wikipedia.org/zh-hans/%E7%B2%BE%E7%A1%AE%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98">https://zh.m.wikipedia.org/zh-hans/%E7%B2%BE%E7%A1%AE%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98</a></li>
<li><a href="https://zh.m.wikipedia.org/zh-hans/%E8%88%9E%E8%B9%88%E9%93%BE">https://zh.m.wikipedia.org/zh-hans/%E8%88%9E%E8%B9%88%E9%93%BE</a></li>
<li><a href="http://www.mamicode.com/info-detail-2274481.html">http://www.mamicode.com/info-detail-2274481.html</a></li>
<li><a href="https://www.cnblogs.com/grenet/p/3145800.html">https://www.cnblogs.com/grenet/p/3145800.html</a></li>
<li><a href="https://www.cnblogs.com/grenet/p/3145800.html">https://www.cnblogs.com/grenet/p/3145800.html</a></li>
<li><a href="https://www.cnblogs.com/grenet/p/7903680.html">https://www.cnblogs.com/grenet/p/7903680.html</a></li>
<li><a href="https://www.cnblogs.com/wujiechao/p/5767124.html">https://www.cnblogs.com/wujiechao/p/5767124.html</a></li>
<li><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/79220897">https://blog.csdn.net/WhereIsHeroFrom/article/details/79220897</a></li>
<li><a href="https://blog.csdn.net/qq_26822029/article/details/81129701">https://blog.csdn.net/qq_26822029/article/details/81129701</a></li>
<li><a href="https://blog.csdn.net/peng_wu01/article/details/6026103">https://blog.csdn.net/peng_wu01/article/details/6026103</a></li>
<li><a href="https://blog.csdn.net/zj0395/article/details/72773001">https://blog.csdn.net/zj0395/article/details/72773001</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>舞蹈链</tag>
        <tag>数独</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中socket地址API</title>
    <url>/2022/08/11/Linux/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E4%B8%ADsocket%E5%9C%B0%E5%9D%80API/</url>
    <content><![CDATA[<h1 id="Linux中socket地址API"><a href="#Linux中socket地址API" class="headerlink" title="Linux中socket地址API"></a>Linux中socket地址API</h1><p>学习《Linux高性能服务器编程》第五章Linux网络编程基础API，为了印象深刻一些，多动手多实践，所以记下这个笔记。这一篇主要记录Linux中socket地址的基础，包括主机字节序和网络字节序、socket地址和IP地址转化函数。</p>
<span id="more"></span>
<h2 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h2><p>计算机硬件有两种储存数据的方式：<strong>大端字节序（big endian）</strong>和<strong>小端字节序（little endian）</strong>。</p>
<ul>
<li><strong>大端字节序</strong>：高位字节在前，低位字节在后，符合人类读写数值的方法。</li>
<li><strong>小端字节序</strong>：低位字节在前，高位字节在后</li>
</ul>
<p>想要判别机器的字节序可以使用如下的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">byteorder</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="type">short</span> value;</span><br><span class="line">		<span class="type">char</span> union_bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">	&#125; test;</span><br><span class="line">	test.value = <span class="number">0x0102</span>;</span><br><span class="line">	<span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;big endian\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;little endian\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unknown...\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	byteorder();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220809181538872.png" alt="image-20220809181538872"></p>
<p>这段代码使用的原理是<strong>union变量所占用的内存长度等于最长的成员的内存长度。</strong></p>
<p>所以<code>test</code>中<code>value</code>和<code>union_bytes</code>是共用一段内存的。因为在c中<code>short</code>是16位也就是2字节，<code>char</code>是8位也就是1字节，所以<code>union_bytes</code>数组的大小是2。</p>
<p>我们给<code>value</code>赋值为<code>0x0102</code>。如果是机器是大端存储，那么<code>union_bytes</code>数组第一个元素存储<code>0x01</code>，第二个元素存储<code>0x02</code>，如果是机器是小端存储，那么<code>union_bytes</code>数组第一个元素存储<code>0x02</code>，第二个元素存储<code>0x01</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/Snipaste_2023-03-29_19-41-48.png" alt="image-20220809185922374"></p>
<p>扩展到32位，四字节来说以<code>0x12345678</code>为例，那么</p>
<p><strong>大端字节序</strong>：0x12345678</p>
<p><strong>小端字节序</strong>：0x78563412</p>
<p>总结来说就是大端字节序和小端字节序的区别就是以<strong>字节</strong>为单位的存储方式不同。</p>
<p>在网络中两台使用不同字节序的主机之间直接传递时，接收端必然会造成错误。书中说解决的方法是发送端总是把要发送的数据转化成大端字节序数据再发送，接受端知道传送过来的数据总是采用大端字节序，所以接收端根据自身采用的字节序再对数据进行一定的处理（小端进行转换，大端就不转换）。</p>
<p>Linux提供了4个函数来完成主机字节序和网络字节序之间的转换:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220810153657086.png" alt="image-20220810153657086"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span> <span class="params">(<span class="type">uint32_t</span> __netlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span> <span class="params">(<span class="type">uint16_t</span> __netshort)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span> <span class="params">(<span class="type">uint32_t</span> __hostlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span> <span class="params">(<span class="type">uint16_t</span> __hostshort)</span>;</span><br></pre></td></tr></table></figure>
<p>它们的含义是就是首字母缩写（这谁看的出来），比如”htonl”表示“host to network long”，即将长整型（32bit）的主机字节序数据转化为网络字节序数据。这四个函数中，长整型<code>uint32_t</code>函数通常用来转换IP地址，短整型<code>uint16_t</code>函数用来转化端口号。</p>
<p>简单示例展示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="number">258</span>;</span><br><span class="line">    <span class="type">uint16_t</span> p = htons(port);</span><br><span class="line">    port = ntohs(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;htons :%u \n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ntohs :%u \n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220810181643405.png" alt="image-20220810181643405"></p>
<p><code>513</code>二进制：<code>0000 0010 0000 0001</code></p>
<p><code>258</code>二进制：<code>0000 0001 0000 0010</code></p>
<p>可以看出两者字节序是不同的</p>
<h2 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h2><h3 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h3><h4 id="sockaddr"><a href="#sockaddr" class="headerlink" title="sockaddr"></a>sockaddr</h4><p>socket网络接口中表示socket地址的是结构体<code>sockaddr</code>，他的定义在头<code>&lt;bits/socket.h&gt;</code>中，我看在我的电脑上看到的是如下的定义（各个版本不同，可能实现不同，我这里和书上就不大相同）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220810185029006.png" alt="image-20220810185029006"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Structure describing a generic socket address.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sa_);	<span class="comment">/* Common data: address family and length.  */</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];		<span class="comment">/* Address data.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>__SOCKADDR_COMMON</code>定义在<code>&lt;bits/sockaddr.h&gt;</code>中</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220810185204703.png" alt="image-20220810185204703"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/sockaddr.h&gt;</span></span></span><br><span class="line"><span class="comment">/* POSIX.1g specifies this type name for the `sa_family&#x27; member.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This macro is used to declare the initial common members</span></span><br><span class="line"><span class="comment">   of the data types used for socket addresses, `struct sockaddr&#x27;,</span></span><br><span class="line"><span class="comment">   `struct sockaddr_in&#x27;, `struct sockaddr_un&#x27;, etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	__SOCKADDR_COMMON(sa_prefix) sa_family_t sa_prefix##family</span></span><br></pre></td></tr></table></figure>
<p><code>__SOCKADDR_COMMON</code>是定义的一个函数，它返回一个<code>sa_family_t</code>类型的数据，数据的名字是<code>sa_prefixfamily</code>，其中<code>sa_prefix</code>是你传进去的值。比如：<code>__SOCKADDR_COMMON (sa_)</code>其实就是返回<code>sa_family_t sa_family</code>。</p>
<p>所以<code>sockaddr</code>其实就是两个成员，一个是<code>sa_family_t</code>（地址族）类型的变量<code>sa_family</code>，一个<code>char</code>数组类型的变量<code>sa_data</code></p>
<p><code>sa_family_t</code>常见的协议族（protocol family，也称domain）和对应的地址族如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">协议族</th>
<th style="text-align:center">地址族</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF_UNIX</td>
<td style="text-align:center">AF_UNIX</td>
<td style="text-align:center">UNIX本地协议族</td>
</tr>
<tr>
<td style="text-align:center">PF_INET</td>
<td style="text-align:center">AF_INET</td>
<td style="text-align:center">IPv4协议族</td>
</tr>
<tr>
<td style="text-align:center">PF_INET6</td>
<td style="text-align:center">AF_INET6</td>
<td style="text-align:center">IPv6协议族</td>
</tr>
</tbody>
</table>
</div>
<p>宏PF_*和AF_*都定义在<code>&lt;bits/socket.h&gt;</code>当中，两者的值相同，所以两者可以混用</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811094342093.png" alt="image-20220811094342093"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811094510529.png" alt="image-20220811094510529"></p>
<p><code>sa_data</code>成员用于存放socket地址值。不同的协议族的地址值有不同的含义和长度。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">协议族</th>
<th style="text-align:center">地址值含义和长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF_UNIX</td>
<td style="text-align:center">文件的路径名，长度可达108字节</td>
</tr>
<tr>
<td style="text-align:center">PF_INET</td>
<td style="text-align:center">16bit端口号和32bit IPv4地址，共6字节</td>
</tr>
<tr>
<td style="text-align:center">PF_INET6</td>
<td style="text-align:center">16bit端口号，32bit流标识，128bit IPv6地址，32bit范围ID，共26字节</td>
</tr>
</tbody>
</table>
</div>
<h4 id="sockaddr-storage"><a href="#sockaddr-storage" class="headerlink" title="sockaddr_storage"></a>sockaddr_storage</h4><p>可以看出14字节的<code>sa_data</code>根本无法容纳多数协议族的地址值。所以，Linux中定义了新的通用socket地址结构体（其实就是把存放地址的数组加大了）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Structure large enough to hold any socket address (with the historical</span></span><br><span class="line"><span class="comment">   exception of AF_UNIX).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ss_aligntype	unsigned long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SS_PADSIZE \</span></span><br><span class="line"><span class="meta">  (_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (ss_);	<span class="comment">/* Address family, etc.  */</span></span><br><span class="line">    <span class="type">char</span> __ss_padding[_SS_PADSIZE];</span><br><span class="line">    __ss_aligntype __ss_align;	<span class="comment">/* Force desired alignment.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>_SS_SIZE</code>、<code>__SOCKADDR_COMMON_SIZE</code>在<code>&lt;bits/sockaddr.h&gt;</code>当中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/sockaddr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE	(sizeof (unsigned short int))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of struct sockaddr_storage.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SS_SIZE 128</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811135111456.png" alt="image-20220811135111456"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811135134566.png" alt="image-20220811135134566"></p>
<p>这个结构体提供了足够大的空间用于存放地址值，并且是内存对齐的。</p>
<p><code>ss_</code>（其实是<code>ss_family</code>）是<code>sa_family_t</code>类型（介绍<code>sockaddr</code>有提到），即<code>unsigned short int</code>类型，2字节。</p>
<p><code>__ss_align</code>是<code>__ss_aligntype</code>类型，即<code>unsigned long int</code>类型，4字节</p>
<p><code>__ss_padding</code>是<code>char</code>类型数组，大小为<code>_SS_PADSIZE</code>，而<code>_SS_PADSIZE=_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype)=128-2-4=122</code>字节，完全足够保存地址值。</p>
<p>综上<code>sockaddr_storage</code>是128字节大小，保证了内存对齐。</p>
<h3 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h3><p>上面两种通用的socket地址使用起来显然不够方便，因为将IP地址和端口等信息直接放在同一个<code>char</code>数组中，那要得到IP地址和端口信息都得费好大劲进行操作。因此，Linux为各个协议族提供了专门的socket地址结构体。</p>
<p>UNIX本地协议族使用<code>sockaddr_un</code>，数据结构很简单，只有一个保存地址族类型的<code>sun_</code>（其实是<code>sun_family</code>）和保存文件位置的<code>sun_path</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Structure describing the address of an AF_LOCAL (aka AF_UNIX) socket.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sun_);</span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];		<span class="comment">/* Path name.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>IPv4协议族使用<code>sockaddr_in</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Structure describing an Internet socket address.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin_);</span><br><span class="line">    <span class="type">in_port_t</span> sin_port;			<span class="comment">/* Port number.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>		<span class="comment">/* Internet address.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr&#x27;.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr)</span><br><span class="line">			   - __SOCKADDR_COMMON_SIZE</span><br><span class="line">			   - <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>)</span><br><span class="line">			   - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>in_port_t</code>定义、<code>in_addr_t</code>结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Type to represent a port.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811143542024.png" alt="image-20220811143542024"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811143600470.png" alt="image-20220811143600470"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811143622907.png" alt="image-20220811143622907"></p>
<p>可以看的出来<code>sin_</code>（其实是<code>sin_family</code>）存放地址族类型，<code>sin_port</code>存放端口，<code>sin_addr</code>存放地址。<code>sin_zero</code>为了让<code>sockaddr_in</code>大小和<code>sockaddr</code>相同，为什么有这个成员，个人感觉这是因为所以<strong>专用socket</strong>在实际使用中都需要转化为<strong>通用socket地址类型</strong><code>socketaddr</code>，因为socket编程接口使用的是参数类型是<code>socketaddr</code>。</p>
<p>IPv6协议族使用<code>sockaddr_in6</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Ditto, for IPv6.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin6_);</span><br><span class="line">    <span class="type">in_port_t</span> sin6_port;	<span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_flowinfo;	<span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>	<span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_scope_id;	<span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>in6_addr</code>如下，因为IPv6不是学习重点，这里就不过多展开介绍。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* IPv6 address */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span>	__u6_addr8[<span class="number">16</span>];</span><br><span class="line">	<span class="type">uint16_t</span> __u6_addr16[<span class="number">8</span>];</span><br><span class="line">	<span class="type">uint32_t</span> __u6_addr32[<span class="number">4</span>];</span><br><span class="line">      &#125; __in6_u;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s6_addr			__in6_u.__u6_addr8</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_MISC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> s6_addr16		__in6_u.__u6_addr16</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> s6_addr32		__in6_u.__u6_addr32</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>除此之外需要注意：所有<strong>专用socket地址</strong>（以及<code>sockaddr_storage</code>）类型的变量在实际使用时都需要转化为<strong>通用socket地址</strong>类型<code>sockaddr</code>（强制转换即可)，因为所有socket编程接口使用的地址参数的类型都是sockaddr。</p>
<h2 id="IP地址转化函数"><a href="#IP地址转化函数" class="headerlink" title="IP地址转化函数"></a>IP地址转化函数</h2><p>通常来说，人们更喜欢用点分十进制的字符串来表示IPv4地址，但是在编程的过程中，我们需要把这个字符串转化为整数才能使用，但是输出的时候我们又需要把整数转化成点分十进制的字符串，这样方便观察。所以系统提供了3个函数用于点分十进制的字符串IPv4地址和整数的IPv4地址之间的转化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert Internet host address from numbers-and-dots notation in CP</span></span><br><span class="line"><span class="comment">   into binary data in network byte order.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">in_addr_t</span> <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__cp)</span> __THROW;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert Internet host address from numbers-and-dots notation in CP</span></span><br><span class="line"><span class="comment">   into binary data and store the result in the structure INP.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">inet_aton</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__cp, <span class="keyword">struct</span> in_addr *__inp)</span> __THROW;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert Internet number in IN to ASCII representation.  The return value</span></span><br><span class="line"><span class="comment">   is a pointer to an internal array containing the string.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">inet_ntoa</span> <span class="params">(<span class="keyword">struct</span> in_addr __in)</span> __THROW;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>inet_addr</code>函数将用点分十进制字符串表示的IPv4地址转化为用网络字节序整数表示的IPv4地址。它失败时返回 <code>INADDR_NONE</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">in_addr_t</span> ip = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.167.14&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ip == INADDR_NONE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip convert by inet_addr %u \n&quot;</span>, ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811170759741.png" alt="image-20220811170759741"></p>
<p><code>inet_aton</code>功能和<code>inet_addr</code>相同，但是将结果存在在<code>in_addr_t</code>指向的地址结构当中，函数成功返回1，失败返回0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">inet_aton</span>(<span class="string">&quot;192.168.167.14&quot;</span>, &amp;ip);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip convert by inet_aton %u \n&quot;</span>, ip.s_addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811171444397.png" alt="image-20220811171444397"></p>
<p><code>inet_ntoa</code>函数将整数的IPv4地址转化为点分十进制字符串的IPv4。成功时返回转换的字符串地址值，失败时返回-1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">inet_aton</span>(<span class="string">&quot;192.168.167.14&quot;</span>, &amp;ip);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip convert by inet_aton %u \n&quot;</span>, ip.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ip_str = <span class="built_in">inet_ntoa</span>(ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address :%s \n&quot;</span>, ip_str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811173503409.png" alt="image-20220811173503409"></p>
<p>需要注意的是<code>inet_ntoa</code>函数内部使用一个静态变量存储转化的结果，函数的返回值指向该静态内存，因此<code>inet_ntoa</code>是不可重入的，这一点需要多注意。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">inet_aton</span>(<span class="string">&quot;192.168.167.14&quot;</span>, &amp;ip);</span><br><span class="line">    <span class="type">char</span> *ip_str1 = <span class="built_in">inet_ntoa</span>(ip);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inet_aton</span>(<span class="string">&quot;192.168.167.15&quot;</span>, &amp;ip);</span><br><span class="line">    <span class="type">char</span> *ip_str2 = <span class="built_in">inet_ntoa</span>(ip);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address :%s \n&quot;</span>, ip_str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address :%s \n&quot;</span>, ip_str2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811180430697.png" alt="image-20220811180430697"></p>
<p>除此之外，下面两个函数也能完成前三个函数的功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Convert from presentation format of an Internet number in buffer</span></span><br><span class="line"><span class="comment">   starting at CP to the binary network format and store result for</span></span><br><span class="line"><span class="comment">   interface type AF in buffer starting at BUF.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">inet_pton</span> <span class="params">(<span class="type">int</span> __af, <span class="type">const</span> <span class="type">char</span> *__restrict __cp,</span></span></span><br><span class="line"><span class="params"><span class="function">		      <span class="type">void</span> *__restrict __buf)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert a Internet address in binary network format for interface</span></span><br><span class="line"><span class="comment">   type AF in buffer starting at CP to presentation form and place</span></span><br><span class="line"><span class="comment">   result in buffer of length LEN astarting at BUF.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span> <span class="params">(<span class="type">int</span> __af, <span class="type">const</span> <span class="type">void</span> *__restrict __cp,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="type">char</span> *__restrict __buf, <span class="type">socklen_t</span> __len)</span></span></span><br><span class="line"><span class="function">     __THROW</span>;</span><br></pre></td></tr></table></figure>
<p><code>inet_pton</code>函数将用字符串表示的P地址<code>__cp</code>（用点分十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址）转换成用网络字节序整数表示的IP地址，并把转换结果存储于<code>__buf</code>指向的内存中。其中，<code>__af</code>参数指定地址族，可以是<code>AF_INET</code>或者<code>AF_INET6</code>。<code>inet_pton</code>成功时返回1，失败则返回0并设置<code>errno</code>。</p>
<p><code>__restrict</code>emmm目前找不到定义，但是看了下<code>restrict</code>关键字，是指告诉编译器传入的两个指针不指向同一数据，方便进行优化用来提升性能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ip_str[] = <span class="string">&quot;192.168.167.42&quot;</span>;</span><br><span class="line">    <span class="type">in_addr_t</span> ip;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">inet_pton</span>(AF_INET, ip_str, &amp;ip);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ip error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip convert by inet_pton %u \n&quot;</span>, ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> in_ip;</span><br><span class="line">    ret = <span class="built_in">inet_pton</span>(AF_INET, ip_str, &amp;in_ip);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ip error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip convert by inet_pton %u \n&quot;</span>, in_ip.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811183002035.png" alt="image-20220811183002035"></p>
<p><code>inet_ntop</code>函数进行相反的转换，前三个参数的含义与<code>inet_pton</code>的参数相同，最后一个参数 <code>__len</code>指定目标存储单元的大小。下面的两个宏能帮助我们指定这个大小(分别用于IPv4和IPv6):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure>
<p><code>inet_ntop</code>成功时返回目标存储单元的地址，失败则返回NULL并设置errno。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ip_str[] = <span class="string">&quot;192.168.167.42&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> in_ip;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">inet_pton</span>(AF_INET, ip_str, &amp;in_ip);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ip error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip convert by inet_pton %u \n&quot;</span>, in_ip.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ip_str2[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip_str3 = <span class="built_in">inet_ntop</span>(AF_INET, &amp;in_ip, ip_str2, <span class="built_in">sizeof</span>(ip_str2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ip_str3 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ip error \n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address :%s \n&quot;</span>, ip_str2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address :%s \n&quot;</span>, ip_str3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811220718920.png" alt="image-20220811220718920"></p>
<p>值得注意的是<code>ip_str2</code>和<code>ip_str3</code>的地址相同，也就是说传入参数和返回值相同，虽然不知道为啥这样设计。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811221357471.png" alt="image-20220811221357471"></p>
]]></content>
      <categories>
        <category>Linux网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
        <tag>计算机网络</tag>
        <tag>Linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>使用muduo编写webserver</title>
    <url>/2023/02/13/Linux/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAmuduo/%E4%BD%BF%E7%94%A8muduo%E7%BC%96%E5%86%99webserver/</url>
    <content><![CDATA[<h1 id="使用muduo编写webserver"><a href="#使用muduo编写webserver" class="headerlink" title="使用muduo编写webserver"></a>使用muduo编写webserver</h1><p>因为学习了muduo库，想通过muduo库写一个webserver作为项目，在muduo和tinyWebserver的基础上改了一下，简单的把他们融合了一下。</p>
<span id="more"></span>
<h2 id="httpserver"><a href="#httpserver" class="headerlink" title="httpserver"></a>httpserver</h2><p>在muduo原本的httpserver的基础上进行了改造，加入简单的数据库操作的部分。针对http请求处理的逻辑部分封装在了<code>onHttpProcess</code>中。</p>
<p>HttpServer.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HTTPSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HTTPSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../net/TcpServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../base/SqlConnectionPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tinyMuduo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> net</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">HttpRequest</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">HttpResponse</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// A simple embeddable HTTP server designed for report status of a program.</span></span><br><span class="line">        <span class="comment">/// It is not a fully HTTP 1.1 compliant server, but provides minimum features</span></span><br><span class="line">        <span class="comment">/// that can communicate with HttpClient and Web browser.</span></span><br><span class="line">        <span class="comment">/// It is synchronous, just like Java Servlet.</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">HttpServer</span> : boost::noncopyable</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">const</span> HttpRequest &amp;,</span><br><span class="line">                                       HttpResponse *)&gt;</span><br><span class="line">                HttpCallback;</span><br><span class="line">            <span class="built_in">HttpServer</span>(EventLoop *loop,</span><br><span class="line">                       <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                       <span class="type">const</span> string &amp;name,</span><br><span class="line">                       <span class="type">const</span> string &amp;user,</span><br><span class="line">                       <span class="type">const</span> string &amp;passwd,</span><br><span class="line">                       <span class="type">const</span> string &amp;databaseName,</span><br><span class="line">                       <span class="type">int</span> sqlNum,</span><br><span class="line">                       TcpServer::Option option = TcpServer::kNoReusePort);</span><br><span class="line"></span><br><span class="line">            <span class="function">EventLoop *<span class="title">getLoop</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> server_.<span class="built_in">getLoop</span>(); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Not thread safe, callback be registered before calling start().</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setHttpCallback</span><span class="params">(<span class="type">const</span> HttpCallback &amp;cb)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                httpCallback_ = cb;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                server_.<span class="built_in">setThreadNum</span>(numThreads);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Buffer *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Timestamp receiveTime)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">onRequest</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;, <span class="type">const</span> HttpRequest &amp;)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">onWriteComplete</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">initmysql</span><span class="params">(ConnectionPool *connPool)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">onHttpProcess</span><span class="params">(<span class="type">const</span> HttpRequest &amp;req, HttpResponse *resp)</span></span>;</span><br><span class="line">            TcpServer server_;</span><br><span class="line">            HttpCallback httpCallback_;</span><br><span class="line"></span><br><span class="line">            ConnectionPool *connPool_; <span class="comment">// 数据库相关</span></span><br><span class="line">            string user_;              <span class="comment">// 登陆数据库用户名</span></span><br><span class="line">            string passwd_;            <span class="comment">// 登陆数据库密码</span></span><br><span class="line">            string databaseName_;      <span class="comment">// 使用数据库名</span></span><br><span class="line">            <span class="type">int</span> sqlNum_;</span><br><span class="line">            map&lt;string, string&gt; users;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">// namespace net</span></span><br><span class="line">&#125; <span class="comment">// namespace tinyMuduo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _HTTPSERVER_H</span></span></span><br></pre></td></tr></table></figure>
<p>HttpServer.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../net/http/HttpServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../base/Logging.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../net/http/HttpContext.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../net/http/HttpRequest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../net/http/HttpResponse.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tinyMuduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tinyMuduo::net;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tinyMuduo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> net</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">namespace</span> detail</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">defaultHttpCallback</span><span class="params">(<span class="type">const</span> HttpRequest &amp;, HttpResponse *resp)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                resp-&gt;<span class="built_in">setStatusCode</span>(HttpResponse::k404NotFound);</span><br><span class="line">                resp-&gt;<span class="built_in">setStatusMessage</span>(<span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">                resp-&gt;<span class="built_in">setCloseConnection</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="comment">// namespace detail</span></span><br><span class="line">    &#125;     <span class="comment">// namespace net</span></span><br><span class="line">&#125; <span class="comment">// namespace tinyMuduo</span></span><br><span class="line"></span><br><span class="line">HttpServer::<span class="built_in">HttpServer</span>(EventLoop *loop,</span><br><span class="line">                       <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                       <span class="type">const</span> string &amp;name,</span><br><span class="line">                       <span class="type">const</span> string &amp;user,</span><br><span class="line">                       <span class="type">const</span> string &amp;passwd,</span><br><span class="line">                       <span class="type">const</span> string &amp;databaseName,</span><br><span class="line">                       <span class="type">int</span> sqlNum,</span><br><span class="line">                       TcpServer::Option option)</span><br><span class="line">    : <span class="built_in">server_</span>(loop, listenAddr, name, option), <span class="built_in">user_</span>(user), <span class="built_in">passwd_</span>(passwd), <span class="built_in">databaseName_</span>(databaseName), <span class="built_in">sqlNum_</span>(sqlNum)</span><br><span class="line">&#123;</span><br><span class="line">    server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;HttpServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">    server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;HttpServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">    server_.<span class="built_in">setWriteCompleteCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;HttpServer::onWriteComplete, <span class="keyword">this</span>, _1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setHttpCallback</span>(std::<span class="built_in">bind</span>(&amp;HttpServer::onHttpProcess, <span class="keyword">this</span>, _1, _2));</span><br><span class="line">    <span class="comment">// user_ = &quot;root&quot;;</span></span><br><span class="line">    <span class="comment">// passwd_ = &quot;123456&quot;;</span></span><br><span class="line">    <span class="comment">// databaseName_ = &quot;yourdb&quot;;</span></span><br><span class="line">    <span class="comment">// sqlNum_ = 8;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化数据库</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param connPool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::initmysql</span><span class="params">(ConnectionPool *connPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先从连接池中取一个连接</span></span><br><span class="line">    MYSQL *mysql = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">tinyMuduo::ConnectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;mysql, connPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在user表中检索username，passwd数据，浏览器端输入</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(mysql, <span class="string">&quot;SELECT username,passwd FROM user&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">&quot;SELECT error: &quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(mysql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从表中检索完整的结果集</span></span><br><span class="line">    MYSQL_RES *result = <span class="built_in">mysql_store_result</span>(mysql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果集中的列数</span></span><br><span class="line">    <span class="type">int</span> num_fields = <span class="built_in">mysql_num_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回所有字段结构的数组</span></span><br><span class="line">    MYSQL_FIELD *fields = <span class="built_in">mysql_fetch_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从结果集中获取下一行，将对应的用户名和密码，存入map中</span></span><br><span class="line">    <span class="keyword">while</span> (MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(result))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">string <span class="title">temp1</span><span class="params">(row[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="function">string <span class="title">temp2</span><span class="params">(row[<span class="number">1</span>])</span></span>;</span><br><span class="line">        users[temp1] = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">&quot;HttpServer[&quot;</span> &lt;&lt; server_.<span class="built_in">name</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;] starts listening on &quot;</span> &lt;&lt; server_.<span class="built_in">ipPort</span>();</span><br><span class="line">    server_.<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">// 初始化数据库连接池</span></span><br><span class="line">    connPool_ = ConnectionPool::<span class="built_in">getInstance</span>();</span><br><span class="line">    connPool_-&gt;<span class="built_in">init</span>(<span class="string">&quot;127.0.0.1&quot;</span>, user_, passwd_, databaseName_, <span class="number">3306</span>, sqlNum_);</span><br><span class="line">    <span class="built_in">initmysql</span>(connPool_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;<span class="built_in">connected</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        conn-&gt;<span class="built_in">setContext</span>(<span class="built_in">HttpContext</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Buffer *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HttpContext *context = boost::<span class="built_in">any_cast</span>&lt;HttpContext&gt;(conn-&gt;<span class="built_in">getMutableContext</span>());</span><br><span class="line">    <span class="comment">// LOG_INFO &lt;&lt; buf-&gt;toStringPiece();</span></span><br><span class="line">    <span class="keyword">if</span> (!context-&gt;<span class="built_in">parseRequest</span>(buf, receiveTime))</span><br><span class="line">    &#123;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(<span class="string">&quot;HTTP/1.1 400 Bad Request\r\n\r\n&quot;</span>);</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context-&gt;<span class="built_in">gotAll</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">onRequest</span>(conn, context-&gt;<span class="built_in">request</span>());</span><br><span class="line">        context-&gt;<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::onRequest</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, <span class="type">const</span> HttpRequest &amp;req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> string &amp;connection = req.<span class="built_in">getHeader</span>(<span class="string">&quot;Connection&quot;</span>);</span><br><span class="line">    <span class="type">bool</span> close = connection == <span class="string">&quot;close&quot;</span> ||</span><br><span class="line">                 (req.<span class="built_in">getVersion</span>() == HttpRequest::kHttp10 &amp;&amp; connection != <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">    <span class="function">HttpResponse <span class="title">response</span><span class="params">(close)</span></span>;</span><br><span class="line">    <span class="built_in">httpCallback_</span>(req, &amp;response);</span><br><span class="line">    Buffer buf;</span><br><span class="line">    response.<span class="built_in">appendToBuffer</span>(&amp;buf);</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(&amp;buf);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = response.g_file.<span class="built_in">c_str</span>();</span><br><span class="line">    FILE *fp = ::<span class="built_in">fopen</span>(file, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">TcpConnection::FilePtr <span class="title">ctx</span><span class="params">(fp, ::fclose)</span></span>;</span><br><span class="line">        <span class="comment">// conn-&gt;setContext(ctx);</span></span><br><span class="line">        conn-&gt;filePtr_.<span class="built_in">swap</span>(ctx);</span><br><span class="line">        <span class="type">char</span> buf[TcpConnection::kBufSize];</span><br><span class="line">        <span class="type">size_t</span> nread = ::<span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="keyword">sizeof</span> buf, fp);</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(buf, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(nread));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; file &lt;&lt; <span class="string">&quot; no such file&quot;</span>;</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::onWriteComplete</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[TcpConnection::kBufSize];</span><br><span class="line">    <span class="type">size_t</span> nread = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;filePtr_)</span><br><span class="line">        nread = ::<span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="keyword">sizeof</span> buf, <span class="built_in">get_pointer</span>(conn-&gt;filePtr_));</span><br><span class="line">    <span class="keyword">if</span> (nread &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(buf, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(nread));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        conn-&gt;filePtr_.<span class="built_in">reset</span>();</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">&quot;FileServer - done&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 对http消息进行处理的函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param req</span></span><br><span class="line"><span class="comment"> * @param resp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::onHttpProcess</span><span class="params">(<span class="type">const</span> HttpRequest &amp;req, HttpResponse *resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;Headers &quot;</span> &lt;&lt; req.<span class="built_in">methodString</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; req.<span class="built_in">path</span>();</span><br><span class="line"></span><br><span class="line">    std::string file;</span><br><span class="line">    <span class="keyword">if</span> (!req.<span class="built_in">body</span>().<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *bodyStr = req.<span class="built_in">body</span>().<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="comment">// 将用户名和密码提取出来</span></span><br><span class="line">        <span class="comment">// user=123&amp;passwd=123</span></span><br><span class="line">        <span class="type">char</span> name[<span class="number">100</span>], password[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">5</span>; bodyStr[i] != <span class="string">&#x27;&amp;&#x27;</span>; ++i)</span><br><span class="line">            name[i - <span class="number">5</span>] = bodyStr[i];</span><br><span class="line">        name[i - <span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = i + <span class="number">10</span>; bodyStr[i] != <span class="string">&#x27;\0&#x27;</span>; ++i, ++j)</span><br><span class="line">            password[j] = bodyStr[i];</span><br><span class="line">        password[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/3CGISQL.cgi&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 表示注册</span></span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">count</span>(name))</span><br><span class="line">            &#123;</span><br><span class="line">                file.<span class="built_in">append</span>(<span class="string">&quot;resources/registerError.html&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果是注册，先检测数据库中是否有重名的</span></span><br><span class="line">                <span class="comment">// 没有重名的，进行增加数据</span></span><br><span class="line">                <span class="type">char</span> *sql_insert = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">                <span class="built_in">strcpy</span>(sql_insert, <span class="string">&quot;INSERT INTO user(username, passwd) VALUES(&quot;</span>);</span><br><span class="line">                <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                <span class="built_in">strcat</span>(sql_insert, name);</span><br><span class="line">                <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;, &#x27;&quot;</span>);</span><br><span class="line">                <span class="built_in">strcat</span>(sql_insert, password);</span><br><span class="line">                <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 先从连接池中取一个连接</span></span><br><span class="line">                MYSQL *mysql = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="function">ConnectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;mysql, connPool_)</span></span>;</span><br><span class="line">                <span class="comment">// 此处感觉需要锁一下</span></span><br><span class="line">                <span class="type">int</span> res = <span class="built_in">mysql_query</span>(mysql, sql_insert);</span><br><span class="line">                <span class="keyword">if</span> (!res)</span><br><span class="line">                &#123;</span><br><span class="line">                    users[name] = password;</span><br><span class="line">                    file.<span class="built_in">append</span>(<span class="string">&quot;resources/login.html&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    file.<span class="built_in">append</span>(<span class="string">&quot;resources/registerError.html&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/2CGISQL.cgi&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 表示登录</span></span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">count</span>(name) &amp;&amp; users[name] == password)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                file.<span class="built_in">append</span>(<span class="string">&quot;resources/welcome.html&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                file.<span class="built_in">append</span>(<span class="string">&quot;resources/logError.html&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/register.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/1&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/login.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/5&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/picture.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/6&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/video.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/7&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/fans.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="built_in">path</span>() == <span class="string">&quot;/404&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/404.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// strcpy(file, &quot;resources&quot;);</span></span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources&quot;</span>);</span><br><span class="line">        <span class="comment">// int len = strlen(file);</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *url_real = req.<span class="built_in">path</span>().<span class="built_in">c_str</span>();</span><br><span class="line">        file.<span class="built_in">append</span>(url_real);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件状态</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> fileStat;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stat</span>(file.<span class="built_in">c_str</span>(), &amp;fileStat) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; file &lt;&lt; <span class="string">&quot; no such file&quot;</span>;</span><br><span class="line">        file.<span class="built_in">clear</span>();</span><br><span class="line">        file.<span class="built_in">append</span>(<span class="string">&quot;resources/404.html&quot;</span>);</span><br><span class="line">        <span class="built_in">stat</span>(file.<span class="built_in">c_str</span>(), &amp;fileStat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (!(fileStat.st_mode &amp; S_IROTH))</span></span><br><span class="line">    <span class="comment">//   return;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (S_ISDIR(fileStat.st_mode))</span></span><br><span class="line">    <span class="comment">//   return;</span></span><br><span class="line"></span><br><span class="line">    resp-&gt;<span class="built_in">setStatusCode</span>(HttpResponse::k200Ok);</span><br><span class="line">    resp-&gt;<span class="built_in">setStatusMessage</span>(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Server&quot;</span>, <span class="string">&quot;tinyMuduo&quot;</span>);</span><br><span class="line">    resp-&gt;<span class="built_in">setContentLength</span>(fileStat.st_size);</span><br><span class="line">    resp-&gt;<span class="built_in">setFile</span>(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重要的东西是<code>onHttpProcess</code>函数，这个函数是处理http请求的逻辑。其次我觉得重要的是<code>onRequest</code>中发送文件，因为图片、html页面等文件太大，所以一次发可能装不下，所以这里参考了muduo中ftp的实现，在<code>onRequest</code>中发送一次文件，如果没有发送完会在<code>onWriteComplete</code>中接着发送。</p>
<h2 id="SqlConnectionPool"><a href="#SqlConnectionPool" class="headerlink" title="SqlConnectionPool"></a>SqlConnectionPool</h2><p>因为涉及连接数据库，简单将tinyWEbserver里面的数据库池搬了过来。</p>
<p>SqlConnectionPool.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SQLCONNECTIONPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SQLCONNECTIONPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logging.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tinyMuduo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ConnectionPool</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">MYSQL *<span class="title">getConnection</span><span class="params">()</span></span>;              <span class="comment">// 获取数据库连接</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">releaseConnection</span><span class="params">(MYSQL *conn)</span></span>; <span class="comment">// 释放连接</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getFreeConn</span><span class="params">()</span></span>;                   <span class="comment">// 获取连接</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">destroyPool</span><span class="params">()</span></span>;                  <span class="comment">// 销毁所有连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单例模式</span></span><br><span class="line">        <span class="function"><span class="type">static</span> ConnectionPool *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string url, string User, string PassWord, string DataBaseName, <span class="type">int</span> Port, <span class="type">int</span> MaxConn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">ConnectionPool</span>();</span><br><span class="line">        ~<span class="built_in">ConnectionPool</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxConn_;          <span class="comment">// 最大连接数</span></span><br><span class="line">        <span class="type">int</span> curConn_;          <span class="comment">// 当前已使用的连接数</span></span><br><span class="line">        <span class="type">int</span> freeConn_;         <span class="comment">// 当前空闲的连接数</span></span><br><span class="line">        list&lt;MYSQL *&gt; connList; <span class="comment">// 连接池</span></span><br><span class="line">        std::mutex mutex_;</span><br><span class="line">        std::condition_variable condition_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string url_;          <span class="comment">// 主机地址</span></span><br><span class="line">        string port_;         <span class="comment">// 数据库端口号</span></span><br><span class="line">        string user_;         <span class="comment">// 登陆数据库用户名</span></span><br><span class="line">        string passwd_;     <span class="comment">// 登陆数据库密码</span></span><br><span class="line">        string databaseName_; <span class="comment">// 使用数据库名</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ConnectionRAII</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ConnectionRAII</span>(MYSQL **con, ConnectionPool *connPool);</span><br><span class="line">        ~<span class="built_in">ConnectionRAII</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MYSQL *conRAII_;</span><br><span class="line">        ConnectionPool *poolRAII_;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _SQLCONNECTIONPOOL_H</span></span></span><br></pre></td></tr></table></figure>
<p>SqlConnectionPool.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SqlConnectionPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tinyMuduo</span><br><span class="line">&#123;</span><br><span class="line">    ConnectionPool::<span class="built_in">ConnectionPool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        curConn_ = <span class="number">0</span>;</span><br><span class="line">        freeConn_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ConnectionPool *<span class="title">ConnectionPool::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> ConnectionPool connPool;</span><br><span class="line">        <span class="keyword">return</span> &amp;connPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ConnectionPool::init</span><span class="params">(string url, string User, string PassWord, string DBName, <span class="type">int</span> Port, <span class="type">int</span> MaxConn)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        url_ = url;</span><br><span class="line">        port_ = Port;</span><br><span class="line">        user_ = User;</span><br><span class="line">        passwd_ = PassWord;</span><br><span class="line">        databaseName_ = DBName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxConn; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            MYSQL *con = <span class="literal">NULL</span>;</span><br><span class="line">            con = <span class="built_in">mysql_init</span>(con);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (con == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG_ERROR &lt;&lt; <span class="string">&quot;MySQL Error&quot;</span>;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            con = <span class="built_in">mysql_real_connect</span>(con, url.<span class="built_in">c_str</span>(), User.<span class="built_in">c_str</span>(), PassWord.<span class="built_in">c_str</span>(), DBName.<span class="built_in">c_str</span>(), Port, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (con == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG_ERROR &lt;&lt; <span class="string">&quot;MySQL Error&quot;</span>;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            connList.<span class="built_in">push_back</span>(con);</span><br><span class="line">            ++freeConn_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxConn_ = freeConn_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当有请求时，从数据库连接池中返回一个可用连接，更新使用和空闲连接数</span></span><br><span class="line">    <span class="function">MYSQL *<span class="title">ConnectionPool::getConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MYSQL *con = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == connList.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">        con = connList.<span class="built_in">front</span>();</span><br><span class="line">        connList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        --freeConn_;</span><br><span class="line">        ++curConn_;</span><br><span class="line">        <span class="keyword">while</span> (freeConn_ &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            condition_.<span class="built_in">wait</span>(lk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放当前使用的连接</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ConnectionPool::releaseConnection</span><span class="params">(MYSQL *con)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == con)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">        connList.<span class="built_in">push_back</span>(con);</span><br><span class="line">        ++freeConn_;</span><br><span class="line">        --curConn_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// condition_.wait(lk);</span></span><br><span class="line">        <span class="keyword">if</span> (freeConn_ &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            condition_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁数据库连接池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ConnectionPool::destroyPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connList.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            list&lt;MYSQL *&gt;::iterator it;</span><br><span class="line">            <span class="keyword">for</span> (it = connList.<span class="built_in">begin</span>(); it != connList.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            &#123;</span><br><span class="line">                MYSQL *con = *it;</span><br><span class="line">                <span class="built_in">mysql_close</span>(con);</span><br><span class="line">            &#125;</span><br><span class="line">            curConn_ = <span class="number">0</span>;</span><br><span class="line">            freeConn_ = <span class="number">0</span>;</span><br><span class="line">            connList.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前空闲的连接数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ConnectionPool::getFreeConn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;freeConn_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConnectionPool::~<span class="built_in">ConnectionPool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">destroyPool</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConnectionRAII::<span class="built_in">ConnectionRAII</span>(MYSQL **SQL, ConnectionPool *connPool)</span><br><span class="line">    &#123;</span><br><span class="line">        *SQL = connPool-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line"></span><br><span class="line">        conRAII_ = *SQL;</span><br><span class="line">        poolRAII_ = connPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConnectionRAII::~<span class="built_in">ConnectionRAII</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        poolRAII_-&gt;<span class="built_in">releaseConnection</span>(conRAII_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// namespace tinyMuduo</span></span><br></pre></td></tr></table></figure>
<p>测试SqlConnectionPool_test.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../base/SqlConnectionPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要修改的数据库信息,登录名,密码,库名</span></span><br><span class="line">string user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">string passwd = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">string databasename = <span class="string">&quot;yourdb&quot;</span>;</span><br><span class="line"></span><br><span class="line">map&lt;string, string&gt; users;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initmysqlResult</span><span class="params">(tinyMuduo::ConnectionPool *connPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先从连接池中取一个连接</span></span><br><span class="line">    MYSQL *mysql = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">tinyMuduo::ConnectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;mysql, connPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在user表中检索username，passwd数据，浏览器端输入</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(mysql, <span class="string">&quot;SELECT username,passwd FROM user&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">&quot;SELECT error: &quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(mysql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从表中检索完整的结果集</span></span><br><span class="line">    MYSQL_RES *result = <span class="built_in">mysql_store_result</span>(mysql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果集中的列数</span></span><br><span class="line">    <span class="type">int</span> num_fields = <span class="built_in">mysql_num_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回所有字段结构的数组</span></span><br><span class="line">    MYSQL_FIELD *fields = <span class="built_in">mysql_fetch_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从结果集中获取下一行，将对应的用户名和密码，存入map中</span></span><br><span class="line">    <span class="keyword">while</span> (MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(result))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">string <span class="title">temp1</span><span class="params">(row[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="function">string <span class="title">temp2</span><span class="params">(row[<span class="number">1</span>])</span></span>;</span><br><span class="line">        users[temp1] = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化数据库连接池</span></span><br><span class="line">    tinyMuduo::ConnectionPool *connPool = tinyMuduo::ConnectionPool::<span class="built_in">getInstance</span>();</span><br><span class="line">    connPool-&gt;<span class="built_in">init</span>(<span class="string">&quot;127.0.0.1&quot;</span>, user, passwd, databasename, <span class="number">3306</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据库读取表</span></span><br><span class="line">    <span class="built_in">initmysqlResult</span>(connPool);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = users.<span class="built_in">begin</span>(); iter != users.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; passwd: &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mysql是使用docker进行安装的，进入docker查看一下数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20230213144740181.png" alt="image-20230213144740181"></p>
<p>运行测试</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20230213144824101.png" alt="image-20230213144824101"></p>
<p>可以看到简单的连接是成功的</p>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>main里面实现很简单，主要是需要写好数据库相关的信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/Logging.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net/EventLoop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net/http/HttpServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net/http/HttpRequest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net/http/HttpResponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tinyMuduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tinyMuduo::net;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要修改的数据库信息,登录名,密码,库名</span></span><br><span class="line">  string user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">  string passwd = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">  string databasename = <span class="string">&quot;yourdb&quot;</span>;</span><br><span class="line">  <span class="type">int</span> sqlNum = <span class="number">8</span>;</span><br><span class="line">  <span class="type">int</span> numThreads = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  EventLoop loop;</span><br><span class="line">  <span class="function">HttpServer <span class="title">server</span><span class="params">(&amp;loop, InetAddress(<span class="number">8080</span>), <span class="string">&quot;webserver&quot;</span>, user, passwd, databasename, sqlNum)</span></span>;</span><br><span class="line">  server.<span class="built_in">setThreadNum</span>(numThreads);</span><br><span class="line">  server.<span class="built_in">start</span>();</span><br><span class="line">  loop.<span class="built_in">loop</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>登录界面</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20230213151254186.png" alt="image-20230213151254186"></p>
<p>选择界面</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20230213151319812.png" alt="image-20230213151319812"></p>
<p>关注界面</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20230213151339389.png" alt="image-20230213151339389"></p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>感谢muduo的仓库和tinyWebserver仓库</p>
<p>muduo：<a href="https://github.com/chenshuo/muduo">https://github.com/chenshuo/muduo</a></p>
<p>tinyWebServer:<a href="https://github.com/qinguoyi/TinyWebServer">https://github.com/qinguoyi/TinyWebServer</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在muduo的基础上想写个webserver很简单，只需要在他http的基础上进行改进就可以。</p>
<p>最好代码仓库：<a href="https://github.com/bugcat9/tinyMuduo">https://github.com/bugcat9/tinyMuduo</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程编程</title>
    <url>/2022/08/31/Linux/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h1><p>学习《Linux高性能服务器编程》第十三章多进程编程，里面介绍了各种Linux编程中多进程编程的内容，为了印象深刻一些，多动手多实践，所以记下这个笔记。这一篇主要记录Linux中。这一章分为fork系统调用、exec系列系统调用、处理僵尸进程、信号量、共享内存、消息队列、IPC命令。</p>
<span id="more"></span>
<h2 id="fork系统调用"><a href="#fork系统调用" class="headerlink" title="fork系统调用"></a>fork系统调用</h2><p>Linux当作创建新进程的系统调用是fork</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><code>fork</code>函数的每次调用都返回两次，在父进程中返回的是子进程的<code>PID</code>，在子进程中则返回0。该返回值是后续代码判断当前进程是父进程还是子进程的依据。</p>
<p><code>fork</code>调用失败时返回-1，并设置<code>errno</code>。</p>
<p><code>fork</code>函数深入起来需要注意的点有很多，书中给了三个需要注意的部分：</p>
<ul>
<li><code>fork</code>函数复制当前进程，在内核进程表中创建一个<strong>新的</strong>进程表项。新的进程表项有很多属性和原进程相同，比如堆指针、栈指针和标志寄存器的值。但也有许多属性被赋予了新的值，比如该进程的<code>PPID</code>被设置成原进程的<code>PID</code>，<strong>信号位图被清除</strong>（原进程设置的信号处理函数不再对新进程起作用)。</li>
<li>子进程的代码与父进程完全<strong>相同</strong>，同时它还会复制父进程的数据（堆数据、栈数据和静态数据)。数据的复制采用的是所谓的<strong>写时复制</strong>(copy on writte)，即只有在任一进程(父进程或子进程）对数据执行了<strong>写操作时</strong>，复制才会发生（先是缺页中断，然后操作系统给子进程分配内存并复制父进程的数据)。即便如此，如果我们在程序中分配了大量内存，那么使用<code>fork</code>时也应当十分谨慎，尽量避免没必要的内存分配和数据复制。</li>
<li>创建子进程后，父进程中打开的<strong>文件描述符</strong>默认在子进程中也是打开的，且文件描述符的引用计数加1。不仅如此，父进程的用户根目录、当前工作目录等变量的引用计数均会加1。</li>
</ul>
<p>写个简单的小例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m parent pid = %d, parentID = %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child  pid = %d, parentID=%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220902104536913.png" alt="image-20220902104536913"></p>
<h2 id="exec系列系统调用"><a href="#exec系列系统调用" class="headerlink" title="exec系列系统调用"></a>exec系列系统调用</h2><p>有时我们需要在子进程中<strong>执行其他程序</strong>，即替换当前进程映像，这就需要使用如下exec系列函数之一:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>
<p><code>path</code>参数指定可执行文件的完整路径，<code>file</code>参数可以接受文件名，该文件的具体位置则在环境变量<code>PATH</code>中搜寻。</p>
<p><code>arg</code>接受可变参数，<code>argv</code>则接受参数数组，它们都会被传递给新程序(<code>path</code>或<code>file</code>指定的程序）的<code>main</code>函数。<code>envp</code>参数用于设置新程序的环境变量。如果未设置它，则新程序将使用由全局变量<code>environ</code>指定的环境变量。</p>
<p>一般<code>exec</code>函数是不返回的，除非出错。它出错时返回-1，并设置<code>errno</code>。如果没出错，则原程序中<code>exec</code>调用之后的代码都不会执行，因为此时原程序已经被<code>exec</code>的参数指定的程序完全替换（包括代码和数据)。</p>
<p><code>exec</code>函数不会关闭原程序打开的文件描述符，除非该文件描述符被设置了类似<code>SOCK_CLOEXEC</code>的属性。</p>
<p><code>exec</code>函数族一般规律：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l(list)       命令行参数列表</span><br><span class="line"></span><br><span class="line">p(path)       搜索file时使用环境变量</span><br><span class="line"></span><br><span class="line">v(vector)      使用命令行参数数组</span><br><span class="line"></span><br><span class="line">e(environment)    使用环境变量数组，不适用进程原有的环境变量，设置新加载程序运行的环境变量</span><br></pre></td></tr></table></figure>
<p>事实上，只有<code>execve</code>是真正的系统调用，其他5个函数最终都调用<code>execve</code>，是库函数，所以<code>execve</code>在man手册第二节，其它函数在man手册第3节。</p>
<p>小栗子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;========================\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *argvv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-F&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-F&quot;, &quot;-a&quot;, NULL);</span></span><br><span class="line">        <span class="comment">// execv(&quot;/bin/ls&quot;, argvv);</span></span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-F&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 使用环境变量</span></span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220903203128588.png" alt="image-20220903203128588"></p>
<h2 id="处理僵尸进程（回收子进程）"><a href="#处理僵尸进程（回收子进程）" class="headerlink" title="处理僵尸进程（回收子进程）"></a>处理僵尸进程（回收子进程）</h2><p>对于多进程程序而言，父进程一般需要跟踪子进程的退出状态。因此，当子进程结束运行时，内核不会立即释放该进程的进程表表项，以满足父进程后续对该子进程退出信息的查询（如果父进程还在运行)。因此有时候子进程会产生两种特殊状态：孤儿进程和僵尸进程（大概就这种意思）</p>
<p><strong>孤儿进程</strong>：<strong>父进程退出</strong>，而它的一个或多个<strong>子进程还在运行</strong>，那么那些子进程将成为孤儿进程。孤儿进程将被<code>init</code>进程(进程号为1)所收养，并由<code>init</code>进程对它们完成状态收集工作。（孤儿进程并不会有什么危害，因为<code>init</code>进程会循环地wait()它的已经退出的子进程）</p>
<p><strong>僵尸进程</strong>：一个进程使用fork创建子进程，如果<strong>子进程退出</strong>，而父进程并没有调用<code>wait</code>或<code>waitpid</code>获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p>
<p><strong>孤儿进程</strong>例子:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am child, my parent pid = %d\n&quot;</span>, getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent, my pid is = %d\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">9</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------parent going to die------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看的父进程退出后，子进程的<code>ppid</code>变成了1（<code>init</code>的<code>pid</code>）,也就是说子进程被<code>init</code>领养了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220903211841731.png" alt="image-20220903211841731"></p>
<p><strong>僵尸进程</strong>例子:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---child, my parent= %d, going to sleep 10s\n&quot;</span>, getppid());</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------child die--------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am parent, pid = %d, myson = %d\n&quot;</span>, getpid(), pid);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220903212739059.png" alt="image-20220903212739059"></p>
<p>子进程处于<strong>僵尸态</strong>会占用内核资源，内核资源长期被占用得不到释放显然是一件不好的事情。所以父进程需要正确的进行调用处理好子进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>
<p><code>wait</code>函数将<strong>阻塞进程</strong>，直到该进程的某个子进程结束运行为止。它返回结束运行的子进程<code>PID</code>。并将该子进程的退出状态信息存储于<code>wstatus</code>参数指向的内存中。Linux中有几个宏来帮助解释子进程的退出状态信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220903210213373.png" alt="image-20220903210213373"></p>
<p><code>wait</code>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid, wpid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---child, my id= %d, going to sleep 10s\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------child die--------------\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">73</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// wpid = wait(NULL);          // 不关心子进程结束原因</span></span><br><span class="line">        wpid = wait(&amp;status); <span class="comment">// 如果子进程未终止,父进程阻塞在这个函数上</span></span><br><span class="line">        <span class="keyword">if</span> (wpid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123; <span class="comment">//为真,说明子进程正常终止.</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exit with %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">        &#123; <span class="comment">//为真,说明子进程是被信号终止.</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child kill with signal %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------parent wait finish: %d\n&quot;</span>, wpid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220903213718096.png" alt="image-20220903213718096"></p>
<p><code>wait</code>会阻塞进程，显然不是我们服务器所期望的，而<code>waitpid</code>函数解决了这个问题，它可以设置非阻塞。</p>
<p><code>waitpid</code>只等待由<code>pid</code>参数指定的子进程。如果<code>pid</code>取值为-1，那么它就和 wait函数相同，即等待<strong>任意</strong>一个子进程结束。</p>
<p><code>wstatus</code>参数的含义和<code>wait</code>函数的<code>wstatus</code>参数相同。<code>options</code>参数可以控制<code>waitpid</code>函数的行为。该参数最常用的取值是<code>WNOHANG</code>。当<code>options</code>的取值是<code>WNOHANG</code>时，<code>waitpid</code>调用将是非阻塞的:如果<code>pid</code>指定的目标子进程<strong>还没有结束或意外终止</strong>，则<code>waitpid</code>立即返回0；如果目标子进程确实正常退出了，则 <code>waitpid</code>返回该子进程的<code>PID</code>。<code>waitpid</code>调用失败时返回-1并设置<code>errno</code>。</p>
<p>Linux在事件<strong>已经发生的情况下</strong>执行非阻塞调用才能提高程序的效率。对<code>waitpid</code>函数而言，我们最好在某个子进程退出之后再调用它。那么父进程从何得知某个子进程已经退出了呢?这正是<code>SIGCHLD</code>信号的用途。当一个进程结束时，它将给其父进程发送一个<code>SIGCHLD</code>信号。因此，我们可以在父进程中捕获<code>SIGCHLD</code>信号，并在信号处理函数中调用<code>waitpid</code>函数以“彻底结束”一个子进程。</p>
<p><code>waitpid</code>简单小例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_child</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123; <span class="comment">//为真,说明子进程正常终止.</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exit with %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">        &#123; <span class="comment">//为真,说明子进程是被信号终止.</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child kill with signal %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child ID %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">73</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 设置信号处理函数</span></span><br><span class="line">        <span class="keyword">struct</span> sigaction act;</span><br><span class="line">        act.sa_handler = handle_child;</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask); <span class="comment">//不屏蔽任何信号</span></span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent ID %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220905104308336.png" alt="image-20220905104308336"></p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量（注意不是信号）是操作系统（并发）里面的概念，解决的是多个进程之间的同步问题。<code>Linux</code>信号量的API都定义在<code>sys/sem.h</code>头文件中，主要包含3个系统调用:<code>semget,semop和semctl</code>。它们都被设计为操作一组信号量，即信号量集，而不是单个信号量，因此这些接口看上要复杂一点。</p>
<h3 id="semget"><a href="#semget" class="headerlink" title="semget"></a>semget</h3><p><code>semget</code>系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span>;</span><br></pre></td></tr></table></figure>
<p><code>key</code>参数是一个键值，用来表示一个全局<strong>唯一</strong>的信号量集。要通过信号量通信的进程需要使用相同的键值来创建/获取该信号量。</p>
<p><code>nsems</code>参数指定要创建/获取的信号量集中信号量的数目。如果是<strong>创建</strong>信号量，则该值必须被指定；如果是<strong>获取</strong>已经存在的信号量，则可以把它设置为0。</p>
<p><code>semflg</code>参数指定信号量的操作类型以及操纵权限。</p>
<p><code>semget</code>成功时返回一个正整数值，它是信号量集的标识符；<code>semget</code>失败时返回-1，并设置<code>errno</code>。</p>
<p><code>semget</code>用于创建信号量集时，和它关联的内核数据结构体<code>semid_ds</code>将会被创建并初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">   <span class="type">key_t</span>          __key; <span class="comment">/* Key supplied to semget(2) */</span></span><br><span class="line">   <span class="type">uid_t</span>          uid;   <span class="comment">/* Effective UID of owner */</span></span><br><span class="line">   <span class="type">gid_t</span>          gid;   <span class="comment">/* Effective GID of owner */</span></span><br><span class="line">   <span class="type">uid_t</span>          cuid;  <span class="comment">/* Effective UID of creator */</span></span><br><span class="line">   <span class="type">gid_t</span>          cgid;  <span class="comment">/* Effective GID of creator */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> mode;  <span class="comment">/* Permissions */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> __seq; <span class="comment">/* Sequence number */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span>  <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">   <span class="type">time_t</span>          sem_otime; <span class="comment">/* Last semop time */</span></span><br><span class="line">   <span class="type">time_t</span>          sem_ctime; <span class="comment">/* Last change time */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span>   sem_nsems; <span class="comment">/* No. of semaphores in set */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916110352739.png" alt="image-20220916110352739"></p>
<h3 id="semop系统调用"><a href="#semop系统调用" class="headerlink" title="semop系统调用"></a>semop系统调用</h3><p><code>semop</code>系统调用改变信号量的值，即执行PV操作。<code>semop</code>是通过在底层是通过操作一些重要的内核变量，如：<code>semval</code>、<code>semzcnt</code>、<code>semncnt</code>、<code>sempid</code>，来实现PV功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span>  semval;   <span class="comment">/* semaphore value */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>  semzcnt;  <span class="comment">/* # waiting for zero */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>  semncnt;  <span class="comment">/* # waiting for increase */</span></span><br><span class="line"><span class="type">pid_t</span>           sempid;   <span class="comment">/* PID of process that last</span></span><br></pre></td></tr></table></figure>
<p><code>semop</code>的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">size_t</span> nsops)</span>;</span><br></pre></td></tr></table></figure>
<p><code>semid</code>参数是由<code>semget</code>调用返回的信号量集标识符，用以指定被操作的目标信号量集。</p>
<p><code>sops</code>参数指向一个<code>sembuf</code>结构体类型的数组，<code>sembuf</code>结构体的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Structure used for argument to `semop&#x27; to describe operations.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sem_num;	<span class="comment">/* semaphore number */</span></span><br><span class="line">  <span class="type">short</span> <span class="type">int</span> sem_op;		<span class="comment">/* semaphore operation */</span></span><br><span class="line">  <span class="type">short</span> <span class="type">int</span> sem_flg;		<span class="comment">/* operation flag */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>sem_num</code>成员是信号量集中信号量的编号，0表示信号量集中第一个信号量。</p>
<p><code>sem_op</code>成员指定操作类型，其可选值为正整数、0和负整数。每种类型的操作的行为又受到<code>sem_fig</code>成员的影响。<code>sem_fg</code>的可选值是<code>IPC_NOWAIT</code>和<code>SEM_UNDO</code>。<code>IPC_NOWAIT</code>的含义是，无论信号量操作是否成功，<code>semop</code>调用都将立即返回，这类似于非阻塞IO操作。<code>SEM_UNDO</code>的含义是，当进程退出时取消正在进行的<code>semop</code>操作。具体来说，<code>sem_op</code>和<code>sem_flg</code> 将按照如下方式来影响<code>semop</code>的行为:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220914191132925.png" alt="image-20220914191132925"></p>
<p><code>semop</code>系统调用的第3个参数<code>num_sem_ops</code>指定要执行的操作个数，即<code>sem_ops</code>数组中元素的个数。<code>semop</code>对数组<code>sem_ops</code>中的每个成员按照数组顺序依次执行操作，并且该过程是原子操作，以避免别的进程在同一时刻按照不同的顺序对该信号集中的信号量执行<code>semop</code>操作导致的竞态条件。</p>
<p><code>semop</code>成功时返回0，失败则返回-1并设置<code>errno</code>。失败的时候，<code>sem_ops</code>数组中指定的所有操作都不被执行。</p>
<h3 id="semtcl系统调用"><a href="#semtcl系统调用" class="headerlink" title="semtcl系统调用"></a>semtcl系统调用</h3><p><code>semctl</code>系统调用允许调用者对信号量进行直接控制。其定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ...)</span>;</span><br></pre></td></tr></table></figure>
<p><code>sem_id</code>参数是由<code>semget</code>调用返回的信号量集标识符，用以指定被操作的信号量集。</p>
<p><code>semnum</code>参数指定被操作的信号量在信号量集中的编号。</p>
<p><code>cmd</code>参数指定要执行的命令。有的命令需要调用者传递第4个参数。第4个参数的类型由用户自己定义，但<code>sys/sem.h</code>头文件给出了它的推荐格式，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">   <span class="type">int</span>              val;    <span class="comment">/* 用于 SETVAL */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>    <span class="comment">/* 用于 IPC_STAT, IPC_SET */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span>  *<span class="built_in">array</span>;  <span class="comment">/* 用于 GETALL, SETALL */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *__<span class="title">buf</span>;</span>  <span class="comment">/* 用于 IPC_INFO(Linux-specific) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">seminfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> semmap;				<span class="comment">/* Linux内核没有使用 */</span></span><br><span class="line">  <span class="type">int</span> semmni;				<span class="comment">/* 系统最多可以拥有的信号量集数目 */</span></span><br><span class="line">  <span class="type">int</span> semmns;				<span class="comment">/* 系统最多可以拥有的信号量数目 */</span></span><br><span class="line">  <span class="type">int</span> semmnu;				<span class="comment">/* Linux内核没有使用 */</span></span><br><span class="line">  <span class="type">int</span> semmsl;				<span class="comment">/* 一个信号集最多允许包含的信号量数目 */</span></span><br><span class="line">  <span class="type">int</span> semopm;				<span class="comment">/* semop一次最多能执行的sem_op操作数目 */</span></span><br><span class="line">  <span class="type">int</span> semume;				<span class="comment">/* Linux内核没有使用 */</span></span><br><span class="line">  <span class="type">int</span> semusz;				<span class="comment">/* sem_undo结构体的大小 */</span></span><br><span class="line">  <span class="type">int</span> semvmx;				<span class="comment">/* 最大允许的信号量值 */</span></span><br><span class="line">  <span class="type">int</span> semaem;				<span class="comment">/* 最多允许的UNDO次数（待SEM_UNDO标志的semop操作的次数）*/</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>semctl</code>支持的命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220914213741897.png" alt="image-20220914213741897"></p>
<p>这些操作中，<code>GETNCNT</code>、<code>GETPID</code>、<code>GETVAL</code>、<code>GETZCNT</code>和<code>SETVAL</code>操作的是单个信号量，它是由标识符<code>semid</code>指定的信号量集中的第<code>semnum</code>个信号量;而其他操作针对的是整个信号量集，此时<code>semctl</code>的参数<code>semnum</code>被忽略。</p>
<p><code>semctl</code>成功时的返回值取决于<code>cmd</code>参数，如表13-2所示。<code>semctl</code>失败时返回-1,并设置<code>errno</code>。</p>
<h3 id="特殊键值IPC-PRIVATE"><a href="#特殊键值IPC-PRIVATE" class="headerlink" title="特殊键值IPC_PRIVATE"></a>特殊键值IPC_PRIVATE</h3><p><code>semget</code>的调用者可以给其<code>key</code>参数传递一个特殊的键值<code>IPC_PRIVATE</code>(其值为0)，这样无论该信号量是否已经存在，<code>semget</code>都将创建一个新的信号量。使用该键值创建的信号量并非像它的名字声称的那样是进程私有的。其他进程，尤其是子进程，也有方法来访问这个信号量。所以<code>semget</code>的 man手册的<code>BUGS</code>部分上说，使用名字<code>IPC_PRIVATE</code>有些误导（历史原因)，应该称为<code>IPC_NEW</code>。比如下面的代码就在父、子进程间使用一个IPC_PRIVATE信号量来同步。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pv</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = op;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    semop(sem_id, &amp;sem_b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sem_id = semget(IPC_PRIVATE, <span class="number">1</span>, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_un</span>;</span></span><br><span class="line">    sem_un.val = <span class="number">1</span>;</span><br><span class="line">    semctl(sem_id, <span class="number">0</span>, SETVAL, sem_un);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child try to get binary sem\n&quot;</span>);</span><br><span class="line">        pv(sem_id, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child get the sem and would release it after 5 seconds\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        pv(sem_id, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent try to get binary sem\n&quot;</span>);</span><br><span class="line">        pv(sem_id, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent get the sem and would release it after 5 seconds\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        pv(sem_id, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    waitpid(id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    semctl(sem_id, <span class="number">0</span>, IPC_RMID, sem_un);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存是最高效的IPC机制，因为它不涉及进程之间的任何数据传输。这种高效率带来的问题是，我们必须用其他辅助手段来同步进程对共享内存的访问，否则会产生竞态条件。因此，共享内存通常和其他进程间通信方式一起使用。</p>
<p>Linux共享内存的API都定义<code>sys/shm.h</code>头文件中，包括4个系统调用: <code>shmget</code>、<code>shmat</code>、<code>shmdt</code> 和l<code>shmctl</code>。我们将依次讨论之。</p>
<h3 id="shmget系统调用"><a href="#shmget系统调用" class="headerlink" title="shmget系统调用"></a>shmget系统调用</h3><p><code>shmget</code>系统调用创建一段新的共享内存，或者获取一段已经存在的共享内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>
<p><code>key</code>参数是一个键值，用来标识一段全局唯一的共享内存。</p>
<p><code>size</code>参数指定共享内存的大小，单位是字节。如果是创建新的共享内存，则size值必须被指。如果是获取已经存在的共享内存，则可以把<code>size</code>设置为0。</p>
<p><code>shmflg</code>参数指定信号量的操作类型以及操纵权限。它和<code>semget</code>中<code>semflg</code>参数相同，但是<code>shmflg</code>支持两个额外的标志：<code>SHM_HUGETLB</code>和<code>SHM_NORESERVE</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916104221617.png" alt="image-20220916104221617"></p>
<p><code>shmget</code>成功时返回—个正整数值，它是共享内存的标识符。<code>shmget</code>失败时返回-1，并设置<code>errno</code>。</p>
<p>如果<code>shmget</code>用于创建共享内存，则这段共享内存的所有字节都被初始化为0，与之关联的内核数据结构<code>shmid_ds</code>将被创建并初始化。<code>shmid_ds</code>结构体的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">   <span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line">   <span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line">   <span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line">   <span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Last change time */</span></span><br><span class="line">   <span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line">   <span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class="line">   <span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* No. of current attaches */</span></span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">   <span class="type">key_t</span>          __key;    <span class="comment">/* Key supplied to shmget(2) */</span></span><br><span class="line">   <span class="type">uid_t</span>          uid;      <span class="comment">/* Effective UID of owner */</span></span><br><span class="line">   <span class="type">gid_t</span>          gid;      <span class="comment">/* Effective GID of owner */</span></span><br><span class="line">   <span class="type">uid_t</span>          cuid;     <span class="comment">/* Effective UID of creator */</span></span><br><span class="line">   <span class="type">gid_t</span>          cgid;     <span class="comment">/* Effective GID of creator */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> mode;     <span class="comment">/* Permissions + SHM_DEST and</span></span><br><span class="line"><span class="comment">                               SHM_LOCKED flags */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> __seq;    <span class="comment">/* Sequence number */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916110659249.png" alt="image-20220916110659249"></p>
<h3 id="shmat和shdt系统调用"><a href="#shmat和shdt系统调用" class="headerlink" title="shmat和shdt系统调用"></a>shmat和shdt系统调用</h3><p>共享内存被创建/获取之后，我们不能立即访问它，而是需要先将它关联到进程的地址空间中。使用完共享内存之后，我们也需要将它从进程地址空间中分离。这两项任务分别由如下两个系统调用实现:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure>
<p><code>shmid</code>参数是由<code>shmget</code>调用返回的共享内存标识符。</p>
<p><code>shmaddr</code>参数指定将共享内存关联到进程的那块地址空间，最终的效果还受到<code>shmflg</code>参数的可选标志<code>SHM_RND</code>的影响。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916142910291.png" alt="image-20220916142910291"></p>
<p>除了<code>SHM_RND</code>标志外，shmflg参数还支持如下标志：</p>
<p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220916143225086.png" alt="image-20220916143225086"></p>
<p><code>shmat</code>成功时返回共享内存被关联到的地址，失败则返回<code>(void*)-1</code>并设置<code>errno</code>。<code>shmat</code>成功时，将修改内核数据结构<code>shmid_ds</code>的部分字段，如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916143610901.png" alt="image-20220916143610901"></p>
<p><code>shmdt</code>函数将关联到<code>shm_addr</code>处的共享内存从进程中分离。它成功时返回0，失败则返回-1并设置<code>errno</code>。<code>shmdt</code>在成功调用时将修改内核数据结构<code>shmid_ds</code>的部分字段，如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916143718065.png" alt="image-20220916143718065"></p>
<h3 id="shmctl系统调用"><a href="#shmctl系统调用" class="headerlink" title="shmctl系统调用"></a>shmctl系统调用</h3><p>shmctl系统调用控制共享内存的某些属性。定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>
<p><code>shmid</code>参数是由<code>shmget</code>调用返回的共享内存标识符。</p>
<p><code>cmd</code>参数指定要执行的命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916160516010.png" alt="image-20220916160516010"></p>
<p><code>shmctl</code>成功时的返回值取决于<code>cmd</code>参数，如上表所展示的，<code>shmctl</code>失败时返回-1，并且设置<code>erron</code>。</p>
<h3 id="共享内存POSIX方法"><a href="#共享内存POSIX方法" class="headerlink" title="共享内存POSIX方法"></a>共享内存POSIX方法</h3><p>之前介绍过<code>mmap</code>函数。利用它的<code>MAP_ANONYMOUS</code>标志我们可以实现父、子进程之间的匿名内存共享。通过打开同一个文件，<code>mmap</code>也可以实现无关进程之间的内存共享。Linux提供了另外一种利用<code>mmap</code>在无关进程之间共享内存的方式。这种方式无须任何文件的支持，但它需要先使用如下函数来创建或打开一个<code>POSIX</code>共享内存对象:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>        <span class="comment">/* For mode constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>           <span class="comment">/* For O_* constants */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shm_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">shm_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<p><code>shm_open</code>的使用方法与<code>open</code>系统调用完全相同。</p>
<p><code>name</code>参数指定要创建<code>/</code>打开的共享内存对象。从可移植性的角度考虑，该参数应该使用”/somename”的格式:以“/”开始，后接多个字符，且这些字符都不是“/”；以“\0”结尾，长度不超过<code>NAME_MAX</code>(通常是255)。</p>
<p><code>oflag</code>参数指定创建方式。它可以是下列标志中的一个或者多个的按位或:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916183212921.png" alt="image-20220916183212921"></p>
<p><code>shm_open</code>调用成功时返回一个文件描述符。该文件描述符可用于后续的<code>mmap</code>调用，从而将共享内存关联到调用进程。<code>shm_open</code>失败时返回-1，并设置<code>errno</code>。</p>
<p>和打开的文件最后需要关闭一样，由<code>shm_open</code>创建的共享内存对象使用完之后也需要被删除。这个过程是通过<code>shm_unlink</code>函数实现的。</p>
<p>该函数将<code>name</code>参数指定的共享内存对象标记为等待删除。当所有使用该共享内存对象的进程都使用<code>ummap</code>将它从进程中分离之后，系统将销毁这个共享内存对象所占据的资源。</p>
<p>如果代码中使用了上述<code>POSIX</code>共享内存函数，则编译的时候需要指定链接选项<code>-lrt</code>。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是在两个进程之间传递二进制块数据的一种简单有效的方式。每个数据块都有一个特定的类型，接收方可以根据类型来有选择地接收数据，而不一定像管道和命名管道那样必须以先进先出的方式接收数据。</p>
<p>Linux消息队列的API都定义在<code>sys/msg.h</code>头文件中，包括4个系统调用: <code>msgget</code>、<code>msgsnd</code>、<code>msgrcv</code>和 <code>msgctl</code>。</p>
<h3 id="msgget系统调用"><a href="#msgget系统调用" class="headerlink" title="msgget系统调用"></a>msgget系统调用</h3><p><code>msgget</code>系统调用创建一个消息队列，或者获取一个已有的消息队列。其定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>
<p><code>key</code>参数是一个键值，用来标识一段全局唯一的共享内存。</p>
<p><code>msgflg</code>参数指定信号量的操作类型以及操纵权限。它和<code>semget</code>中<code>semflg</code>参数相同。</p>
<p><code>msgget</code>成功时返回一个正整数值，它是消息队列的标识符。<code>msgget</code>失败时返回-1，并设置<code>errno</code>。</p>
<p>如果<code>msgget</code>用于创建消息队列，则与之关联的内核数据结构<code>msqid_ds</code>将被创建并初始化。<code>msqid_ds</code>结构体的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span>     <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">   <span class="type">time_t</span>          msg_stime;    <span class="comment">/* Time of last msgsnd(2) */</span></span><br><span class="line">   <span class="type">time_t</span>          msg_rtime;    <span class="comment">/* Time of last msgrcv(2) */</span></span><br><span class="line">   <span class="type">time_t</span>          msg_ctime;    <span class="comment">/* Time of last change */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span>   __msg_cbytes; <span class="comment">/* Current number of bytes in</span></span><br><span class="line"><span class="comment">                                    queue (nonstandard) */</span></span><br><span class="line">   <span class="type">msgqnum_t</span>       msg_qnum;     <span class="comment">/* Current number of messages</span></span><br><span class="line"><span class="comment">                                    in queue */</span></span><br><span class="line">   <span class="type">msglen_t</span>        msg_qbytes;   <span class="comment">/* Maximum number of bytes</span></span><br><span class="line"><span class="comment">                                    allowed in queue */</span></span><br><span class="line">   <span class="type">pid_t</span>           msg_lspid;    <span class="comment">/* PID of last msgsnd(2) */</span></span><br><span class="line">   <span class="type">pid_t</span>           msg_lrpid;    <span class="comment">/* PID of last msgrcv(2) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">   <span class="type">key_t</span>          __key;       <span class="comment">/* Key supplied to msgget(2) */</span></span><br><span class="line">   <span class="type">uid_t</span>          uid;         <span class="comment">/* Effective UID of owner */</span></span><br><span class="line">   <span class="type">gid_t</span>          gid;         <span class="comment">/* Effective GID of owner */</span></span><br><span class="line">   <span class="type">uid_t</span>          cuid;        <span class="comment">/* Effective UID of creator */</span></span><br><span class="line">   <span class="type">gid_t</span>          cgid;        <span class="comment">/* Effective GID of creator */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> mode;        <span class="comment">/* Permissions */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> __seq;       <span class="comment">/* Sequence number */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="msgsnd系统调用"><a href="#msgsnd系统调用" class="headerlink" title="msgsnd系统调用"></a>msgsnd系统调用</h3><p><code>msgsnd</code>系统调用把一条消息添加到消息队列当中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>
<p><code>msqid</code>参数是由<code>msgget</code>调用返回的消息队列标识符。</p>
<p><code>msgp</code>参数指向一个准备发生的消息，消息的类型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">   <span class="type">long</span> mtype;       <span class="comment">/* message type, must be &gt; 0 */</span></span><br><span class="line">   <span class="type">char</span> mtext[<span class="number">512</span>];    <span class="comment">/* message data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>mtype</code>成员指定消息的类型，它必须是一个正整数。<code>mtext</code>是消息数据。</p>
<p><code>msgsz</code>参数是消息的数据部分(<code>mtext</code>）的长度。这个长度可以为0，表示没有消息数据。</p>
<p><code>msgflg</code>参数控制<code>msgsnd</code>的行为。它通常仅支持<code>IPC_NOWAIT</code>标志，即以非阻塞的方式发送消息。默认情况下，发送消息时如果消息队列满了，则<code>msgsnd</code>将阻塞。若<code>IPC_NOWAIT</code>标志被指定，则<code>msgsnd</code>将立即返回并设置<code>errno</code>为<code>EAGAIN</code>。</p>
<p>处于阻塞状态的<code>msgsnd</code>调用可能被如下两种异常情况所中断:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916203148729.png" alt="image-20220916203148729"></p>
<p><code>msgsnd</code>成功时返回0，失败则返回-1并设置<code>errno</code>。<code>msgsnd</code>成功时将修改内核数据结构<code>msqid_ds</code>的部分字段，如下所示:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916203319762.png" alt="image-20220916203319762"></p>
<h3 id="msgrcv调用"><a href="#msgrcv调用" class="headerlink" title="msgrcv调用"></a>msgrcv调用</h3><p><code>msgrcv</code>系统调用从消息队列中获取消息。其定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>
<p><code>msqid</code>参数是由<code>msgget</code>调用返回的消息队列标识符。</p>
<p><code>msgp</code>参数用于存储接收的消息。</p>
<p><code>msgsz</code>参数指的是消息数据部分的长度。</p>
<p><code>msgtyp</code>参数指定接收何种类型的消息。我们可以使用如下几种方式来指定消息类型:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916203913760.png" alt="image-20220916203913760"></p>
<p><code>msgflg</code>参数控制<code>msgrcv</code>函数的行为。它可以是如下一些标志的按位或:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916204159893.png" alt="image-20220916204159893"></p>
<p>处于阻塞状态的<code>msgrcv</code>调用还可能被如下两种异常情况所中断:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916204353109.png" alt="image-20220916204353109"></p>
<p><code>msgrcv</code>成功时返回0，失败则返回-1并设置<code>errno</code>。<code>msgrcv</code>成功时将修改内核数据结构<code>msqid_ds</code>的部分字段，如下所示:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220916204528137.png" alt="image-20220916204528137"></p>
<h2 id="IPC命令"><a href="#IPC命令" class="headerlink" title="IPC命令"></a>IPC命令</h2><p>上述3种System V IPC进程间通信方式都使用一个全局唯一的键值（key)来描述一个共享资源。当程序调用<code>semget</code>、<code>shmget</code>或者<code>msgget</code>时，就创建了这些共享资源的一个实例。Linux提供了<code>ipcs</code>命令，以观察当前系统上拥有哪些共享资源实例。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220917105516824.png" alt="image-20220917105516824"></p>
<p>上图展示了机器里面没有任何消息队列，但是有共享内存和信号量。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统第2章练习题</title>
    <url>/2022/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC2%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统第2章练习题"><a href="#深入理解计算机系统第2章练习题" class="headerlink" title="深入理解计算机系统第2章练习题"></a>深入理解计算机系统第2章练习题</h1><h2 id="练习题2-1完成下面的数字转换"><a href="#练习题2-1完成下面的数字转换" class="headerlink" title="练习题2.1完成下面的数字转换:"></a>练习题2.1完成下面的数字转换:</h2><p>A.将0x39A7F8转换为二进制。</p>
<script type="math/tex; mode=display">
(39A7F8)_{16} = (0011-1001-1010-0111-1111-1000)_2</script><p>B.将二进制1100100101111011转换为十六进制。</p>
<script type="math/tex; mode=display">
(1100-1001-0111-1011)_2 = (C97B)_{16}</script><p>C.将0xD5E4C转换为二进制。</p>
<script type="math/tex; mode=display">
(D5E4C)_{16} = (1101-0101-1110-0100-1100)_2</script><p>D.将二进制1001101110011110110101转换为十六进制。</p>
<script type="math/tex; mode=display">
(10-0110-1110-0111-1011-0101)_2 =(26E7B5)_{16}</script><span id="more"></span>
<h2 id="练习题2-2-填写下表中的空白项-给出2的不同次幂的二进制和十六进制表示‥"><a href="#练习题2-2-填写下表中的空白项-给出2的不同次幂的二进制和十六进制表示‥" class="headerlink" title="练习题2.2 填写下表中的空白项,给出2的不同次幂的二进制和十六进制表示‥"></a>练习题2.2 填写下表中的空白项,给出2的不同次幂的二进制和十六进制表示‥</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221010210405379.png" alt="image-20221010210405379"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$n$</th>
<th style="text-align:center">$2^n$(十进制)</th>
<th style="text-align:center">$2^n$(十六进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">512</td>
<td style="text-align:center">0x200</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">524288</td>
<td style="text-align:center">0x80000</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">16384</td>
<td style="text-align:center">0x4000</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">65536</td>
<td style="text-align:center">0x10000</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">131072</td>
<td style="text-align:center">0x20000</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">32</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">128</td>
<td style="text-align:center">0x80</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-3-一个字节可以用两个十六进制数字来表示。填写下表中缺失的项-给出-不同字节模式的十进制、二进制和十六进制值"><a href="#练习题2-3-一个字节可以用两个十六进制数字来表示。填写下表中缺失的项-给出-不同字节模式的十进制、二进制和十六进制值" class="headerlink" title="练习题2.3 一个字节可以用两个十六进制数字来表示。填写下表中缺失的项,给出 不同字节模式的十进制、二进制和十六进制值:"></a>练习题2.3 一个字节可以用两个十六进制数字来表示。填写下表中缺失的项,给出 不同字节模式的十进制、二进制和十六进制值:</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221010212306528.png" alt="image-20221010212306528"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">十进制</th>
<th style="text-align:center">二进制</th>
<th style="text-align:center">十六进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0000 0000</td>
<td style="text-align:center">0x00</td>
</tr>
<tr>
<td style="text-align:center">167</td>
<td style="text-align:center">1010 0111</td>
<td style="text-align:center">0xA7</td>
</tr>
<tr>
<td style="text-align:center">62</td>
<td style="text-align:center">0011 1110</td>
<td style="text-align:center">0x3E</td>
</tr>
<tr>
<td style="text-align:center">188</td>
<td style="text-align:center">1011 1100</td>
<td style="text-align:center">0xBC</td>
</tr>
<tr>
<td style="text-align:center">55</td>
<td style="text-align:center">0011 0111</td>
<td style="text-align:center">0x37</td>
</tr>
<tr>
<td style="text-align:center">136</td>
<td style="text-align:center">1000 1000</td>
<td style="text-align:center">0x88</td>
</tr>
<tr>
<td style="text-align:center">243</td>
<td style="text-align:center">1111 0011</td>
<td style="text-align:center">0xF3</td>
</tr>
<tr>
<td style="text-align:center">82</td>
<td style="text-align:center">0101 0010</td>
<td style="text-align:center">0x52</td>
</tr>
<tr>
<td style="text-align:center">172</td>
<td style="text-align:center">1010 1100</td>
<td style="text-align:center">0xAC</td>
</tr>
<tr>
<td style="text-align:center">231</td>
<td style="text-align:center">1110 0111</td>
<td style="text-align:center">0xE7</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-4-不将数字转换为十进制或者二进制-试着解答下面的算术题-答案要用-十六进制表示。提示-只要将执行十进制加法和减法所使用的方法改成以16为基数。"><a href="#练习题2-4-不将数字转换为十进制或者二进制-试着解答下面的算术题-答案要用-十六进制表示。提示-只要将执行十进制加法和减法所使用的方法改成以16为基数。" class="headerlink" title="练习题2.4 不将数字转换为十进制或者二进制,试着解答下面的算术题,答案要用 十六进制表示。提示:只要将执行十进制加法和减法所使用的方法改成以16为基数。"></a>练习题2.4 不将数字转换为十进制或者二进制,试着解答下面的算术题,答案要用 十六进制表示。提示:只要将执行十进制加法和减法所使用的方法改成以16为基数。</h2><p>A. 0x503C + 0x8 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x503C + 0x8 = 0x5044</span><br></pre></td></tr></table></figure>
<p>B. 0x503C - 0x40</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x503C - 0x40 = 0x4F9C</span><br></pre></td></tr></table></figure>
<p>C. 0x503C + 64</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x503C + 64 = 0x507c</span><br></pre></td></tr></table></figure>
<p>D. 0x50EA - 0x503C </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x50EA - 0x503C = 0xAF</span><br></pre></td></tr></table></figure>
<h2 id="练习题2-5-思考下面对show上ytes的三次调用"><a href="#练习题2-5-思考下面对show上ytes的三次调用" class="headerlink" title="练习题2.5 思考下面对show上ytes的三次调用:"></a>练习题2.5 思考下面对show上ytes的三次调用:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(byte_pointer start, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_int</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_float</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_pointer</span><span class="params">(<span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">0x87654321</span>;</span><br><span class="line">byte_pointer valp = (byte_pointer) &amp;val;</span><br><span class="line">show_bytes(valp, <span class="number">1</span>);    <span class="comment">// A.</span></span><br><span class="line">show_bytes(valp, <span class="number">2</span>);    <span class="comment">// B.</span></span><br><span class="line">show_bytes(valp, <span class="number">3</span>);    <span class="comment">// C.</span></span><br></pre></td></tr></table></figure>
<p>指出在小端法机器和大端法机器上,每次调用的输出值。</p>
<p>在小端机上调用了一下，大端机只能使用模拟器目前不打算调用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221011112529883.png" alt="image-20221011112529883"></p>
<h2 id="练习题2-6-使用show-int和show-float-我们确定整数3510593的十六进制表示为0x00359141-而浮点数3510593-0的十六进制表示为0x4A564504。"><a href="#练习题2-6-使用show-int和show-float-我们确定整数3510593的十六进制表示为0x00359141-而浮点数3510593-0的十六进制表示为0x4A564504。" class="headerlink" title="练习题2.6 使用show_int和show_float,我们确定整数3510593的十六进制表示为0x00359141,而浮点数3510593.0的十六进制表示为0x4A564504。"></a>练习题2.6 使用show_int和show_float,我们确定整数3510593的十六进制表示为0x00359141,而浮点数3510593.0的十六进制表示为0x4A564504。</h2><p>A.写出这两个十六进制值的二进制表示</p>
<p>0x00359141    0000 0000 0011 0101 1001 0001 0100 0001</p>
<p>0x4A564504    0100 1010 0101 0110 0100 0101 0000 0100</p>
<p>B.移动这两个二进制串的相对位置,使得它们相匹配的位数最多。有多少位相匹配呢? </p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221011142944151.png" alt="image-20221011142944151"></p>
<p>可以看到移动两位后，最多11位相匹配。</p>
<p>C.串中的什么部分不相匹配?</p>
<p>这个跟浮点数的存储有关，后续应该会学习到。</p>
<h2 id="练习题2-7-下面对show-bytes的调用将输出什么结果"><a href="#练习题2-7-下面对show-bytes的调用将输出什么结果" class="headerlink" title="练习题2.7 下面对show_bytes的调用将输出什么结果?"></a>练习题2.7 下面对show_bytes的调用将输出什么结果?</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">show_bytes((byte_pointer)s,<span class="built_in">strlen</span>(s));</span><br></pre></td></tr></table></figure>
<p>注意字母<code>a</code>~<code>z</code>的ASCII码为 0x61~0x7A</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221011193359526.png" alt="image-20221011193359526"></p>
<h2 id="练习题2-8-填写下表-给出位向量的布尔运算的求值结果。"><a href="#练习题2-8-填写下表-给出位向量的布尔运算的求值结果。" class="headerlink" title="练习题2.8 填写下表,给出位向量的布尔运算的求值结果。"></a>练习题2.8 填写下表,给出位向量的布尔运算的求值结果。</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221011194044827.png" alt="image-20221011194044827"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">[01101001]</td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">[01010101]</td>
</tr>
<tr>
<td style="text-align:center">~a</td>
<td style="text-align:center">[10010110]</td>
</tr>
<tr>
<td style="text-align:center">~b</td>
<td style="text-align:center">[10101010]</td>
</tr>
<tr>
<td style="text-align:center">a&amp;b</td>
<td style="text-align:center">[01000001]</td>
</tr>
<tr>
<td style="text-align:center">a\</td>
<td style="text-align:center">b</td>
<td>[01111101]</td>
</tr>
<tr>
<td style="text-align:center">a^b</td>
<td style="text-align:center">[00111100]</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-9"><a href="#练习题2-9" class="headerlink" title="练习题2.9"></a>练习题2.9</h2><p>通过混合三种不同颜色的光(红色、绿色和蓝色),计算机可以在视频屏 幕或者液晶显示器上产生彩色的画面。设想一种简单的方法,使用三种不同颜色的 光,每种光都能打开或关闭,投射到玻璃屏幕上,如图所示:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221011194841837.png" alt="image-20221011194841837"></p>
<p>那么基于光源R(红)、 G(绿)、 B(蓝)的关闭(0)或打开(1),我们就能够创建8 种不同的颜色:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221011195958415.png" alt="image-20221011195958415"></p>
<p>这些颜色中的每一种都能用一个长度为3的位向量来表示,我们可以对它们进行布尔运算。</p>
<p>A.一种颜色的补是通过关掉打开的光源,且打开关闭的光源而形成的。那么上面列 出的8种颜色每一种的补是什么?</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">原颜色</th>
<th style="text-align:center">代码</th>
<th style="text-align:center">补码</th>
<th style="text-align:center">补颜色</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">黑色</td>
<td style="text-align:center">000</td>
<td style="text-align:center">111</td>
<td style="text-align:center">白色</td>
</tr>
<tr>
<td style="text-align:center">蓝色</td>
<td style="text-align:center">001</td>
<td style="text-align:center">110</td>
<td style="text-align:center">黄色</td>
</tr>
<tr>
<td style="text-align:center">绿色</td>
<td style="text-align:center">010</td>
<td style="text-align:center">101</td>
<td style="text-align:center">红绿色</td>
</tr>
<tr>
<td style="text-align:center">蓝绿色</td>
<td style="text-align:center">011</td>
<td style="text-align:center">100</td>
<td style="text-align:center">红色</td>
</tr>
<tr>
<td style="text-align:center">红色</td>
<td style="text-align:center">100</td>
<td style="text-align:center">111</td>
<td style="text-align:center">蓝绿色</td>
</tr>
<tr>
<td style="text-align:center">红紫色</td>
<td style="text-align:center">101</td>
<td style="text-align:center">010</td>
<td style="text-align:center">绿色</td>
</tr>
<tr>
<td style="text-align:center">黄色</td>
<td style="text-align:center">110</td>
<td style="text-align:center">001</td>
<td style="text-align:center">蓝色</td>
</tr>
<tr>
<td style="text-align:center">白色</td>
<td style="text-align:center">111</td>
<td style="text-align:center">000</td>
<td style="text-align:center">黑色</td>
</tr>
</tbody>
</table>
</div>
<p>B.描述下列颜色应用布尔运算的结果:</p>
<p>蓝色 | 绿色 =  (001 | 010) = 011 = 蓝绿色</p>
<p>黄色 &amp; 蓝绿色 =  (110 &amp; 011) = 010 = 绿色</p>
<p>红色 ^ 红紫色 =  (100 ^ 101) = 001 = 蓝色</p>
<h2 id="练习题2-10-对于任一位向量a-有a-a-0应用这一属性-考虑下面的程序"><a href="#练习题2-10-对于任一位向量a-有a-a-0应用这一属性-考虑下面的程序" class="headerlink" title="练习题2.10 对于任一位向量a,有a^a=0应用这一属性,考虑下面的程序:"></a>练习题2.10 对于任一位向量a,有a^a=0应用这一属性,考虑下面的程序:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inplace_swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    *y = *x ^ *y; <span class="comment">/* Step 1 */</span></span><br><span class="line">    *x = *x ^ *y; <span class="comment">/* Step 2 */</span></span><br><span class="line">    *y = *x ^ *y; <span class="comment">/* Step 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如程序名字所暗示的那样,我们认为这个过程的效果是交换指针变量x和y所指向 的存储位置处存放的值。注意,与通常的交换两个数值的技术不一样,当移动一个值 时,我们不需要第三个位置来临时存储另一个值。这种交换方式并没有性能上的优 势,它仅仅是一个智力游残。</p>
<p>以指针x和y指向的位置存储的值分别是α和6作为开始,填写下表,给出在程序的 每一步之后,存储在这两个位置中的值。利用^的属性证明达到了所希望的效果。回 想一下,每个元素就是它自身的加法逆元(a^a=0)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221011201114181.png" alt="image-20221011201114181"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">步骤</th>
<th style="text-align:center">*x</th>
<th style="text-align:center">*y</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
</tr>
<tr>
<td style="text-align:center">第1步</td>
<td style="text-align:center">a</td>
<td style="text-align:center">a^b</td>
</tr>
<tr>
<td style="text-align:center">第2步</td>
<td style="text-align:center">a\^a\^b=b</td>
<td style="text-align:center">a^b</td>
</tr>
<tr>
<td style="text-align:center">第3步</td>
<td style="text-align:center">b</td>
<td style="text-align:center">b\^a\^b=a</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-11在练习题2-10中的inplace-swap函数的基础上-你决定写一段代码-实现将一个数组中的元素头尾两端依次对调。你写出下面这个函数"><a href="#练习题2-11在练习题2-10中的inplace-swap函数的基础上-你决定写一段代码-实现将一个数组中的元素头尾两端依次对调。你写出下面这个函数" class="headerlink" title="练习题2.11在练习题2.10中的inplace_swap函数的基础上,你决定写一段代码, 实现将一个数组中的元素头尾两端依次对调。你写出下面这个函数:"></a>练习题2.11在练习题2.10中的inplace_swap函数的基础上,你决定写一段代码, 实现将一个数组中的元素头尾两端依次对调。你写出下面这个函数:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse_array</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> first, last;</span><br><span class="line">    <span class="keyword">for</span> (first = <span class="number">0</span>, last = cnt - <span class="number">1</span>; first &lt;= last; first++, last--)</span><br><span class="line">    &#123;</span><br><span class="line">        inplace_swap(&amp;a[first], &amp;a[last]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你对一个包含元素1、 2、 3和4的数纽使用这个函数时,正如预期的那样,现在数 纽的元素变成了4、3、2和1。不过,当你对一个包含元素1、2、3、4和5的数纽使 用这个函数时,你会很惊奇地看到得到数字的元素为5、 4、0、 2和1。实际上,你会 发现这段代码对所有偶数长度的数组都能正确地工作,但是当数组的长度为奇数时, 它就会把中间的元素设置成0。</p>
<p>A.对于一个长度为奇数的数纽,长度cnt=2k+1,函数<code>reverse_array</code>最后一次循环中,变量first和Iast的值分别是什么?</p>
<p>最后一次循环时，变量first = a[k]，last = a[k]。</p>
<p>B.为什么这时调用函数<code>inplace_swap</code>会将数组元素设置为0?</p>
<p>因为最后一次循环时，变量first = a[k]，last = a[k]。他们之间进行<code>inplace_swap</code></p>
<p>第一步 <em>y = </em>x ^ *y; 替换之后a[k] = a[k] ^ a[k] =0;</p>
<p>第二步<em>x = </em>x ^ *y; 替换之后a[k] = 0 ^ 0 =0;</p>
<p>第二步<em>y = </em>x ^ *y; 替换之后a[k] = 0 ^ 0 =0;</p>
<p>C.对<code>reverse_array</code>的代码做哪些筒单改动就能消除这个问题?</p>
<p>只需要将<code>first &lt;= last</code>改为<code>first &lt; last</code>即可</p>
<h2 id="练习题2-12-对于下面的值-写出变量x的C语言表达式。"><a href="#练习题2-12-对于下面的值-写出变量x的C语言表达式。" class="headerlink" title="练习题2.12 对于下面的值,写出变量x的C语言表达式。"></a>练习题2.12 对于下面的值,写出变量x的C语言表达式。</h2><p>你的代码应该对任何字 长$w\geq8$都能工作。我们给出了当x=0x87654321以及$w=32$时表达式求值的结果, 仅供参考。</p>
<p>A. x的最低有效字节,其他位均置为0。[0x00000021]。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x &amp; 0xFF</span><br></pre></td></tr></table></figure>
<p>B.除了x的最低有效字节外,其他的位都取补,最低有效字节保持不变。 [0x789ABC21]。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~(x ^ 0xFF)或者x ^ (~0xFF)</span><br></pre></td></tr></table></figure>
<p>C.x的最低有效字节设置成全1，其他字节都保持不变。[0x876543FF]。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x | 0xFF</span><br></pre></td></tr></table></figure>
<h2 id="练习题2-13"><a href="#练习题2-13" class="headerlink" title="练习题2.13"></a>练习题2.13</h2><p>从20世纪70年代末到80年代末，Digital Equipment的 VAX计算机是一种非常流行的机型。它没有布尔运算AND 和OR指令，只有bis(位设置)和bic(位清除)这两种指令。两种指令的输入都是一个数据字x和一个掩码字m。它们生成一个结果z，z是由根据掩码m的位来修改x的位得到的。使用bis 指令，这种修改就是在m为1的每个位置上，将z对应的位设置为1。使用bic指令，这种修改就是在m为1的每个位置，将z对应的位设置为0。</p>
<p>为了看清楚这些运算与C语言位级运算的关系，假设我们有两个函数bis和 bic来实现位设置和位清除操作。只想用这两个函数，而不使用任何其他C语言运算，来实现按位|和~运算。填写下列代码中缺失的代码。提示:写出bis和 bic运算的C语言表达式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bis</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> m)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bic</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> m)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bool_or</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = bis(x, y);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bool_xor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = bis(bic(x, y), bic(y, x));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题2-14-假设x和y的字节值分别为0x66和0x39。填写下表，指明各个C表达式的字节值。"><a href="#练习题2-14-假设x和y的字节值分别为0x66和0x39。填写下表，指明各个C表达式的字节值。" class="headerlink" title="练习题2.14 假设x和y的字节值分别为0x66和0x39。填写下表，指明各个C表达式的字节值。"></a>练习题2.14 假设x和y的字节值分别为0x66和0x39。填写下表，指明各个C表达式的字节值。</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221013122941220.png" alt="image-20221013122941220"></p>
<p>0x66 = 0110 0110</p>
<p>0x39 = 0011 1001</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x &amp; y</td>
<td style="text-align:center">0110 0110 &amp; 0011 1001 = 0010 0000 = 0x20</td>
</tr>
<tr>
<td style="text-align:center">x \</td>
<td style="text-align:center">y</td>
<td>0110 0110 \</td>
<td>0011 1001 = 0111 1111 = 0x7F</td>
</tr>
<tr>
<td style="text-align:center">~x \</td>
<td style="text-align:center">~y</td>
<td>~0110 0110 \</td>
<td>~0011 1001 = 1001 1001 \</td>
<td>1100 0110 = 1101 1111 = 0xDF</td>
</tr>
<tr>
<td style="text-align:center">x &amp; !y</td>
<td style="text-align:center">0110 0110 &amp; !0011 1001 = 0110 0110 &amp; 0000 0000 = 0x00</td>
</tr>
<tr>
<td style="text-align:center">x &amp;&amp; y</td>
<td style="text-align:center">0x01</td>
</tr>
<tr>
<td style="text-align:center">x \</td>
<td style="text-align:center">\</td>
<td>y</td>
<td>0x01</td>
</tr>
<tr>
<td style="text-align:center">!x \</td>
<td style="text-align:center">\</td>
<td>!y</td>
<td>0x00</td>
</tr>
<tr>
<td style="text-align:center">x &amp;&amp; ~y</td>
<td style="text-align:center">0x01</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-15︰只使用位级和逻辑运算，编写一个C表达式，它等价于x-y。换句云说，当x和y相等时它将返回1，否则就返回0。"><a href="#练习题2-15︰只使用位级和逻辑运算，编写一个C表达式，它等价于x-y。换句云说，当x和y相等时它将返回1，否则就返回0。" class="headerlink" title="练习题2.15︰只使用位级和逻辑运算，编写一个C表达式，它等价于x= =y。换句云说，当x和y相等时它将返回1，否则就返回0。"></a>练习题2.15︰只使用位级和逻辑运算，编写一个C表达式，它等价于x= =y。换句云说，当x和y相等时它将返回1，否则就返回0。</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!(x^y)</span><br></pre></td></tr></table></figure>
<h2 id="练习题2-16"><a href="#练习题2-16" class="headerlink" title="练习题2.16"></a>练习题2.16</h2><p>填写下表，展示不同移位运算对单字节数的影响。思考移位运算的最好方式是使用二进制表示。将最初的值转换为二进制，执行移位运算，然后再转换回十六进制。每个答案都应该是8个二进制数字或者2个十六进制数字。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221013124953580.png" alt="image-20221013124953580"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center"></th>
<th style="text-align:center">x&lt;&lt;3</th>
<th style="text-align:center"></th>
<th style="text-align:center">x&gt;&gt;2(逻辑)</th>
<th style="text-align:center"></th>
<th style="text-align:center">x&gt;&gt;2(算术)</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">十六进制</td>
<td style="text-align:center">二进制</td>
<td style="text-align:center">二进制</td>
<td style="text-align:center">十六进制</td>
<td style="text-align:center">二进制</td>
<td style="text-align:center">十六进制</td>
<td style="text-align:center">二进制</td>
<td style="text-align:center">十六进制</td>
</tr>
<tr>
<td style="text-align:center">0xC3</td>
<td style="text-align:center">1100 0011</td>
<td style="text-align:center">0001 1000</td>
<td style="text-align:center">0x18</td>
<td style="text-align:center">0011 0000</td>
<td style="text-align:center">0x30</td>
<td style="text-align:center">1111 0000</td>
<td style="text-align:center">0xF0</td>
</tr>
<tr>
<td style="text-align:center">0x75</td>
<td style="text-align:center">0111 0101</td>
<td style="text-align:center">1010 1000</td>
<td style="text-align:center">0xA8</td>
<td style="text-align:center">0001 1101</td>
<td style="text-align:center">0x1D</td>
<td style="text-align:center">0001 1101</td>
<td style="text-align:center">0x1D</td>
</tr>
<tr>
<td style="text-align:center">0x87</td>
<td style="text-align:center">1000 0111</td>
<td style="text-align:center">0011 1000</td>
<td style="text-align:center">0x38</td>
<td style="text-align:center">0010 0001</td>
<td style="text-align:center">0x21</td>
<td style="text-align:center">1110 0001</td>
<td style="text-align:center">0xE1</td>
</tr>
<tr>
<td style="text-align:center">0x66</td>
<td style="text-align:center">0110 0110</td>
<td style="text-align:center">0011 0000</td>
<td style="text-align:center">0x30</td>
<td style="text-align:center">0001 1001</td>
<td style="text-align:center">0x19</td>
<td style="text-align:center">0001 1001</td>
<td style="text-align:center">0x19</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-17"><a href="#练习题2-17" class="headerlink" title="练习题2.17"></a>练习题2.17</h2><p>假设w=4（字长为4），我们能给每个可能的十六进制数字赋予一个数值，假设用一个无符号或者补码表示。请根据这些表示，通过写出等式(2.1)和等式(2.3)所示的求和公式中的2的非零次幂，填写下表:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221015120400005.png" alt="image-20221015120400005"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center"></th>
<th style="text-align:center">无符号(B2U(x))</th>
<th style="text-align:center">补码(B2T(x))</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">十六进制</td>
<td style="text-align:center">二进制</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">0xE</td>
<td style="text-align:center">1110</td>
<td style="text-align:center">14</td>
<td style="text-align:center">-2</td>
</tr>
<tr>
<td style="text-align:center">0x0</td>
<td style="text-align:center">0000</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0x5</td>
<td style="text-align:center">0101</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">0x8</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-8</td>
</tr>
<tr>
<td style="text-align:center">0xD</td>
<td style="text-align:center">1101</td>
<td style="text-align:center">13</td>
<td style="text-align:center">-3</td>
</tr>
<tr>
<td style="text-align:center">0xF</td>
<td style="text-align:center">1111</td>
<td style="text-align:center">15</td>
<td style="text-align:center">-1</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-18"><a href="#练习题2-18" class="headerlink" title="练习题2.18"></a>练习题2.18</h2><p>在第3章中，我们将看到由反汇编器生成的列表，反汇编器是一种将可执行程序文件转换回可读性更好的ASCII码形式的程序。这些文件包含许多十六进制数字，都是用典型的补码形式来表示这些值。能够认识这些数字并理解它们的意义(例如它们是正数还是负数)，是一项重要的技巧。</p>
<p>在下面的列表中，对于标号为A～I(标记在右边)的那些行，将指令名(sub、mov和add)右边显示的(32位补码形式表示的)十六进制值转换为等价的十进制值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221015122226429.png" alt="image-20221015122226429"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">32位补码</th>
<th style="text-align:center">十进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x2e0</td>
<td style="text-align:center">736</td>
</tr>
<tr>
<td style="text-align:center">0x58</td>
<td style="text-align:center">88</td>
</tr>
<tr>
<td style="text-align:center">0x28</td>
<td style="text-align:center">40</td>
</tr>
<tr>
<td style="text-align:center">0x30</td>
<td style="text-align:center">48</td>
</tr>
<tr>
<td style="text-align:center">0x78</td>
<td style="text-align:center">120</td>
</tr>
<tr>
<td style="text-align:center">0x88</td>
<td style="text-align:center">136</td>
</tr>
<tr>
<td style="text-align:center">0x1f8</td>
<td style="text-align:center">504</td>
</tr>
<tr>
<td style="text-align:center">0x8</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">0xc0</td>
<td style="text-align:center">192</td>
</tr>
<tr>
<td style="text-align:center">0x48</td>
<td style="text-align:center">72</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-19-利用你解答练习题2-17时填写的表格，填写下列描述函数T2U。的表格。"><a href="#练习题2-19-利用你解答练习题2-17时填写的表格，填写下列描述函数T2U。的表格。" class="headerlink" title="练习题2.19 利用你解答练习题2.17时填写的表格，填写下列描述函数T2U。的表格。"></a>练习题2.19 利用你解答练习题2.17时填写的表格，填写下列描述函数T2U。的表格。</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221015132301591.png" alt="image-20221015132301591"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center">T2U(x)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-8</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">-3</td>
<td style="text-align:center">13</td>
</tr>
<tr>
<td style="text-align:center">-2</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">-1</td>
<td style="text-align:center">15</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-20"><a href="#练习题2-20" class="headerlink" title="练习题2.20"></a>练习题2.20</h2><p>请说明等式(2.5)是如何应用到解答练习题2.19时生成的表格中的各项的。反过来看，我们希望推导出一个无符号数$u$和与之对应的有符号数$U2T_w(u)$之间的关系:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221019105712222.png" alt="image-20221019105712222"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221019110140819.png" alt="image-20221019110140819"></p>
<h2 id="练习题2-21-假设在采用补码运算的32位机器上对这些表达式求值，按照图2-19的格式填写下表，描述强制类型转换和关系运算的结果。"><a href="#练习题2-21-假设在采用补码运算的32位机器上对这些表达式求值，按照图2-19的格式填写下表，描述强制类型转换和关系运算的结果。" class="headerlink" title="练习题2.21 假设在采用补码运算的32位机器上对这些表达式求值，按照图2-19的格式填写下表，描述强制类型转换和关系运算的结果。"></a>练习题2.21 假设在采用补码运算的32位机器上对这些表达式求值，按照图2-19的格式填写下表，描述强制类型转换和关系运算的结果。</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221015134013727.png" alt="image-20221015134013727"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">求值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-2147483647-1==2147483648U</td>
<td style="text-align:center">无符号</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">-2147483647-1&lt;2147482647</td>
<td style="text-align:center">有符号</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">-2147483647-1U &lt; 2147483647</td>
<td style="text-align:center">无符号</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">-2147483647-1&lt;-2147482647</td>
<td style="text-align:center">有符号</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">-2147483647-1U&lt;-2147482647</td>
<td style="text-align:center">无符号</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-22-通过应用等式-2-3-，表明下面每个位向量都是-5的补码表示。"><a href="#练习题2-22-通过应用等式-2-3-，表明下面每个位向量都是-5的补码表示。" class="headerlink" title="练习题2.22 通过应用等式(2.3)，表明下面每个位向量都是-5的补码表示。"></a>练习题2.22 通过应用等式(2.3)，表明下面每个位向量都是-5的补码表示。</h2><p>A.[1011]</p>
<p>1011 =  -2^3+2+1 = -5</p>
<p>B.[11011]</p>
<p>11011 = -2\^4+2\^3+2+1 = -5</p>
<p>C.[111011]</p>
<p>111011 = -2\^5+2\^4+2\^3+2+1 = -5</p>
<h2 id="练习题2-23考虑下面的C函数"><a href="#练习题2-23考虑下面的C函数" class="headerlink" title="练习题2.23考虑下面的C函数"></a>练习题2.23考虑下面的C函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">funl</span><span class="params">(<span class="type">unsigned</span> word)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)((word &lt;&lt; <span class="number">24</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun2</span><span class="params">(<span class="type">unsigned</span> word)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">int</span>)word &lt;&lt; <span class="number">24</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设在一个采用补码运算的机器上以32位程序来执行这些函数。还假设有符号数值的右移是算术右移，而无符号数值的右移是逻辑右移。</p>
<p>A.填写下表，说明这些函数对几个示例参数的结果。你会发现用十六进制表示来做会更方便，只要记住十六进制数字8到F的最高有效位等于1。</p>
<p>写下如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun1</span><span class="params">(<span class="type">unsigned</span> word)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)((word &lt;&lt; <span class="number">24</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun2</span><span class="params">(<span class="type">unsigned</span> word)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">int</span>)(word &lt;&lt; <span class="number">24</span>)) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a1 = <span class="number">0x00000076</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a2 = <span class="number">0x87654321</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a3 = <span class="number">0x000000C9</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a4 = <span class="number">0xEDCBA987</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1(a1) %x,&quot;</span>, fun1(a1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun2(a1) %x\n&quot;</span>, fun2(a1));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1(a2) %x,&quot;</span>, fun1(a2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun2(a2) %x\n&quot;</span>, fun2(a2));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1(a3) %x,&quot;</span>, fun1(a3));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun2(a3) %x\n&quot;</span>, fun2(a3));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1(a4) %x,&quot;</span>, fun1(a4));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun2(a4) %x\n&quot;</span>, fun2(a4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221015213023031.png" alt="image-20221015213023031"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">w</th>
<th style="text-align:center">fun1(w)</th>
<th style="text-align:center">fun2(w)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x00000076</td>
<td style="text-align:center">0x00000076</td>
<td style="text-align:center">0x00000076</td>
</tr>
<tr>
<td style="text-align:center">0x87654321</td>
<td style="text-align:center">0x00000021</td>
<td style="text-align:center">0x00000021</td>
</tr>
<tr>
<td style="text-align:center">0x000000c9</td>
<td style="text-align:center">0x000000C9</td>
<td style="text-align:center">0xffffffC9</td>
</tr>
<tr>
<td style="text-align:center">0xEDCBA987</td>
<td style="text-align:center">0x00000087</td>
<td style="text-align:center">0xffffff87</td>
</tr>
</tbody>
</table>
</div>
<p>B.用语言来描述这些函数执行的有用的计算。</p>
<h2 id="练习题2-24-假设将一个4位数值-用十六进制数字0～F表示-截断到一个3位数-用十六进制数字0～7表示-。填写下表，根据那些位模式的无符号和补码解释，明这种截断对某些情况的结果。"><a href="#练习题2-24-假设将一个4位数值-用十六进制数字0～F表示-截断到一个3位数-用十六进制数字0～7表示-。填写下表，根据那些位模式的无符号和补码解释，明这种截断对某些情况的结果。" class="headerlink" title="练习题2.24 假设将一个4位数值(用十六进制数字0～F表示)截断到一个3位数(用十六进制数字0～7表示)。填写下表，根据那些位模式的无符号和补码解释，明这种截断对某些情况的结果。"></a>练习题2.24 假设将一个4位数值(用十六进制数字0～F表示)截断到一个3位数(用十六进制数字0～7表示)。填写下表，根据那些位模式的无符号和补码解释，明这种截断对某些情况的结果。</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221015213952945.png" alt="image-20221015213952945"></p>
<p>解释如何将等式(2.9)和等式(2.10)应用到这些示例上。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">十六进制</th>
<th style="text-align:center"></th>
<th style="text-align:center">无符号</th>
<th style="text-align:center"></th>
<th style="text-align:center">补码</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">原始值</td>
<td style="text-align:center">截断值</td>
<td style="text-align:center">原始值</td>
<td style="text-align:center">截断值</td>
<td style="text-align:center">原始值</td>
<td style="text-align:center">截断值</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">1</td>
<td style="text-align:center">9</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-7</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">3</td>
<td style="text-align:center">11</td>
<td style="text-align:center">3</td>
<td style="text-align:center">-5</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">7</td>
<td style="text-align:center">15</td>
<td style="text-align:center">7</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-25考虑下列代码，这段代码试图计算数组a中所有元素的和，其中元素的数量由参数length-给出。"><a href="#练习题2-25考虑下列代码，这段代码试图计算数组a中所有元素的和，其中元素的数量由参数length-给出。" class="headerlink" title="练习题2.25考虑下列代码，这段代码试图计算数组a中所有元素的和，其中元素的数量由参数length 给出。"></a>练习题2.25考虑下列代码，这段代码试图计算数组a中所有元素的和，其中元素的数量由参数length 给出。</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">sum_elements</span><span class="params">(<span class="type">float</span> a[], <span class="type">unsigned</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当参数length等于0时，运行这段代码应该返回0.0。但实际上，运行时会遇到一个内存错误。请解释为什么会发生这样的情况，并且说明如何修改代码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221015220734092.png" alt="image-20221015220734092"></p>
<p>原因是length的类型是unsigned 但是1的类型是是int，所以计算转为无符号数计算，length - 1=length +（- 1），现在的问题是-1的无符号数是多少-1的十六进制无符号数为0xFFFFFFFF换算之后是4294967295,所以代码就出现了异常,for循环进去之后数组下标越界。只需要将unsigned 改为int即可。</p>
<h2 id="练习题2-26现在给你一个任务，写一个函数用来判定一个字符串是否比另一个更长。前提是你要用字符串库函数strlen，它的声明如下"><a href="#练习题2-26现在给你一个任务，写一个函数用来判定一个字符串是否比另一个更长。前提是你要用字符串库函数strlen，它的声明如下" class="headerlink" title="练习题2.26现在给你一个任务，写一个函数用来判定一个字符串是否比另一个更长。前提是你要用字符串库函数strlen，它的声明如下:"></a>练习题2.26现在给你一个任务，写一个函数用来判定一个字符串是否比另一个更长。前提是你要用字符串库函数strlen，它的声明如下:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strlonger</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(s) - <span class="built_in">strlen</span>(t) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你在一些示例上测试这个函数时，一切似乎都是正确的。进一步研究发现在头文件stdio.h中数据类型size_t是定义成unsigned int的。</p>
<p>A.在什么情况下，这个函数会产生不正确的结果？</p>
<p>当s字符串的长度strlen1小于t字符串的长度strlen2时。</p>
<p>B.解释为什么会出现这样不正确的结果?</p>
<p>当s字符串的长度strlen1小于t字符串的长度strlen2时，strlen1-strlen2应当是负数，但是size_t是无符号，根据无符号数的方式解释器补码，这个负数是一个很大的正数。然后正数是大于0，不等式成立，函数就会返回逻辑True。</p>
<p>C.说明如何修改这段代码好让它能可靠地工作。</p>
<p>修改后的表达式：return strlen(s)&gt;strlen(t);</p>
<h2 id="练习题2-27-写出一个具有如下原型的函数"><a href="#练习题2-27-写出一个具有如下原型的函数" class="headerlink" title="练习题2.27 写出一个具有如下原型的函数:"></a>练习题2.27 写出一个具有如下原型的函数:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uadd_ok</span><span class="params">(<span class="type">unsigned</span> x,<span class="type">unsigned</span> y)</span> </span><br></pre></td></tr></table></figure>
<p>如果参数x和y相加不会产生溢出，这个函数就返回1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uadd_ok</span><span class="params">(<span class="type">unsigned</span> x,<span class="type">unsigned</span> y)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &gt;= x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题2-28我们能用一个十六进制数字来表示长度w-4的位模式。对于这些数字的无符号解释，使用等式-2-12-填写下表，给出所示数字的无符号加法逆元的位表示-用十六进制形式-。"><a href="#练习题2-28我们能用一个十六进制数字来表示长度w-4的位模式。对于这些数字的无符号解释，使用等式-2-12-填写下表，给出所示数字的无符号加法逆元的位表示-用十六进制形式-。" class="headerlink" title="练习题2.28我们能用一个十六进制数字来表示长度w=4的位模式。对于这些数字的无符号解释，使用等式(2.12)填写下表，给出所示数字的无符号加法逆元的位表示(用十六进制形式)。"></a>练习题2.28我们能用一个十六进制数字来表示长度w=4的位模式。对于这些数字的无符号解释，使用等式(2.12)填写下表，给出所示数字的无符号加法逆元的位表示(用十六进制形式)。</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221015222427723.png" alt="image-20221015222427723"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x$</th>
<th style="text-align:center"></th>
<th style="text-align:center">$-^u_4x$</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">十六进制</td>
<td style="text-align:center">十进制</td>
<td style="text-align:center">十六进制</td>
<td style="text-align:center">十进制</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">B</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">13</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">15</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-29按照图2-25的形式填写下表。分别列出5位参数的整数值、整数和与补码和的数值、补码和的位级表示，以及属于等式-2-13-推导中的哪种情况。"><a href="#练习题2-29按照图2-25的形式填写下表。分别列出5位参数的整数值、整数和与补码和的数值、补码和的位级表示，以及属于等式-2-13-推导中的哪种情况。" class="headerlink" title="练习题2.29按照图2-25的形式填写下表。分别列出5位参数的整数值、整数和与补码和的数值、补码和的位级表示，以及属于等式(2.13)推导中的哪种情况。"></a>练习题2.29按照图2-25的形式填写下表。分别列出5位参数的整数值、整数和与补码和的数值、补码和的位级表示，以及属于等式(2.13)推导中的哪种情况。</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221016100641498.png" alt="image-20221016100641498"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x$</th>
<th style="text-align:center">$y$</th>
<th style="text-align:center">$x+y$</th>
<th style="text-align:center">$x+^t_5y$</th>
<th style="text-align:center">情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[10100] -12</td>
<td style="text-align:center">[10001] -15</td>
<td style="text-align:center">[100101] -27</td>
<td style="text-align:center">[00101] 5</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">[11000] -8</td>
<td style="text-align:center">[11000] -8</td>
<td style="text-align:center">[110000] -16</td>
<td style="text-align:center">[10000] -16</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">[10111] -9</td>
<td style="text-align:center">[01000] 8</td>
<td style="text-align:center">[11111] -1</td>
<td style="text-align:center">[11111] -1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">[00010] 2</td>
<td style="text-align:center">[00101] 5</td>
<td style="text-align:center">[00111] 7</td>
<td style="text-align:center">[00111] 7</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">[01100] 12</td>
<td style="text-align:center">[00100] 4</td>
<td style="text-align:center">[10000] 16</td>
<td style="text-align:center">[10000] -16</td>
<td style="text-align:center">-16</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-30写出一个具有如下原型的函数"><a href="#练习题2-30写出一个具有如下原型的函数" class="headerlink" title="练习题2.30写出一个具有如下原型的函数:"></a>练习题2.30写出一个具有如下原型的函数:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Determine whether arguments can be added without overflow */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tadd_ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br></pre></td></tr></table></figure>
<p>如果参数x和y相加不会产生溢出，这个函数就返回1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tadd_ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s = x + y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> s &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> s &lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题2-31你的同事对你补码加法溢出条件的分析有些不耐烦了，他给出了一个函数tadd-ok的实现，如下所示"><a href="#练习题2-31你的同事对你补码加法溢出条件的分析有些不耐烦了，他给出了一个函数tadd-ok的实现，如下所示" class="headerlink" title="练习题2.31你的同事对你补码加法溢出条件的分析有些不耐烦了，他给出了一个函数tadd_ok的实现，如下所示:"></a>练习题2.31你的同事对你补码加法溢出条件的分析有些不耐烦了，他给出了一个函数tadd_ok的实现，如下所示:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// determin whether arguments can be added without overflow</span></span><br><span class="line"><span class="comment">// WARNING: THIS code is buggy</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tadd_ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> (sum - x == y) &amp;&amp; (sum - y == x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看了代码以后笑了。解释一下为什么。</p>
<p>因为sum-x与y是恒相等的。</p>
<p>假设int的w是4，即字长为4，并且sum=x+y发生正溢出（x&gt;0,y&gt;0,sum&lt;=0）。那么sum = x+y-16。</p>
<p>sum-x = x+y-16-x = y-16。因为字长是4，并且y&gt;0 ，所以y = y-16是恒等的。也就是说sum-x=y是永远成立的。</p>
<p>同理可以得出负溢出的情况。所以就算一簇上述代码也不会返回0，代码是错误的。</p>
<h2 id="练习题2-32你现在有个任务，编写函数tsub-ok-的代码，函数的参数是x和y，如果计算x-y不产生溢出，函数就返回1。假设你写的练习题2-30的代码如下所示"><a href="#练习题2-32你现在有个任务，编写函数tsub-ok-的代码，函数的参数是x和y，如果计算x-y不产生溢出，函数就返回1。假设你写的练习题2-30的代码如下所示" class="headerlink" title="练习题2.32你现在有个任务，编写函数tsub_ok 的代码，函数的参数是x和y，如果计算x-y不产生溢出，函数就返回1。假设你写的练习题2.30的代码如下所示:"></a>练习题2.32你现在有个任务，编写函数tsub_ok 的代码，函数的参数是x和y，如果计算x-y不产生溢出，函数就返回1。假设你写的练习题2.30的代码如下所示:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tsub_ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tadd_ok(x, -y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x和y取什么值时，这个函数会产生错误的结果?写一个该函数的正确版本(家庭作业2.74)。</p>
<p>当y = INT_MIN时会发生错误。</p>
<p>在计算机当中，y = INT_MIN时，-y = INT_MIN（会发生溢出）。所以这时tadd_ok(x, -y)会判断错误。</p>
<p>至于正确答案，如果-y = INT_MIN理解为也算溢出的话，答案应该如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tsub_ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == INT_MIN) <span class="comment">//只要y为INT_MIN，就直接返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tadd_ok(x, -y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题2-33我们可以用一个十六进制数字来表示长度w-4的位模式。根据这些数字的补码的解释，填写下表，确定所示数字的加法逆元。"><a href="#练习题2-33我们可以用一个十六进制数字来表示长度w-4的位模式。根据这些数字的补码的解释，填写下表，确定所示数字的加法逆元。" class="headerlink" title="练习题2.33我们可以用一个十六进制数字来表示长度w=4的位模式。根据这些数字的补码的解释，填写下表，确定所示数字的加法逆元。"></a>练习题2.33我们可以用一个十六进制数字来表示长度w=4的位模式。根据这些数字的补码的解释，填写下表，确定所示数字的加法逆元。</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221016115010661.png" alt="image-20221016115010661"></p>
<p>对于补码和无符号(练习题2.28)非(negation)产生的位模式，你观察到什么?</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x$</th>
<th style="text-align:center"></th>
<th style="text-align:center">$-^t_4x$</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">十六进制</td>
<td style="text-align:center">十进制</td>
<td style="text-align:center">十六进制</td>
<td style="text-align:center">十进制</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">B</td>
<td style="text-align:center">-5</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">-8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-8</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">-3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-34-按照图2-27的风格填写下表，说明不同的3位数字乘法的结果。"><a href="#练习题2-34-按照图2-27的风格填写下表，说明不同的3位数字乘法的结果。" class="headerlink" title="练习题2.34 按照图2-27的风格填写下表，说明不同的3位数字乘法的结果。"></a>练习题2.34 按照图2-27的风格填写下表，说明不同的3位数字乘法的结果。</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221016120202629.png" alt="image-20221016120202629"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">x</th>
<th style="text-align:center">y</th>
<th style="text-align:center">x*y</th>
<th style="text-align:center">截断的x*y</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无符号</td>
<td style="text-align:center">[100] 4</td>
<td style="text-align:center">[101] 5</td>
<td style="text-align:center">[001 0100] 20</td>
<td style="text-align:center">[100] 4</td>
</tr>
<tr>
<td style="text-align:center">补码</td>
<td style="text-align:center">[100] -4</td>
<td style="text-align:center">[101] -3</td>
<td style="text-align:center">[000 1100] 12</td>
<td style="text-align:center">[100] -4</td>
</tr>
<tr>
<td style="text-align:center">无符号</td>
<td style="text-align:center">[010] 2</td>
<td style="text-align:center">[111] 7</td>
<td style="text-align:center">[000 1110] 14</td>
<td style="text-align:center">[110] 6</td>
</tr>
<tr>
<td style="text-align:center">补码</td>
<td style="text-align:center">[010] 2</td>
<td style="text-align:center">[111] -1</td>
<td style="text-align:center">[111 1110] -2</td>
<td style="text-align:center">[110] -2</td>
</tr>
<tr>
<td style="text-align:center">无符号</td>
<td style="text-align:center">[110] 6</td>
<td style="text-align:center">[110] 6</td>
<td style="text-align:center">[010 0100] 36</td>
<td style="text-align:center">[100] 4</td>
</tr>
<tr>
<td style="text-align:center">补码</td>
<td style="text-align:center">[110] -2</td>
<td style="text-align:center">[110] -2</td>
<td style="text-align:center">[000 0100 ] 4</td>
<td style="text-align:center">[100] -4</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-35﹐-给你一个任务，开发函数tmult-ok-的代码，该函数会判断两个参数相乘是否会产生溢出。下面是你的解决方案"><a href="#练习题2-35﹐-给你一个任务，开发函数tmult-ok-的代码，该函数会判断两个参数相乘是否会产生溢出。下面是你的解决方案" class="headerlink" title="练习题2.35﹐ 给你一个任务，开发函数tmult ok 的代码，该函数会判断两个参数相乘是否会产生溢出。下面是你的解决方案:"></a>练习题2.35﹐ 给你一个任务，开发函数tmult ok 的代码，该函数会判断两个参数相乘是否会产生溢出。下面是你的解决方案:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Determine whether arguments can be multiplied without overflow */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmult_ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = x * y;</span><br><span class="line">    <span class="comment">/*Either x is zero, or dividing p by x gives y */</span></span><br><span class="line">    <span class="keyword">return</span> !x || p / x == y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题2-36对于数据类型int为32位的情况，设计一个版本的tmult-ok函数-练习题2-35-，使用64位精度的数据类型int64-t，而不使用除法。"><a href="#练习题2-36对于数据类型int为32位的情况，设计一个版本的tmult-ok函数-练习题2-35-，使用64位精度的数据类型int64-t，而不使用除法。" class="headerlink" title="练习题2.36对于数据类型int为32位的情况，设计一个版本的tmult_ok函数(练习题2.35)，使用64位精度的数据类型int64_t，而不使用除法。"></a>练习题2.36对于数据类型int为32位的情况，设计一个版本的tmult_ok函数(练习题2.35)，使用64位精度的数据类型int64_t，而不使用除法。</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmult_ok2</span><span class="params">(<span class="type">int32_t</span> x, <span class="type">int32_t</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int64_t</span> p = (<span class="type">int64_t</span>)x * y; <span class="comment">/*一定要先将右边手动转成 int64_t */</span></span><br><span class="line">	<span class="comment">/*printf(&quot;p=%&quot; PRId64 &quot;, q=%&quot; PRId32 &quot;\n&quot;, p,q);*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p == (<span class="type">int32_t</span>)p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="练习题2-37现在你有一个任务，当数据类型int和size-t-都是32位的，修补上述旁注给出的XDR代码中的漏洞。你决定将待分配字节数设置为数据类型uint64-t，来消除乘法溢出的可能性。你把原来对malloc函数的调用-第9行-替换如下"><a href="#练习题2-37现在你有一个任务，当数据类型int和size-t-都是32位的，修补上述旁注给出的XDR代码中的漏洞。你决定将待分配字节数设置为数据类型uint64-t，来消除乘法溢出的可能性。你把原来对malloc函数的调用-第9行-替换如下" class="headerlink" title="练习题2.37现在你有一个任务，当数据类型int和size_t 都是32位的，修补上述旁注给出的XDR代码中的漏洞。你决定将待分配字节数设置为数据类型uint64_t，来消除乘法溢出的可能性。你把原来对malloc函数的调用(第9行)替换如下:"></a>练习题2.37现在你有一个任务，当数据类型int和size_t 都是32位的，修补上述旁注给出的XDR代码中的漏洞。你决定将待分配字节数设置为数据类型uint64_t，来消除乘法溢出的可能性。你把原来对malloc函数的调用(第9行)替换如下:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> asize = ele_cnt * (<span class="type">uint64_t</span>) ele_size;</span><br><span class="line"><span class="type">void</span> *result = <span class="built_in">malloc</span>(asize);</span><br></pre></td></tr></table></figure>
<p>提醒一下，malloc 的参数类型是size_t。</p>
<p><strong>A．这段代码对原始的代码有了哪些改进?</strong></p>
<p>假设会溢出，那么虽然到了asize这步还不会溢出，因为在等式右边已经先把两个乘子强制类型转换为<code>uint64_t</code>了。<br>但是到了malloc函数时，由于此函数的原型设计，还是会被截断，传入malloc函数时发生溢出。</p>
<p><strong>B.你该如何修改代码来消除这个漏洞?</strong></p>
<h2 id="练习题2-38就像我们将在第3章中看到的那样，LEA指令能够执行形如-a-lt-lt-k-b的计算，这里k-等于0、1、2或3，而b等于0或者某个程序值。编译器常常用这条指令来执行常数因子乘法。例如，我们可以用-a-lt-lt-1-a来计算3-a。考虑b等于0或者等于a、k为任意可能的值的情况，用一条LEA指令可以计算a的哪些倍数"><a href="#练习题2-38就像我们将在第3章中看到的那样，LEA指令能够执行形如-a-lt-lt-k-b的计算，这里k-等于0、1、2或3，而b等于0或者某个程序值。编译器常常用这条指令来执行常数因子乘法。例如，我们可以用-a-lt-lt-1-a来计算3-a。考虑b等于0或者等于a、k为任意可能的值的情况，用一条LEA指令可以计算a的哪些倍数" class="headerlink" title="练习题2.38就像我们将在第3章中看到的那样，LEA指令能够执行形如(a&lt;&lt;k)+b的计算，这里k 等于0、1、2或3，而b等于0或者某个程序值。编译器常常用这条指令来执行常数因子乘法。例如，我们可以用(a&lt;&lt;1)+a来计算3*a。考虑b等于0或者等于a、k为任意可能的值的情况，用一条LEA指令可以计算a的哪些倍数?"></a>练习题2.38就像我们将在第3章中看到的那样，LEA指令能够执行形如(a&lt;&lt;k)+b的计算，这里k 等于0、1、2或3，而b等于0或者某个程序值。编译器常常用这条指令来执行常数因子乘法。例如，我们可以用(a&lt;&lt;1)+a来计算3*a。考虑b等于0或者等于a、k为任意可能的值的情况，用一条LEA指令可以计算a的哪些倍数?</h2><p>当b=0时，(a&lt;&lt;k)+b = a*2\^k，而k=0、1、2或3，所以结果为a，2a，4a，8a</p>
<p>当b=a时，(a&lt;&lt;k)+a = a(2^k+1)，而k=0、1、2或3，所以结果为2a，3a，5a，9a</p>
<p>综上：结果为a，2a，3a，4a，5a，8a，9a</p>
<h2 id="练习题2-39对于位位置n为最高有效位的情况，我们要怎样修改形式B的表达式"><a href="#练习题2-39对于位位置n为最高有效位的情况，我们要怎样修改形式B的表达式" class="headerlink" title="练习题2.39对于位位置n为最高有效位的情况，我们要怎样修改形式B的表达式?"></a>练习题2.39对于位位置n为最高有效位的情况，我们要怎样修改形式B的表达式?</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221019110357157.png" alt="image-20221019110357157"></p>
<p>这个表达式就变成了$-(x&lt;&lt;m)$。要看清这一点，设字长为$w$，$n=w—1$。形式B说我们要计算$(x&lt;&lt;w)-(x&lt;&lt;m)$，但是将x向左移动w位会得到值0。</p>
<h2 id="练习题2-40对于下面每个K的值，找出只用指定数量的运算表达x-K-的方法﹐这里我们认为加法和减法的开销相当。除了我们已经考虑过的简单的形式A和B原则-你可能会需要使用一些技巧。"><a href="#练习题2-40对于下面每个K的值，找出只用指定数量的运算表达x-K-的方法﹐这里我们认为加法和减法的开销相当。除了我们已经考虑过的简单的形式A和B原则-你可能会需要使用一些技巧。" class="headerlink" title="练习题2.40对于下面每个K的值，找出只用指定数量的运算表达x* K 的方法﹐这里我们认为加法和减法的开销相当。除了我们已经考虑过的简单的形式A和B原则,你可能会需要使用一些技巧。"></a>练习题2.40对于下面每个K的值，找出只用指定数量的运算表达x* K 的方法﹐这里我们认为加法和减法的开销相当。除了我们已经考虑过的简单的形式A和B原则,你可能会需要使用一些技巧。</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221016123931135.png" alt="image-20221016123931135"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">K</th>
<th style="text-align:center">移位</th>
<th style="text-align:center">加法/减法</th>
<th style="text-align:center">表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">(x &lt;&lt; 2) + (x&lt;&lt;1)</td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">(x &lt;&lt;5 ) - x</td>
</tr>
<tr>
<td style="text-align:center">-6</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">(x &lt;&lt; 1) - (x &lt;&lt; 3)</td>
</tr>
<tr>
<td style="text-align:center">55</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">(x &lt;&lt; 6) - (x &lt;&lt;3) - x</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-41对于一组从位位置n开始到位位置m-的连续的1-n≥m-，我们看到可以产生两种形式的代码，A和B。编译器该如何决定使用哪一种呢"><a href="#练习题2-41对于一组从位位置n开始到位位置m-的连续的1-n≥m-，我们看到可以产生两种形式的代码，A和B。编译器该如何决定使用哪一种呢" class="headerlink" title="练习题2.41对于一组从位位置n开始到位位置m 的连续的1(n≥m)，我们看到可以产生两种形式的代码，A和B。编译器该如何决定使用哪一种呢?"></a>练习题2.41对于一组从位位置n开始到位位置m 的连续的1(n≥m)，我们看到可以产生两种形式的代码，A和B。编译器该如何决定使用哪一种呢?</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221019110357157.png" alt="image-20221019110357157"></p>
<p>假设加法和减法有同样的性能，那么原则就是当n=m时，选择形式A，当n=m+1时，随便选哪种，而当n&gt;m＋1时，选择形式B。</p>
<p>当 n=m 时，A:x&lt;&lt;n , B:(x&lt;&lt;n+1)-(x&lt;&lt;n) 形式A只需要1个移位,而形式B需要 2个移位和1个减法 ，所以选择A</p>
<p>当n=m+1时，A:(x&lt;&lt;n)+(x&lt;&lt;m)，B:(x&lt;&lt;n+1)-(x&lt;&lt;n)形式A只需要2个移位一个加法，而形式B需要 2个移位和1个减法 ，所以随便选那种</p>
<p>当n&gt;m+1时，就如同上图所展示，很显然选择B</p>
<h2 id="练习题2-42写一个函数-div16，对于整数参数x返回x-16的值。你的函数不能使用除法、模运算、乘法、任何条件语句-if或者-、任何比较运算符（例如-lt-、-gt-或-或任何循环。你可以假设数据类型int是32位长，使用补码表示，而右移是算术右移。"><a href="#练习题2-42写一个函数-div16，对于整数参数x返回x-16的值。你的函数不能使用除法、模运算、乘法、任何条件语句-if或者-、任何比较运算符（例如-lt-、-gt-或-或任何循环。你可以假设数据类型int是32位长，使用补码表示，而右移是算术右移。" class="headerlink" title="练习题2.42写一个函数 div16，对于整数参数x返回x/16的值。你的函数不能使用除法、模运算、乘法、任何条件语句(if或者?:)、任何比较运算符（例如&lt;、&gt;或= =)或任何循环。你可以假设数据类型int是32位长，使用补码表示，而右移是算术右移。"></a>练习题2.42写一个函数 div16，对于整数参数x返回x/16的值。你的函数不能使用除法、模运算、乘法、任何条件语句(if或者?:)、任何比较运算符（例如&lt;、&gt;或= =)或任何循环。你可以假设数据类型int是32位长，使用补码表示，而右移是算术右移。</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">book_div16</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* Compute bias to be either 0 (x &gt;= 0) or 15 (x &lt; 0) */</span></span><br><span class="line">        <span class="type">int</span> bias = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0xF</span>;<span class="comment">//右移31位后，32位上面都是符号位的值</span></span><br><span class="line">        <span class="comment">//如果为非负数，符号位为0，bias变量为0</span></span><br><span class="line">        <span class="comment">//如果为负数，符号位为1，bias变量为0xF，即15</span></span><br><span class="line">        <span class="keyword">return</span> (x + bias) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题2-43在下面的代码中，我们省略了常数M和N的定义"><a href="#练习题2-43在下面的代码中，我们省略了常数M和N的定义" class="headerlink" title="练习题2.43在下面的代码中，我们省略了常数M和N的定义:"></a>练习题2.43在下面的代码中，我们省略了常数M和N的定义:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M <span class="comment">/*Mystery number 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N <span class="comment">/* Mystery number 2*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arith</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    result = x * M + y / N; <span class="comment">/*Mand N are mystery numbers. */</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以某个M和N的值编译这段代码。编译器用我们讨论过的方法优化乘法和除法。下面是将产生出的机器代码翻译回C语言的结果:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">optarith</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    x &lt;&lt;= <span class="number">5</span>;</span><br><span class="line">    x -= t;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">0</span>)</span><br><span class="line">        y += <span class="number">7</span>;</span><br><span class="line">    y &gt;&gt;= <span class="number">3</span>; <span class="comment">/* Arithmetic shift */</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看M:<br>代码等价于x = x <em> 32 -x = x </em> 31.所以M为31.</p>
<p>再看N</p>
<p>7=2\^3-1,最后的右移操作也是右移3位，所以N=8</p>
<h2 id="练习题2-44假设我们在对有符号值使用补码运算的32位机器上运行代码。对于有符号值使用的是算术右移，而对于无符号值使用的是逻辑右移。变量的声明和初始化如下"><a href="#练习题2-44假设我们在对有符号值使用补码运算的32位机器上运行代码。对于有符号值使用的是算术右移，而对于无符号值使用的是逻辑右移。变量的声明和初始化如下" class="headerlink" title="练习题2.44假设我们在对有符号值使用补码运算的32位机器上运行代码。对于有符号值使用的是算术右移，而对于无符号值使用的是逻辑右移。变量的声明和初始化如下:"></a>练习题2.44假设我们在对有符号值使用补码运算的32位机器上运行代码。对于有符号值使用的是算术右移，而对于无符号值使用的是逻辑右移。变量的声明和初始化如下:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = foo();</span><br><span class="line"><span class="type">int</span> y = bar();</span><br><span class="line"><span class="type">unsigned</span> ux = x;</span><br><span class="line"><span class="type">unsigned</span> uy = y;</span><br></pre></td></tr></table></figure>
<p>对于下面每个C表达式，1)证明对于所有的x和y值，它都为真(等于1);或者2)给出使得它为假(等于0)的x和y的值:</p>
<p><strong>A. (x &gt; 0)||(x-1 &lt;0)</strong></p>
<p>当x为TMIN时，左边不符合条件，为0；右边负溢出为TMAX，正数不小于0，为0；此时为false</p>
<p><strong>B. (x &amp; 7) != 7 || (x&lt;&lt;29&lt; 0)</strong></p>
<p>左边要求的是x的低3位不能都为1；右边要求第3位为1（先左移29位，所以有原始的低3位和29位个0组成，此时小于0，说明符号位为1，即原始的低3位的最高那个为1）；<br>低3位分两种情况：<br>1）除111外的所有情况：左边符合，必返回1，不用管右边。<br>2）111：左边不符合，但右边符合了，也返回1。<br>该表达式必为true。</p>
<p><strong>C. (x* x) &gt;= 0</strong></p>
<p>x = 182</p>
<p>182*182-65536=33124-65536=-32412</p>
<p><strong>D. x &lt;0 || -x &lt;=0</strong></p>
<p>当x为0时，右边成立；<br>当x为[1,TMAX]，右边必成立；<br>当x为[TMIN+1,-1]，左边成立；<br>当x为TMIN，左右都成立；<br>综上，此表达式必为1.</p>
<p><strong>E. x &gt; 0 || -x &gt;= 0</strong></p>
<p>当x为0时，右边成立；<br>当x为[1,TMAX]，左边成立；<br>当x为[TMIN+1,-1]，右边成立；<br>当x为TMIN，左右理论上都不成立（实际上有问题）；</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221016132814756.png" alt="image-20221016132814756"></p>
<p><strong>F. x+y == uy+ux</strong></p>
<p>表达式中含有无符号数，所以左边也会转换为无符号数。等价于unsigned(x+y) == uy+ux.<br>在二进制上，无符号数和有符号数的加法是一样的，故都为真。</p>
<p><strong>G.x*~y + uy*ux=-x</strong></p>
<p>-y = ~y+1,故 ~y=-y-1, 左边= x*(-y-1)+uy*ux = uy*ux - x*y -x, 不管是无符号数还是有符号数，在二进制层面上相乘后截短后的结果都是相同的。故 uy*ux-x*y=0, 故结果都为真</p>
<h2 id="练习题2-45填写下表中的缺失的信息"><a href="#练习题2-45填写下表中的缺失的信息" class="headerlink" title="练习题2.45填写下表中的缺失的信息:"></a>练习题2.45填写下表中的缺失的信息:</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221018111104045.png" alt="image-20221018111104045"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">小数值</th>
<th style="text-align:center">二进制表示</th>
<th style="text-align:center">十进制表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\frac{1}{8}$</td>
<td style="text-align:center">0.001</td>
<td style="text-align:center">0.125</td>
</tr>
<tr>
<td style="text-align:center">$\frac{3}{4}$</td>
<td style="text-align:center">0.110</td>
<td style="text-align:center">0.75</td>
</tr>
<tr>
<td style="text-align:center">$\frac{25}{16}$</td>
<td style="text-align:center">1.1001</td>
<td style="text-align:center">1.5625</td>
</tr>
<tr>
<td style="text-align:center">$\frac{43}{16}$</td>
<td style="text-align:center">10.1011</td>
<td style="text-align:center">2.6875</td>
</tr>
<tr>
<td style="text-align:center">$\frac{9}{8}$</td>
<td style="text-align:center">1.001</td>
<td style="text-align:center">1.125</td>
</tr>
<tr>
<td style="text-align:center">$\frac{47}{8}$</td>
<td style="text-align:center">101.111</td>
<td style="text-align:center">5.875</td>
</tr>
<tr>
<td style="text-align:center">$\frac{51}{16}$</td>
<td style="text-align:center">11.0011</td>
<td style="text-align:center">3.1875</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-46"><a href="#练习题2-46" class="headerlink" title="练习题2.46"></a>练习题2.46</h2><p>太长了，略。</p>
<h2 id="练习题2-47︰假设一个基于IEEE浮点格式的5位浮点表示，有1个符号位、2个阶码位-k-2-和两个小数位-n-2-。阶码偏置量是-2-2-1-1-。"><a href="#练习题2-47︰假设一个基于IEEE浮点格式的5位浮点表示，有1个符号位、2个阶码位-k-2-和两个小数位-n-2-。阶码偏置量是-2-2-1-1-。" class="headerlink" title="练习题2.47︰假设一个基于IEEE浮点格式的5位浮点表示，有1个符号位、2个阶码位(k=2)和两个小数位(n=2)。阶码偏置量是$2^{2-1}=1$。"></a>练习题2.47︰假设一个基于IEEE浮点格式的5位浮点表示，有1个符号位、2个阶码位(k=2)和两个小数位(n=2)。阶码偏置量是$2^{2-1}=1$。</h2><p>下表中列举了这个5位浮点表示的全部非负取值范围。使用下面的条件，填写表格中的空白项:</p>
<p>$e$:假定阶码字段是一个无符号整数所表示的值。</p>
<p>$E$:偏置之后的阶码值。</p>
<p>$2^E$:阶码的权重。</p>
<p>$f$ :小数值。</p>
<p>$M$:尾数的值。</p>
<p>$2^E×M$:该数(未归约的)小数值。</p>
<p>$V$:该数归约后的小数值。</p>
<p>十进制:该数的十进制表示。</p>
<p>写出$2^E$、f、M、$2^E\times M$和V的值，要么是整数(如果可能的话)，要么是形如$\frac{x}{y}$的小数，这里y是2的幂。标注为“—”的条目不用填。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221018154232508.png" alt="image-20221018154232508"></p>
<p>偏置量是$2^{2-1}-1=1$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">位</th>
<th style="text-align:center">e</th>
<th style="text-align:center">$E$</th>
<th style="text-align:center">$2^E$</th>
<th style="text-align:center">$f$</th>
<th style="text-align:center">$M$</th>
<th style="text-align:center">$2^E \times M$</th>
<th style="text-align:center">$V$</th>
<th style="text-align:center">十进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0 00 00</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$\frac{0}{4}$</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.0</td>
</tr>
<tr>
<td style="text-align:center">0 00 01</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$\frac{1}{4}$</td>
<td style="text-align:center">$\frac{1}{4}$</td>
<td style="text-align:center">$\frac{1}{4}$</td>
<td style="text-align:center">$\frac{1}{4}$</td>
<td style="text-align:center">0.25</td>
</tr>
<tr>
<td style="text-align:center">0 00 10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$\frac{2}{4}$</td>
<td style="text-align:center">$\frac{2}{4}$</td>
<td style="text-align:center">$\frac{2}{4}$</td>
<td style="text-align:center">$\frac{1}{2}$</td>
<td style="text-align:center">0.5</td>
</tr>
<tr>
<td style="text-align:center">0 00 11</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$\frac{3}{4}$</td>
<td style="text-align:center">$\frac{3}{4}$</td>
<td style="text-align:center">$\frac{3}{4}$</td>
<td style="text-align:center">$\frac{3}{4}$</td>
<td style="text-align:center">0.75</td>
</tr>
<tr>
<td style="text-align:center">0 01 00</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$\frac{0}{4}$</td>
<td style="text-align:center">$\frac{4}{4}$</td>
<td style="text-align:center">$\frac{4}{4}$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">1.0</td>
</tr>
<tr>
<td style="text-align:center">0 01 01</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$\frac{1}{4}$</td>
<td style="text-align:center">$\frac{5}{4}$</td>
<td style="text-align:center">$\frac{5}{4}$</td>
<td style="text-align:center">$\frac{5}{4}$</td>
<td style="text-align:center">1.25</td>
</tr>
<tr>
<td style="text-align:center">0 01 11</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$\frac{2}{4}$</td>
<td style="text-align:center">$\frac{6}{4}$</td>
<td style="text-align:center">$\frac{6}{4}$</td>
<td style="text-align:center">$\frac{3}{2}$</td>
<td style="text-align:center">1.5</td>
</tr>
<tr>
<td style="text-align:center">0 10 00</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">$\frac{4}{4}$</td>
<td style="text-align:center">$\frac{8}{4}$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">0 10 01</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">$\frac{1}{4}$</td>
<td style="text-align:center">$\frac{5}{4}$</td>
<td style="text-align:center">$\frac{10}{4}$</td>
<td style="text-align:center">$\frac{5}{2}$</td>
<td style="text-align:center">2.5</td>
</tr>
<tr>
<td style="text-align:center">0 10 11</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">$\frac{2}{4}$</td>
<td style="text-align:center">$\frac{6}{4}$</td>
<td style="text-align:center">$\frac{12}{4}$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">0 11 00</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">$+\infty$</td>
<td style="text-align:center">——</td>
</tr>
<tr>
<td style="text-align:center">0 11 01</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">NAN</td>
<td style="text-align:center">——</td>
</tr>
<tr>
<td style="text-align:center">0 11 10</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">NAN</td>
<td style="text-align:center">——</td>
</tr>
<tr>
<td style="text-align:center">0 11 11</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">NAN</td>
<td style="text-align:center">——</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-48正如在练习题2-6中提到的，整数3-510-593的十六进制表示为0x00359141，而单精度浮点数3510593-0的十六进制表示为0x42564504。推导出这个浮点表示，并解释整数和浮点数表示的位之间的关系。"><a href="#练习题2-48正如在练习题2-6中提到的，整数3-510-593的十六进制表示为0x00359141，而单精度浮点数3510593-0的十六进制表示为0x42564504。推导出这个浮点表示，并解释整数和浮点数表示的位之间的关系。" class="headerlink" title="练习题2.48正如在练习题2.6中提到的，整数3 510 593的十六进制表示为0x00359141，而单精度浮点数3510593.0的十六进制表示为0x42564504。推导出这个浮点表示，并解释整数和浮点数表示的位之间的关系。"></a>练习题2.48正如在练习题2.6中提到的，整数3 510 593的十六进制表示为0x00359141，而单精度浮点数3510593.0的十六进制表示为0x42564504。推导出这个浮点表示，并解释整数和浮点数表示的位之间的关系。</h2><p>整数 0x00359141 = 0000 0000 0011 0101 1001 0001 0100 0001</p>
<p>转换成浮点表示时, 先将小数点放在值为 1 的最高有效位的右边, 得到 $1.1 0101 1001 0001 0100 0001_2\times 2^{21} $。</p>
<p>因此尾数值为$1.101011001000101000001_2$，舍弃开头的1，末尾还需要增加两个0 （总共尾数23位），尾数部分为$101 0110 0100 0101 0000 0100$。</p>
<p>对于阶码位数 k=8，$Bias =2^{k-1}-1=2^7-1=127$，指数值 E = 21, E = e-B, 从而 e= 21+127=148,148 = 1001 0100</p>
<p>对于符号位，直接为0</p>
<p>综上，3510593.0 的浮点表示为 0 10010100 10101100100010100000100</p>
<p>而 0x4a564504 的位模式刚好为 010010100101 0110 0100 0101 0000 0100</p>
<h2 id="练习题2-49"><a href="#练习题2-49" class="headerlink" title="练习题2.49"></a>练习题2.49</h2><p>A. 对于一种具有n位小数的浮点格式，给出不能准确描述的最小正整数的公式(因为要想准确表示它需要n＋1位小数)。假设阶码字段长度k足够大，可以表示的阶码范围不会限制这个问题。</p>
<p>该练习有助于我们思考什么数不能用浮点数精确表示，因为阶码范围不限制, 故只需考虑小数部分最小能表示的数即可。</p>
<p>小数最多 n 位, 故最小能表示的小数 f 是 n 个 0 后面再加一个 1, 这个小数需要 n+1 个位来表示, 那么尾数 $M = f+1 =1.0000⋯01_2$</p>
<p>即要示的数的二进制表示为：1 后面跟 n 个 0, 再跟一个 1, 值为$2^{n+1}+1$</p>
<p>B. 对于单精度格式(n=23)，这个整数的数字值是多少?</p>
<p>对于单精度格式 n=23, 这个数为 $2^{24}+1=16777217$</p>
<h2 id="练习题2-50根据舍入到偶数规则，说明如何将下列二进制小数值舍入到最接近的二分之一-二进制小数点右边1位-。对每种情况，给出舍入前后的数字值。"><a href="#练习题2-50根据舍入到偶数规则，说明如何将下列二进制小数值舍入到最接近的二分之一-二进制小数点右边1位-。对每种情况，给出舍入前后的数字值。" class="headerlink" title="练习题2.50根据舍入到偶数规则，说明如何将下列二进制小数值舍入到最接近的二分之一(二进制小数点右边1位)。对每种情况，给出舍入前后的数字值。"></a>练习题2.50根据舍入到偶数规则，说明如何将下列二进制小数值舍入到最接近的二分之一(二进制小数点右边1位)。对每种情况，给出舍入前后的数字值。</h2><p>A.$10.010_2 = 10.0$</p>
<p>B.$10.011_2 = 10.1$</p>
<p>C.$10.110_2 = 11.0$</p>
<p>D.$11.001_2=11.0$</p>
<h2 id="练习题2-51"><a href="#练习题2-51" class="headerlink" title="练习题2.51"></a>练习题2.51</h2><h2 id="练习题2-52考虑下列基于IEEE浮点格式的7位浮点表示。两个格式都没有符号位——它们只能表示非负的数字。"><a href="#练习题2-52考虑下列基于IEEE浮点格式的7位浮点表示。两个格式都没有符号位——它们只能表示非负的数字。" class="headerlink" title="练习题2.52考虑下列基于IEEE浮点格式的7位浮点表示。两个格式都没有符号位——它们只能表示非负的数字。"></a>练习题2.52考虑下列基于IEEE浮点格式的7位浮点表示。两个格式都没有符号位——它们只能表示非负的数字。</h2><p>1.格式A</p>
<ul>
<li>有k=3个阶码位。阶码的偏置值是3。</li>
<li>有n=4个小数1。</li>
</ul>
<p>2.格式B</p>
<ul>
<li>有k=4个阶码位。阶码的偏置值是7。</li>
<li>有n=3个小数位。</li>
</ul>
<p>下面给出了一些格式A表示的位模式，你的任务是将它们转换成格式B中最接近的值。如果需要，请使用舍入到偶数的舍入原则。另外，给出由格式A和格式B表示的位模式对应的数字的值。给出整数(例如17)或者小数(例如17/64)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221019191037787.png" alt="image-20221019191037787"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">格式A</th>
<th style="text-align:center"></th>
<th style="text-align:center">格式B</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">位</td>
<td style="text-align:center">值</td>
<td style="text-align:center">位</td>
<td style="text-align:center">值</td>
</tr>
<tr>
<td style="text-align:center">011 0000</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0111 000</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">101 1110</td>
<td style="text-align:center">$\frac{15}{2}$</td>
<td style="text-align:center">1001 111</td>
<td style="text-align:center">$\frac{15}{2}$</td>
</tr>
<tr>
<td style="text-align:center">010 1001</td>
<td style="text-align:center">$\frac{25}{32}$</td>
<td style="text-align:center">0110 100</td>
<td style="text-align:center">$\frac{3}{4}$</td>
</tr>
<tr>
<td style="text-align:center">110 1111</td>
<td style="text-align:center">$\frac{31}{2}$</td>
<td style="text-align:center">1010 000</td>
<td style="text-align:center">16</td>
</tr>
<tr>
<td style="text-align:center">000 0001</td>
<td style="text-align:center">$\frac{1}{64}$</td>
<td style="text-align:center">0001 000</td>
<td style="text-align:center">$\frac{1}{64}$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题2-53完成下列宏定义，生成双精度值-∞-−∞和-0"><a href="#练习题2-53完成下列宏定义，生成双精度值-∞-−∞和-0" class="headerlink" title="练习题2.53完成下列宏定义，生成双精度值+∞, −∞和 0:"></a>练习题2.53完成下列宏定义，生成双精度值+∞, −∞和 0:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define POS_INFINITY 1e400</span><br><span class="line">#define NEG_INFINITY (-POS_INFINITY)</span><br><span class="line">#define NEG_ZERO (-1.0/POS_INFINITY)</span><br></pre></td></tr></table></figure>
<h2 id="练习题-2-54-假设变量-x-f-d-类型分别是-int-float-double-它们除了不是-∞-−∞-和-NaN-外-可以是任意值-对于下面的每个-C-表达式-证明它们总是真（也就是求值为1）-或者给出一个使其不为真的值（就是求值为0-。"><a href="#练习题-2-54-假设变量-x-f-d-类型分别是-int-float-double-它们除了不是-∞-−∞-和-NaN-外-可以是任意值-对于下面的每个-C-表达式-证明它们总是真（也就是求值为1）-或者给出一个使其不为真的值（就是求值为0-。" class="headerlink" title="练习题 2.54 假设变量 x, f, d 类型分别是 int, float, double, 它们除了不是 +∞, −∞ 和 NaN 外,可以是任意值, 对于下面的每个 C 表达式, 证明它们总是真（也就是求值为1）,或者给出一个使其不为真的值（就是求值为0)。"></a>练习题 2.54 假设变量 x, f, d 类型分别是 int, float, double, 它们除了不是 +∞, −∞ 和 NaN 外,可以是任意值, 对于下面的每个 C 表达式, 证明它们总是真（也就是求值为1）,或者给出一个使其不为真的值（就是求值为0)。</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A.x == (<span class="type">int</span>)(<span class="type">double</span>) x</span><br><span class="line">B.x == (<span class="type">int</span>)(<span class="type">float</span>) x</span><br><span class="line">C.d == (<span class="type">double</span>)(<span class="type">float</span>) d</span><br><span class="line">D.f == (<span class="type">float</span>)(<span class="type">double</span>)f</span><br><span class="line">E.f == -(-f)</span><br><span class="line">F<span class="number">.1</span><span class="number">.0</span>/<span class="number">2</span> == <span class="number">1</span>/<span class="number">2.0</span></span><br><span class="line">G.d*d &gt;= <span class="number">0.0</span></span><br><span class="line">H. (f+d)-f == d</span><br></pre></td></tr></table></figure>
<p>float 的最大规格化数是 3.4e38, 小于 1e40, double 的最大规格化数是 1.8e308, 小于 1e309.</p>
<p>A.  x == (int)(double) x : int 转换到 double 时能精确转换, 故总为真</p>
<p>B.x == (int)(float) x: int 到 float, 不溢出, 可能舍入, 根据练习题 2.49, 最小不能表示的正数是$2^{23}+1$，此时会舍入到$2^{23}$</p>
<p>C. d == (double)(float) d: double 转换到 float 会溢出,也会舍入, d = 1e40 时右边会是正无穷</p>
<p>D. f == (float)(double)f:　都为真</p>
<p>E. f == -(-f): 都为真, 因为浮点数的正负转换只需转换符号位即可.</p>
<p>F. 1.0/2 == 1/2.0:　都为真, 因为分子和分母在运算前都会先转换成浮点数．</p>
<p>G. d*d &gt;= 0.0：实数乘法符合单调性, 故都为真, 不过可能溢出为 +∞</p>
<p>H. (f+d)-f == d: 当 f+d 溢出时, 不为真, 例如 f=1e20, d=1.0 时, 左边会 0,右边 为 1.0</p>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统第2章</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>A Survey on Temporal Action Localization</title>
    <url>/2021/06/15/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/A%20Survey%20on%20Temporal%20Action%20Localization/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="A-Survey-on-Temporal-Action-Localization"><a href="#A-Survey-on-Temporal-Action-Localization" class="headerlink" title="A Survey on Temporal Action Localization"></a>A Survey on Temporal Action Localization</h1><blockquote>
<p><strong>摘要:</strong>在计算机视觉中，时间动作定位是视频理解中最关键也是最具挑战性的问题之一。由于其广泛的应用，近年来引起了广泛的关注日常生活应用。时间动作定位技术已经取得了很大的进展，特别是最近深度学习的发展。而且在未裁剪的情况下，现在需要更多的时间动作定位视频。在这篇论文中，我们的目标是调查最新的技术和模型的视频时间行动定位。主要包括相关技术、一些基准数据集和评价时间动作定位的度量。此外，我们从两个方面总结了时间动作定位各方面:全监督学习和弱监督学习。并列举了几部具有代表性的作品并比较他们各自的表现。最后，对其进行了深入分析，并提出了发展前景研究方向，并总结调查。</p>
</blockquote>
<p><strong>关键词</strong>：动作检测，计算机视觉，全监督学习，时间动作定位，弱监督学习。</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>随着视频数量急剧的增长，视频理解成为了计算机视觉领域的一个热点问题和具有挑战性的方向。这个视频理解发个信包括许多子研究方向，包括在夏威夷，被CVPR举办的ActivityNet 挑战2017，这个网络一共提出了5个任务。</p>
<ul>
<li>未裁剪的视频分类(Untrimmed Video Classification )</li>
<li>裁剪后的行动识别( Trimmed Action Recognition)</li>
<li>时间动作检测( Temporal Action Proposals)</li>
<li>时间动作定位(Temporal Action Localization)</li>
<li>视频中密集的字幕事件(Dense-Captioning Events in Videos)</li>
</ul>
<p>在最近的调查中，我们关注的是时间动作定位，也就是上面列出的第四个。它需要检测包含目标动作的时间间隔。对于长时间的<strong>未裁剪的视频</strong>，时间动作定位主要解决两个任务，识别和定位。特别是,a)动作发生的起始时间和终止时间,b)每个提案的类别是什么属于(如挥手、爬山、扣篮)。当然，一个视频可能包含一个或多个行动剪辑(action clips),所以时间动作定位是要开发模型和技术来提供计算机视觉应用所需要的最基本的信息:动作是什么，动作什么时候发生?我们将这个任务作为动作定位，或时间动作定位，或动作检测。</p>
<p>虽然动作识别和动作本地化都是视频理解里面很重要的任务，但是时间动作定位比动作识别更加具有挑战性。动作识别和动作定位的关系和图像检测类似于图像识别和图像检测。但是由于时间连续信息(temporal series information),时间动作定位比图像检测更见困难。困难主要来自以下几个方面：<strong>a)</strong>时间信息，由于1维时间连续信息，时间动作定位不能使用静态图片信息，它必须结合时间连续信息。<strong>b)</strong>与目标检测不同的是，边界对象通常是非常清晰的，所以我们可以为对象标记一个更清晰的边界框。然而，可能没有关于动作的确切时间范围合理定义，所以，不可能给一个动作开始和结束的准确边界。<strong>c)</strong>大的时间跨度，时间动作片段的跨度可以是非常大的，比如，挥手可能只几秒钟但是攀岩和骑自行车能够持续十几秒。它们时间跨度在长度上的不同，是的提取检测(extract proposals)很困难。另外，在开放的环境当中，这里也又许多问题，例如多尺度，多目标和相机移动。</p>
<p>时间动作定位非常贴近我们的生活，它具有广泛的应用前景和社会价值在视频概况(video summarization)、公共视频监控、技能评估和日常生活安全。所以它在最最近几年得到了广泛的关注。与“动作检测”有关的出版物总数约为324127份，近二十年来包括书籍、期刊、论文、会议论文、专利和一些科技成果。下面我们主要分析出版学术和回忆论文的趋势动作检测，如同<strong>图1</strong>所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20201027193624091.png" alt=""></p>
<p>本调查旨在帮助对时态动作本地化感兴趣的初学者。它提供一个概括动作定位的方法和最新进展，本文余下部分组织如下。</p>
<ul>
<li>第二节概述相关技术。</li>
<li>第三节介绍基本的时间动作定位数据集</li>
<li>第四节描述模型的性能评估指标</li>
<li>第五节从全监督和弱监督两方面，提供一个时间动作定位模型和方法的概述</li>
<li>第六节讨论现在的挑战和建议未来的方向</li>
<li>第七节总结本论文</li>
</ul>
<span id="more"></span>
<h2 id="2-相关技术"><a href="#2-相关技术" class="headerlink" title="2.相关技术"></a>2.相关技术</h2><p>因为最近时间本地化已经成为了一个活跃的研究领域，许多解决此问题的不同的方法被提出。虽然动作检测已经研究了许多年，但是它仍处于实验室数据集的测试阶段，没有实际的实用性和工业化。理解视频中动作发生的时间和内容是非常具有挑战性的。可以看出，目前对于这个任务仍然没有健壮的解决方案。在本节中，我们将回顾时间动作定位的相关技术。</p>
<p>众所周知，视频特征表示可以为视频动作提供有用的信息，并且很多实验已经被做了。在过去的二十年，众所周知特征提取的进展一般经历了两个重要的历史时期。一个是传统的动作检测阶段在2014年之前，另一个时期时深度学习阶段，在2014年之后。时间线框架如<strong>图2</strong>所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20201027201856154.png" alt="image-20201027201856154"></p>
<p>在深度学习阶段，它们主要被分为两种类型框架：“两阶段检测(‘two-stage detection)”和“一阶段检测（one-stage detection）”。特别，前面一种依赖“检测和分类”(proposal-then-classification)范式，这是一个主流方法，后一种同时检测和分类,所以我们称之为一级检测</p>
<h3 id="A-传统的方法-TRADITIONAL-METHODS"><a href="#A-传统的方法-TRADITIONAL-METHODS" class="headerlink" title="A.传统的方法(TRADITIONAL METHODS)"></a>A.传统的方法(TRADITIONAL METHODS)</h3><p>由于动作识别是时间动作定位的一部分，所以大多数早期动作定位算法都依赖于手动制作的特点，这一点和动作识别相同。这里有几种方式去提取视频特征，包含静态图像特征和时间视觉特征。具体来说，静态图像特征是SIFT (ScaleInvariant Feature Transform，特性变换)和 HOG (Histogram of Oriented Gradients，倾斜的直方图)等待。HOG可以认为是SIFT的一种改进，然而时间视觉特征是静态图像信息和时间信息的结合。通过这些特征，可以得到视频的时间信息。</p>
<p>一般来说，我们能够将特征提取分为局部特征提取和全局特征提取。<strong>a)</strong>局部特征提取是指视频中的局部感兴趣点和感兴趣区域，包括统计数据，字段学习(dictionary learning),bagof-words (BoW),特征学习等等。和全局特征提取想比较，局部特征提取对于视频照明、投是、相机抖动和复杂背景更具有健壮性。<strong>b)</strong>全局特征提取指的是人类行为的整体特征，如人体的轮廓、骨架等，它包括全局密度和轨迹方法。为了解决在复炸场景中人类行为的问题，仅仅检测时空区域灰度变化是不够的。因此，研究人员已经提出了许多依赖于点轨迹的特征提取的方法。近似的过程如下：第一，这些方法先在视频的时间区域检测特征点，然后一帧一帧跟踪这些特征点，并将形成的特征点的轨迹连接起来，最后它们使用特征描述器(feature descriptors)来描述这个轨迹和它的时间域。许多特征提取的方法依赖特征点的轨迹传统方法是Dense Trajectories (DT)，随后，考虑到摄像机的运动导致DT提取的特征和人类行为不相关关联，DT特征提取被更深的改进了，一种叫iDT的方法被提出。iDT的非常有价值的见解(valuable insight)仍然影响着以后的研究工作。值得注意的是深度学习和iDT的结合通常可以更进一步的提高性能。许多论文已经采纳以”我们的方法+iDT”的形式去实现最高水平SOTA(state-of-the-Art)</p>
<p>  无论如何，传统特征提取方法的研究过程和思想非常有用，因为这些方法具有很强的可解释性。它们为设计深度学习方法来解决此类问题提供了启发和类比。</p>
<h3 id="B-深度学习的方法-DEEP-LEARNING-METHODS"><a href="#B-深度学习的方法-DEEP-LEARNING-METHODS" class="headerlink" title="B.深度学习的方法(DEEP LEARNING METHODS)"></a>B.深度学习的方法(DEEP LEARNING METHODS)</h3><p>随着使用手工特征提取的方法的表现变得稳定，时间动作定位以及达到了一定高度。随着卷积神经网络的重生，大量的研究也随之兴起。卷积神经网络可以学习见状的和高水准的特征表示。比如，一个2D-CNN对于一个大规模的视频分类是李菲菲的小组在年提出来的。虽然它的表现和依赖传统方法的特征提取不能相比，但是这个想法启发了后来的研究人员。后来，两种流派CNN((RGB frames and optical flow),  3D卷积神经网络和紧接着它们的变化成为了学习动作识别中的区别性特征受欢迎方法。随后，一个结合两种流派和C3D网络被命名为I3D(Inception 3D)被提出。而且它以及成为了一种通用的视频特征表示编码器(video feature representation encoder)。除了几种依赖神经网络的方法被介绍用来捕捉动态的动作识别，TSN通过稀疏采样的策略，也被设计来对整个视频信息进行平均聚集建模。根据<strong>图1</strong>，我们值得，深度学习分为两种类型：两阶段定位和一阶段定位。</p>
<h4 id="1）两阶段定位方法"><a href="#1）两阶段定位方法" class="headerlink" title="1）两阶段定位方法"></a>1）两阶段定位方法</h4><p>两阶段类型依赖定位-然后-分类( proposal-thenclassification)的范式.这个范式先提取时间定位，然后接着处理分类和回归操作。这方式是主流方法，所以大多数论文都是采用此方法。事实上，这个定位的生成是时间定位范式中的一个难点，这个和目标检测中定位的生成相类似(RNN中区域定位生成)。一个好的定位算法可以更好的提高这个模型的效果</p>
<p>时间动作定位生成器的任务是生成一定数量的时间定位对于一个未裁剪的长视频。一个时间动作定位是一个时间间隔包含动作片段(从起点边界到终点边界)。一般来说，平均召回率用来衡量算法的性能。数据库一般使用ActivityNet和THUMOS14，有几种方法提取定位的方法。</p>
<h5 id="a-滑动窗口-SLIDING-WINDOW-S-CNN-14-2016"><a href="#a-滑动窗口-SLIDING-WINDOW-S-CNN-14-2016" class="headerlink" title="a:滑动窗口(SLIDING WINDOW,S-CNN [14], 2016)"></a>a:滑动窗口(SLIDING WINDOW,S-CNN [14], 2016)</h5><p>在2016年，S-CNN第一个方法是固定一些大小滑动窗口去生成各种大小不同的视频片段，然后通过多级网络(SegmentCNN)处理这些片段。SCNN包括3个子网络都使用C3D网络。第一个是定位(proposal)网络，它用来确定当前路段是一个动作的概率，第二个是分类网络，用来给视频片段分类，第三个是定位(localization)网络,它的输出任然是一个类别的概率。并在训练过程中加入重叠相关的损失函数，使得网络能够更好地估计视频片段的类别喝重叠。原则上，当重叠度越高，效果越好。最后non-maximized suppression (NMS)被用于重复的片段和完成预测。</p>
<p>理论上，只有重叠足够高，这种方法是最全面的，但它有更多的冗余。</p>
<h5 id="b-时间活动分组-TEMPORAL-ACTIONNESS-GROUPING-TAG-15-2017"><a href="#b-时间活动分组-TEMPORAL-ACTIONNESS-GROUPING-TAG-15-2017" class="headerlink" title="b:时间活动分组(TEMPORAL ACTIONNESS GROUPING,TAG [15], 2017)"></a>b:时间活动分组(TEMPORAL ACTIONNESS GROUPING,TAG [15], 2017)</h5><p>以前的工作使用滑动窗口去提取建议的区域，但是这个方法不能处理不同视频动作长度。因为一般的是动作识别，卷积适用于密集视频帧，而且对于长动作视频滑动窗口消耗的资源太多。</p>
<p>Y. Xiong et al在2017年提出了一个新的框架用来准确的确定不同长度的动作视频的边界。这个框架包含两个部分：生成时间区域(generating temporal proposals)和分类待选(classifying proposed candidates)。前一部分生成一系列的建议区域，而后者确定它是否是一个动作并且预测它的类别。未来生成时间建议区域，TAG网络被提出。他们有三个主要步骤：a)提取片段(Extract snippets):每个片段包含一个视频的帧和视觉留信息，而且片段是在一个规律的间隔内获得的。b)动作：判断一个片段是否包含动作，为了做这件事，它使用TSN(Temporal Segment Network)学习二分类网络。c)分组：对于输出的片段序列和他们的概率，它将那些得分较高的连续片段进行分组。与此同时，设置一些阈值去删除分数较低的片段，以防止噪声干扰，并且通常设置多组阈值，以防止缺失建议区域。</p>
<p>这个方法对于边界更加灵活，但是它可能因为分类错误而错过一些建议区域</p>
<h5 id="c-时间单位回归网络-TEMPORAL-UNIT-REGRESS-NETWORK-TURN-TAP-16-2017"><a href="#c-时间单位回归网络-TEMPORAL-UNIT-REGRESS-NETWORK-TURN-TAP-16-2017" class="headerlink" title="c:时间单位回归网络(TEMPORAL UNIT REGRESS NETWORK,TURN TAP [16], 2017)"></a>c:时间单位回归网络(TEMPORAL UNIT REGRESS NETWORK,TURN TAP [16], 2017)</h5><p>在SCNN网络中，它使用滑动窗口去寻找建议区域。如果你想得到准确的结果，你需要增加窗口之间的额重叠，这回导致计算量大的问题。</p>
<p>为了减少计算量和增加时间定位准确度，在2017， Gao J.Y. et al在faster-RCNN映入边界回归方法的基础上，提出了转向学习的方法。这个方法将视频分割成固定大小的单元，列入16帧的单元，然后将每个单元放入C3D种提取水平特征。相邻单元形成一个clip，让么个单位形成一个锚单位，构成一个clip金字塔。然后在单元处进行时间坐标回归，这个网络包含两个输出，第一个输出是确定clip是否包含动作的分数；第二个输出是调整边界的时间坐标偏移量。</p>
<p>这个方法主要的贡献如下：1）一种利用坐标回归生成时间建议分段的新方法。2）快的速度(800fps)。3）一个新的评价指标AR-F被提出</p>
<h5 id="d-边界敏感网络-BOUNDARY-SENSITIVE-NETWORK-BSN-21-2018"><a href="#d-边界敏感网络-BOUNDARY-SENSITIVE-NETWORK-BSN-21-2018" class="headerlink" title="d:边界敏感网络(BOUNDARY SENSITIVE NETWORK ,BSN [21], 2018)"></a>d:边界敏感网络(BOUNDARY SENSITIVE NETWORK ,BSN [21], 2018)</h5><p>众所周知，高质量的时间动作建议区域应该有一下几点特征：a)灵活的时间长度,b)精确的时间界限,c)可靠的信心得分。但是现有的方法不能同时兼顾这些方面，为了解决这些困难，T. Lin et al. [21]提出了BSN在2018年。</p>
<p>简略的说，BSN搜先定位时间动作片段的边界(开始节点和结束节点)。边界节点直接组合成一个时间建议区域。然后根据每个建议区域提案的动作置信度评分序列提取一个32维建议区域特征。最后，根据所提取的建议区域层次特征，对时间提案的置信度进行评估。</p>
<p>这方法主要的贡献如下：a)新颖的框架可以在同一时间满足上诉三点。b)BSN模块简单灵活，缺点是:a)对每个时间方案逐个进行特征提取和置信度评估，效率不够。b)语义信息不足。为了保证动作建议区域特征提取的效率，BSN设计的32维特征相对简单，但也限制了置信度评价模块获取更多的语义信息。c)该方法具有多阶段性。它没有联合优化网络的几个部分。</p>
<h5 id="e-边界匹配网络-BOUNDARY-MATCHING-NETWORK-BMN-72-2019"><a href="#e-边界匹配网络-BOUNDARY-MATCHING-NETWORK-BMN-72-2019" class="headerlink" title="e:边界匹配网络(BOUNDARY-MATCHING NETWORK,BMN [72], 2019)"></a>e:边界匹配网络(BOUNDARY-MATCHING NETWORK,BMN [72], 2019)</h5><p>为了解决BSN的缺点，新的时间建议区域置信度评价机制喝边界匹配机制也由T. Lin在2019年提出。BMN能够生成一维边界概率喝二维BM置信度图。然后对所有可能的时间建议区域进行密集评估。</p>
<p>以上时间动作建议区域方法的性能比较如表1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20201114104053741.png" alt=""></p>
<h4 id="一阶段定位方法"><a href="#一阶段定位方法" class="headerlink" title="一阶段定位方法"></a>一阶段定位方法</h4><p>另一种是同时处理建议区域和分类的一阶段框架。比如，在2017年T. Lin 提出SSAD和李菲菲提出了SS—TAD（端到端，单流时间动作检测）。他们都是基于单个检测器。由于时间动作定位和目标检测相似性，SSAD结合了YOLO和SSD两种目标检测模型的特点。SSAD的一般流程如下，使用提前训练的模型，得到特征序列，作为SSAD模型的输入。模型处理后输出检测结果。而SS-TAD将时间动作定位的语义子任务作为调整语义约束，提高了训练和测试性能。效果优于SSAD，SS-TAD提取特征使用C3D，与SSAD相同。而SS-TAD采用锚定机构和叠加GRU单元。最近，Fuchen Long介绍了GTAN(Gaussian Temporal Awareness Networks,高斯时间感知网络),该网络将时间结构与单阶段动作定位相结合。在GTAN，该算法引入高斯核函数，动态优化每个动作建议的时间尺度。</p>
<p>此外，有些方法基于顺序决策过程，也属于单阶段框架。例如，文献10是第一个提出在视频中学习动作检测的端到端的方法。在这篇文章中,它使用强化学习来训练一个基于rnn的代理。代理可以不断观察视频帧，并决定下一步看哪里，何时生成动作预测</p>
<h2 id="3-基准数据集"><a href="#3-基准数据集" class="headerlink" title="3.基准数据集"></a>3.基准数据集</h2><p>虽然没有一个时间动作定位的标准基准，但大多数研究人员使用THUMOS14[6]和ActivityNet [7]。此外，还有几个大型数据集用于时间动作检测。比如，MEXaction2、MutiTHUMOS、Charades和AVA等。下面这段主要介绍几种常用的数据集</p>
<h3 id="A-THUMOS14"><a href="#A-THUMOS14" class="headerlink" title="A.THUMOS14"></a>A.THUMOS14</h3><p>THUMOS14来自2014年的THUMOS Challenge。这个数据集包含两个任务：动作识别和时间动作检测。大多数论文都在这个数据集中进行评估。THUMOS数据集在其训练、验证和测试集中有101个动作类的视频级注释，而在20个类的验证和测试集中只有一小部分视频有时态注释。</p>
<p>一些全监督学习方法的细节如下:a)训练集:UCF101,101种动作类型，共计修剪了13320个视频剪辑。b)验证集：1010个未修剪的视频，其中200个贴有时间注释。(3007个动作片段，只有20个类可以用于时间动作检测任务)。c)测试集：1574个未修剪的视频，其中213个有时态动作注释。（3358个行为片段，只有20个类可以用于时间动作检测任务）</p>
<p>总之，这个数据集很有挑战性，因为有些视频比较长(长达26分钟)，并且包含多个动作实例。动作的长度在一秒到几分钟之间变化很大。</p>
<h3 id="B-ActivityNet"><a href="#B-ActivityNet" class="headerlink" title="B.ActivityNet"></a>B.ActivityNet</h3><p>ActivityNet数据集是最近引入动作识别和动作定位基准的最大的非裁剪视频数据集。该数据集只提供YouTube视频链接，不能直接下载视频。所以我们需要使用YouTube下载工具自动下载。ActivityNet1.3包含10,024个训练视频，4,926个验证视频，5044个测试视频，200个活动类别，如“遛狗”、“跳远”和“给地板吸尘”。ActivityNet1.3 平均每个视频只包含1.5次出现，大多数视频只包含单个动作类别，平均36%的背景。</p>
<p>这个数据集包含在语义分类下涉及各种人类活动的大量自然视频。</p>
<h3 id="C-MEXaction2"><a href="#C-MEXaction2" class="headerlink" title="C.MEXaction2"></a>C.MEXaction2</h3><p>MEXaction2数据集包含两种类型的动作，即骑马和斗牛。这个数据集由三部分组成:YouTube视频，UCF101中的骑马视频和INA视频。其中UCF101中的YouTube视频片段和骑马视频是裁剪后的短视频片段，用于训练集，而INA视频是未裁剪的长视频，总长度为77小时。INA视频分为培训、验证和测试集。训练集、验证集和测试集中分别有1336、310和329个动作片段。</p>
<p>总之，MEXaction2 dataset的特点是未裁剪的视频非常长，注释片段只占整个视频的很小一部分。</p>
<h3 id="D-MUTITHUMOS"><a href="#D-MUTITHUMOS" class="headerlink" title="D.MUTITHUMOS"></a>D.MUTITHUMOS</h3><p>MUTITHUMOS是一个密集的，多类，帧明智标签视频数据集，包括400个视频30小时，38,690个65个类的注释。平均每帧有1.5个标签，每段视频有10.5个动作类。这是THUMOS的增强版。目前，我们只在2017的论文“‘Learning Latent Super-Events to Detect Multiple Activities in Videos”中看到对该数据集的评价</p>
<h3 id="E-CHARADES"><a href="#E-CHARADES" class="headerlink" title="E.CHARADES"></a>E.CHARADES</h3><p>Charades是未删减的视频，其中包含9,848个室内视频，(7985个训练数据，1863年测试数据)，以及来自267个不同人的157个课程。每个视频大约30秒。每个视频都有多个注释，每个动作的开始时间和结束时间。</p>
<h3 id="F-AVA"><a href="#F-AVA" class="headerlink" title="F.AVA"></a>F.AVA</h3><p>AVA是一个时空本地化的原子视觉动作数据集。它包含了430个15分钟长的电影片段，并注释了80个动作。有38.6万个标记片段，61.4万个标记包围框和8.1万个人员轨迹。总共有158万标记的行为，每个人经常有多个标记。</p>
<p>接下来，我们总结和比较这些数据集显示表2。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20201114213744116.png" alt=""></p>
<h2 id="4-评价指标"><a href="#4-评价指标" class="headerlink" title="4.评价指标"></a>4.评价指标</h2><h3 id="A-基本概念"><a href="#A-基本概念" class="headerlink" title="A.基本概念"></a>A.基本概念</h3><p>在二分类问题当中，TP代表True Positive，FP代表False Positive，TN代表True Negative，而FN代表False Negative。这四个参数被用来计算多种性能评价指标。给出了四个参数的逻辑细节在表3中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20201114214140041.png" alt=""></p>
<p>其中，在实际的二进制分类中，positive-1标签指的是你比较关心的样本，比如一个动作或者一个异常事件。</p>
<h4 id="1-ACCURACY"><a href="#1-ACCURACY" class="headerlink" title="1)ACCURACY"></a>1)ACCURACY</h4><p>准确度是指正确分类样本的比例。它被用来评价分级机的性能。</p>
<script type="math/tex; mode=display">
accuracy=\frac{rP+TN}{TP + TN + FP + FN}=\frac{TP+TN}{ALL}(1)</script><h4 id="2-RECALL"><a href="#2-RECALL" class="headerlink" title="2)RECALL"></a>2)RECALL</h4><p>召回率是正确预测的范围。准确的说，找回是测试集中确定了多少真的positive样本。它的公式如下。</p>
<script type="math/tex; mode=display">
recall=\frac{TP}{TP+FN}（2）</script><h4 id="3-PRECISION"><a href="#3-PRECISION" class="headerlink" title="3)PRECISION"></a>3)PRECISION</h4><p>准确的说，准度是预测真实positive样本占预测结果的百分比。它的公式如下。</p>
<script type="math/tex; mode=display">
Precision=\frac{TP}{TP+FP}=\frac{TP}{n}(3)</script><p>其中，n为真positive和假positive之和，n为系统识别的样本总数。</p>
<h4 id="4-INTERSECTION-OVER-UNION-IoU"><a href="#4-INTERSECTION-OVER-UNION-IoU" class="headerlink" title="4)INTERSECTION-OVER-UNION (IoU)"></a>4)INTERSECTION-OVER-UNION (IoU)</h4><p>IoU可以理解为模型预测的检测框与图像中目标检测的地面真实值的重叠。其实就是检测的准确性，计算公式为探测结果与地面真值的交点，并与两者的联合进行比较。</p>
<script type="math/tex; mode=display">
IoU=\frac{predicted detection box\cap ground truth}{predicted detection box\cup ground truth}(4)</script><p>IoU用于检查预测结果与地面真实值之间的IoU是否大于预测阈值。我们通常把0.5作为阈值。如果IoU大于0.5，则该对象被识别为“检测成功”，否则被识别为“漏报”。在时间动作检测中，将IoU转化为时间的t-IoU，该t-IoU只有一维。</p>
<h3 id="B-评价指标"><a href="#B-评价指标" class="headerlink" title="B. 评价指标"></a>B. 评价指标</h3><h3 id="C-平均召回-AVERAGE-RECALL-AR"><a href="#C-平均召回-AVERAGE-RECALL-AR" class="headerlink" title="C.平均召回(AVERAGE RECALL,AR)"></a>C.平均召回(AVERAGE RECALL,AR)</h3><p>AR是时间动作建议区域生成的评价指标。因为时间动作建议区域生成不需要分类，它仅仅只需要去发现建议区域。因此，我们发现的时间动作建议区域是否完整，可以用来评估该方法的性能。所有我们经常使用AR来对此进行判断</p>
<script type="math/tex; mode=display">
AR=\frac{sum of the videos recalled}{total number of videos}(5)</script><h3 id="D-均值平均精度-MEAN-AVERAGE-PRECISION-mAP"><a href="#D-均值平均精度-MEAN-AVERAGE-PRECISION-mAP" class="headerlink" title="D. 均值平均精度(MEAN AVERAGE PRECISION,mAP)"></a>D. 均值平均精度(MEAN AVERAGE PRECISION,mAP)</h3><p>在时间动作定位任务中，mAP是最常用的评价指标。一般来说，我们在t-IoU = 0.5的情况下比较mAp。</p>
<p>简单地说， Precision (P)是给定视频中单个类的正确检测程度。例如，对于给定的单个视频，在公式中显示了类C的精度。</p>
<script type="math/tex; mode=display">
P=\frac{TP}{TP + FP}=\frac{number of predicted correct proposals}{total mumber of predicted proposals}(6)</script><p>由于测试集中有很多视频，平均精度(AP)是类C中所有视频的平均精度。同时，由于测试集视频对应的类也很多，所以平均平均精度就是所有测试视频中所有类的平均精度。</p>
<script type="math/tex; mode=display">
mAP=\frac{the sum of average precision of all classes}{total number of videos in testing set}(7)</script><p>总之，在某t-IoU下，P是某类C在视频中预测建议区域的准确性。AP是视频中所有类别的预测建议的平均精度。MAP是所有测试视频中所有类的预测建议的平均精度的平均值。在标准评价方案下，几乎所有的文献都报道了不同阈值的t-IoU下的mAP</p>
<h2 id="5-最近的方法和发展"><a href="#5-最近的方法和发展" class="headerlink" title="5.最近的方法和发展"></a>5.最近的方法和发展</h2><h3 id="A-全监督时间动作定位-FULLY-SUPETVISED-TEMPORAL-ACTION-LOCALIZATION-F-TAL"><a href="#A-全监督时间动作定位-FULLY-SUPETVISED-TEMPORAL-ACTION-LOCALIZATION-F-TAL" class="headerlink" title="A.全监督时间动作定位(FULLY-SUPETVISED TEMPORAL ACTION LOCALIZATION,F-TAL)"></a>A.全监督时间动作定位(FULLY-SUPETVISED TEMPORAL ACTION LOCALIZATION,F-TAL)</h3><h4 id="1-全监督学习"><a href="#1-全监督学习" class="headerlink" title="1)全监督学习"></a>1)全监督学习</h4><p>==全监督学习是训练一种智能算法将输入数据映射到标签的过程，其中每个训练数据都有其对应的表示其ground truth的标签==。我们经常学习的分类和回归是监督式学习的代表。在时间动作定位任务中，全监督采用训练集的标签，该标签既包含视频级类别标签，又包含动作片段的时间标注信息(包括动作的开始时间和结束时间)。</p>
<h4 id="2-目前具有代表性的方法"><a href="#2-目前具有代表性的方法" class="headerlink" title="2)目前具有代表性的方法"></a>2)目前具有代表性的方法</h4><p>很多方法(如S-CNN[14]和PSDF[18])通过滑动窗口生成建议区域，并将提案分类为C + 1类，即C动作类和一个背景类。其中，S-CNN使用了多级CNN时间动作定位捕获鲁棒的视频特征表示。为了精确的边界，CDC [19] (Convolutional- de -Convolutional)网络和TPC-Net [20] ((Temporal Preservation Convolutional network)网络被提出用于帧级的动作预测。边界敏感网络(Boundary Sensitive Network, BSN[21])是最近提出的一种用于定位时间边界的网络，并进一步整合到动作建议区域中。次年，BSN的作者提出了一个新的时间建议区域置信度评价机制和边界匹配机制BMN [72]。BMN可以同时生成一维边界概率和二维BM的置信度图。为了保证建议区域的完整性，SSN[22]引入了结构化时间金字塔，利用解耦的分类器对行动进行分类和确定完整性。此外，一些基于区域的方法(如R-C3D[23]和talo - net[24])提出将二维目标检测方法推广到一维时间动作定位。最近，为了精确动作定位而提出了TSA-Net [26]和Gaussian temporal modeling [25]。下面是性能比较。为了简单和公平，我们在THUMOS14数据集和各种代表性方法的出版物上对mAP@tIoU = 0.5进行性能比较，如表4所示。</p>
<p>近年来，随着各种新型网络的引进，准确率已达到最新的46.9%[26]。当然，与图像中的目标检测还有一定的差距，这也是目前难以实现大规模商业化的原因。但我们可以相信，随着技术的不断进步，精度一定会实现突破。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20201115121823022.png" alt=""></p>
<h3 id="B-弱监督时间动作定位-W-TAL"><a href="#B-弱监督时间动作定位-W-TAL" class="headerlink" title="B.弱监督时间动作定位(W-TAL)"></a>B.弱监督时间动作定位(W-TAL)</h3><p>由上节可知，目前的全监督学习技术在时间动作定位方面取得了很大的成功。因为许多现有的技术依赖于裁剪后的视频作为输入，例如：UCF101，他们有这些精确的时间注释。但在现实情况下，大多数视频都是未修剪并包含许多与目标动作无关的帧。因此，对时态标注的要求是非常困难的。具体原因总结如下:a)每个动作实例的帧级注释既昂贵又耗时。b)时间行为并没有明确的定义，这些时间行为的标注可能是因人而异的。</p>
<p>因此，弱监督学习方法越来越受欢迎。</p>
<h4 id="1-弱监督学习"><a href="#1-弱监督学习" class="headerlink" title="1)弱监督学习"></a>1)弱监督学习</h4><p>让我们看一看弱监督学习。这里有三种类型的弱监督学习。a)不完全弱监督学习。不完全监督，这只是训练数据的一小部分标记，而其他数据没有标记。例如，在图像分类中，我们可以很容易地从网上得到大量的图像，但由于人工成本昂贵，只有少数图像有注释。b)不精确弱监督学习。也就是说训练数据只有粗粒度的标签。我们还以图像分类为例。我们通常有图像级标签，但没有对象级标签。c)不准确弱监督学习。也就是说，给我们的标签并不总是真实的。例如，当图像注释器疲劳或者粗心大意的时候，或者一些图像很难分类的时候，就会出现这种情况。</p>
<p>由上可知，弱监督时间定位在训练过程中只有视频级标签，没有帧级时间标注，属于第二类弱监督，即不精确监督。</p>
<h4 id="2-目前具有代表性的方法-1"><a href="#2-目前具有代表性的方法-1" class="headerlink" title="2)目前具有代表性的方法"></a>2)目前具有代表性的方法</h4><p>目前基于弱监督的定位方法很少，仅依赖于视频级的类标签来实现时间动作定位。受图像中弱监督目标检测的启发，研究人员对UntrimmedNet[29]和Hide-and-seek [30]进行了研究。UntrimmedNet是第一个提出动作识别和弱监督动作检测的公司。它是学习单标签动作分类和检测的一个端到端模型。STPN [31]是一个深度神经网络，依赖于分类。这个网络的总体结构如下:将视频分为N个片段，注意力模块可以识别关键片段的稀疏子集。然后我们就可以得到在分类标签预测过程中各个环节的重要性。因此，它能够通过自适应时间池化生成相应的类别标签和区间建议。AutoLoc [32]尝试根据CAS的阈值直接预测不同于以往弱监督时间动作检测的时间边界。==其主要思想是鼓励动作部分外的平均分低于动作类内的平均分==。W-TALC [33] 引入一种新的函数来进行K-max多实例学习，挖掘同一类局部实例之间的协同活动关系。为了解决分类器所关心的视频帧的碎片化和动作的完整性问题，Hide-and-seek[30]随机隐藏一些帧，迫使剩余注意力在每次训练中学习辨别度较低的视频帧。虽然，它不能保证在每次训练中都能发现新零件。结果表明，该方法对空间目标检测效果良好，但对时间动作定位效果不佳。Step-by-step erasion, one-by-one collection 对多个分类器进行擦除和训练，直接合并每个分类器的预测片段。性能好了一些，但是它花费更多的时间和计算。随后，CMCS[35]提出了一种具有多样性损失的多分支网络结构，用于动作完整性建模。与此同时，他们提出了一个方案，生成一个hard negative 视频来分离上下文。虽然本文的重点不是背景类，但它启发了接下来的三个作品，即BaSNet[36]，background modeling[37]和LPAT [38]。在没有考虑背景类别的情况下，将背景帧误分类为动作类别，导致大量FPs。在BasNet中，为了构造背景类的负样本，在另一个网络中引入注意模块来抑制背景响应。另外两部作品从不同的角度考虑背景阶级，有效地抑制了背景的影响。最后，它们都提高了定位的准确性。</p>
<p>以下是在THUMOS14数据集上的性能比较，与全监督学习和各种代表性方法发表的标准相同，如表5所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/paper/image-20201115130532292.png" alt=""></p>
<h4 id="3）对W-TAL问题的见解"><a href="#3）对W-TAL问题的见解" class="headerlink" title="3）对W-TAL问题的见解"></a>3）对W-TAL问题的见解</h4><p>近年来，多用例学习(multiple instance learning, MIL)被应用于W-TAL学习中。MIL模型不是使用一组单独标记的实例来学习，而是接收一组标记的包，每个包包含许多实例。如果我们把视频中的动作实例看作一个包，把视频级别的注释看作标签，那么W-TAL可以被表述为一个多实例学习的过程。</p>
<p>时序类激活映射(Temporal class activation mapping，T-CAM)或类激活序列(r Class activation sequence ，CAS)是近年来出现的另一种W-TAL方法。CNN可视化显示，CNN的卷积层作为动作探测器执行，尽管对活动的位置没有监督。类激活序列说明，CNN尽管接受过视频层次标签的训练，但仍然能够具有本地化能力。此外，基于弱监督目标检测的其他研究，如交互式标注和生成对抗训练，也对W-TAL的研究有所启发。</p>
<p>综上所述，弱监督学习降低了劳动和时间成本，但也增加了时间检测的难度。但对于大多数动作类的大多数视频剪辑来说，效果似乎还不错。当然，仍有很大的改进空间</p>
<h2 id="5-未来方向和发展趋势"><a href="#5-未来方向和发展趋势" class="headerlink" title="5.未来方向和发展趋势"></a>5.未来方向和发展趋势</h2><p>时间动作定位的应用实际上会越来越广泛，未来的发展趋势可能集中但不限于以下几方面</p>
<p>a)精度和效率的改进。通过与二维卷积法和三维卷积法的比较，二维卷积法的精度更高，但效率较低。如何更好地发挥二者的优势是一个可能的研究方向</p>
<p>b)动作检测将从时间动作检测扩展到时空动作检测[39]。也就是说，我们应该从一维的时间间隔检测到二维的时空盒，这样可以更全面的检测动作</p>
<p>c)在线视频的动作检测。这是一个处理视频流的过程，需要在线检测动作的类别，但检测时间过后无法知道内容。在线的设置更符合需要实时检测或预警的监控视频的要求，如异常检测[41]。</p>
<p>d)时间动作定位的弱监督学习将会越来越受欢迎。在许多任务中，由于数据标注过程成本高昂，难以获得完整的监管信息。</p>
<p>e)视频是一种包含图像和音频的多模态数据。是否利用音频信息辅助时间动作定位是值得考虑的方向。正如Aytar等人使用图像辅助音频分析[45]。</p>
<h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6.结论"></a>6.结论</h2><p>在本文中，我们对时间动作定位进行了全面的概述。我们从时间划分的角度分析了相关技术:传统方法和深度学习方法。接下来我们总结基准数据集和分析评估指标。然后回顾了时间动作定位从完全监督学习到弱监督学习方法的最新进展。总之，我们试图给出时间行为本土化的相关性和现状。同时，我们也希望对时间动作定位感兴趣的读者有所帮助。</p>
<p>时间动作定位是视频理解领域的一个研究热点，具有很大的复杂性和挑战性。但是，我们相信在不久的将来，深度学习技术的应用可以改善结果，任务也会变得更加容易。</p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>时序动作定位</tag>
        <tag>动作检测</tag>
        <tag>综述</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2024/10/07/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>C++中已经基本不推荐使用裸指针（手动进行<code>new</code>和<code>delete</code>），基本上都是使用智能指针。所以作为C++程序员必须学会智能指针的使用：<code>auto_ptr</code>（已废弃不建议使用）、<code>unique_ptr</code>、<code>share_ptr</code>、<code>weak_ptr</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/智能指针思维导图.png" alt="画板"><br><span id="more"></span></p>
<h2 id="auto-ptr-已废弃"><a href="#auto-ptr-已废弃" class="headerlink" title="auto_ptr(已废弃)"></a><code>auto_ptr</code>(已废弃)</h2><p><code>auto_ptr</code>是C++98标准库中提供的智能指针之一，用于管理动态分配的内存资源。它采用<strong>独占所有权</strong>的方式管理资源，即同一时间只能有一个<code>auto_ptr</code>实例拥有特定资源的所有权。当<code>auto_ptr</code>实例被销毁时，它会自动释放所管理的资源，从而避免了内存泄漏的问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; sp2;</span><br><span class="line">sp2 = sp1;   <span class="comment">// 赋值后sp1为空</span></span><br></pre></td></tr></table></figure>
<p><code>auto_ptr</code>被废弃有一下几个问题：</p>
<ol>
<li>语义不清。当复制一个<code>auto_ptr</code>对象时（拷贝复制或operator =复制），原对象所持有的堆内存对象也会转移给复制出来的对象。这种是复制语义，但是具体实现却是转移（move），语义上就容易让人混淆，让人逻辑上很容易错误，所以后面出现了<code>unique_ptr</code>代替<code>auto_ptr</code></li>
<li>不适用于容器：<code>auto_ptr</code>不能很好地与STL容器一起使用，因为在容器中进行元素的复制或移动操作时会导致指针所有权的转移，可能引发错误。</li>
</ol>
<p><code>auto_ptr</code>了解一下就行，主要感觉八股文考的多一些</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p><code>unique_ptr</code>是C++11标准引入的智能指针之一，它采用<strong>独占所有权</strong>的方式，即同一时间只能有一个<code>unique_ptr</code>实例拥有特定资源的所有权。这意味着在任何时刻只有一个<code>unique_ptr</code>可以指向特定的资源，避免了多重所有权可能引发的问题。<code>unique_ptr</code>可以说是<code>auto_ptr</code>的升级版本。</p>
<p>前面<code>auto_ptr</code>代码使用<code>unique_ptr</code>代替：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;std::string&gt; <span class="title">uptr1</span><span class="params">(<span class="keyword">new</span> std::string(<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">std::unique_ptr&lt;std::string&gt; uptr2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 uptr1 的所有权转移给 uptr2，转移后uptr1为nullptr</span></span><br><span class="line">uptr2 = std::<span class="built_in">move</span>(uptr1);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>auto_ptr</code> 的前车之鉴，<code>unique_ptr</code> 禁止复制语义，为了达到这个效果，<code>std::unique_ptr</code> 类的拷贝构造函数和赋值运算符（<code>operator =</code>）被标记为 <code>delete</code>。<code>unique_ptr</code> 只能通过移动构造或者移动赋值进行转移</li>
<li>自定义删除器。<code>unique_ptr</code>默认的删除器是<code>delete</code>，但是有时候我们想定义自己的删除器，这个也是可以实现的。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用auto和lambda表达式定义自定义删除器</span></span><br><span class="line">    <span class="keyword">auto</span> customDeleter = [](<span class="type">int</span>* ptr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;自定义删除器被调用，释放资源：&quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义删除器</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>, <span class="title">decltype</span><span class="params">(customDeleter)</span>&gt; <span class="title">uptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>), customDeleter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动释放资源</span></span><br><span class="line">    uptr.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>unique_ptr</code>的指针大小和普通指针相等，所以一般没有特殊要求，我们可以使用<code>unique_ptr</code>最节约内存。</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p> <code>unique_ptr</code>其中的源码（visual studio C++20）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span> <span class="comment">/* = default_delete&lt;_Ty&gt; */</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span> &#123; <span class="comment">// non-copyable pointer to an object</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 指针类型</span></span><br><span class="line">    <span class="keyword">using</span> pointer      = <span class="keyword">typename</span> _Get_deleter_pointer_type&lt;_Ty, <span class="type">remove_reference_t</span>&lt;_Dx&gt;&gt;::type;</span><br><span class="line">    <span class="comment">// 元素类型</span></span><br><span class="line">    <span class="keyword">using</span> element_type = _Ty;</span><br><span class="line">    <span class="comment">// 删除器类型</span></span><br><span class="line">    <span class="keyword">using</span> deleter_type = _Dx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dx2</span> = _Dx, _Unique_ptr_enable_default_t&lt;_Dx2&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span> : _Mypair(_Zero_then_variadic_args_t&#123;&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Dx2 = _Dx, _Unique_ptr_enable_default_t&lt;_Dx2&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">unique_ptr</span>(<span class="type">nullptr_t</span>) <span class="keyword">noexcept</span> : _Mypair(_Zero_then_variadic_args_t&#123;&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    _CONSTEXPR23 unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">nullptr_t</span>) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">reset</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The Standard depicts these constructors that accept pointer as taking type_identity_t&lt;pointer&gt; to inhibit CTAD.</span></span><br><span class="line">    <span class="comment">// Since pointer is an opaque type alias in our implementation, it inhibits CTAD without extra decoration.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dx2</span> = _Dx, _Unique_ptr_enable_default_t&lt;_Dx2&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 <span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer _Ptr) <span class="keyword">noexcept</span> : _Mypair(_Zero_then_variadic_args_t&#123;&#125;, _Ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Dx2 = _Dx, <span class="type">enable_if_t</span>&lt;is_constructible_v&lt;_Dx2, <span class="type">const</span> _Dx2&amp;&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 <span class="built_in">unique_ptr</span>(pointer _Ptr, <span class="type">const</span> _Dx&amp; _Dt) <span class="keyword">noexcept</span> : _Mypair(_One_then_variadic_args_t&#123;&#125;, _Dt, _Ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Dx2                                                                            = _Dx,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;negation&lt;is_reference&lt;_Dx2&gt;&gt;, is_constructible&lt;_Dx2, _Dx2&gt;&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 <span class="built_in">unique_ptr</span>(pointer _Ptr, _Dx&amp;&amp; _Dt) <span class="keyword">noexcept</span></span><br><span class="line">        : _Mypair(_One_then_variadic_args_t&#123;&#125;, _STD <span class="built_in">move</span>(_Dt), _Ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Dx2                                                                                      = _Dx,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_reference&lt;_Dx2&gt;, is_constructible&lt;_Dx2, <span class="type">remove_reference_t</span>&lt;_Dx2&gt;&gt;&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">unique_ptr</span>(pointer, <span class="type">remove_reference_t</span>&lt;_Dx&gt;&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dx2</span> = _Dx, <span class="type">enable_if_t</span>&lt;is_move_constructible_v&lt;_Dx2&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 <span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span></span><br><span class="line">        : _Mypair(_One_then_variadic_args_t&#123;&#125;, _STD forward&lt;_Dx&gt;(_Right.<span class="built_in">get_deleter</span>()), _Right.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Ty2, <span class="keyword">class</span> _Dx2,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;</span><br><span class="line">            conjunction_v&lt;negation&lt;is_array&lt;_Ty2&gt;&gt;, is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Ty2, _Dx2&gt;::pointer, pointer&gt;,</span><br><span class="line">                <span class="type">conditional_t</span>&lt;is_reference_v&lt;_Dx&gt;, is_same&lt;_Dx2, _Dx&gt;, is_convertible&lt;_Dx2, _Dx&gt;&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 <span class="built_in">unique_ptr</span>(unique_ptr&lt;_Ty2, _Dx2&gt;&amp;&amp; _Right) <span class="keyword">noexcept</span></span><br><span class="line">        : _Mypair(_One_then_variadic_args_t&#123;&#125;, _STD forward&lt;_Dx2&gt;(_Right.<span class="built_in">get_deleter</span>()), _Right.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Ty2, <span class="keyword">class</span> _Dx2,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;negation&lt;is_array&lt;_Ty2&gt;&gt;, is_assignable&lt;_Dx&amp;, _Dx2&gt;,</span><br><span class="line">                        is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Ty2, _Dx2&gt;::pointer, pointer&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&lt;_Ty2, _Dx2&gt;&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">reset</span>(_Right.<span class="built_in">release</span>());</span><br><span class="line">        _Mypair._Get_first() = _STD forward&lt;_Dx2&gt;(_Right._Mypair._Get_first());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动赋值</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dx2</span> = _Dx, <span class="type">enable_if_t</span>&lt;is_move_assignable_v&lt;_Dx2&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _CONSTEXPR23 unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != _STD <span class="built_in">addressof</span>(_Right)) &#123;</span><br><span class="line">            <span class="built_in">reset</span>(_Right.<span class="built_in">release</span>());</span><br><span class="line">            _Mypair._Get_first() = _STD forward&lt;_Dx&gt;(_Right._Mypair._Get_first());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_CONSTEXPR23 <span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr&amp; _Right)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        _Swap_adl(_Mypair._Myval2, _Right._Mypair._Myval2);</span><br><span class="line">        _Swap_adl(_Mypair._Get_first(), _Right._Mypair._Get_first());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _CONSTEXPR23 ~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Mypair._Myval2) &#123;</span><br><span class="line">            <span class="comment">// 调用 first删除器 删除 指针</span></span><br><span class="line">            _Mypair._Get_first()(_Mypair._Myval2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD _CONSTEXPR23 _Dx&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Mypair._Get_first();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD _CONSTEXPR23 <span class="type">const</span> _Dx&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Mypair._Get_first();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _NODISCARD _CONSTEXPR23 <span class="type">add_lvalue_reference_t</span>&lt;_Ty&gt; <span class="keyword">operator</span>*() <span class="function"><span class="type">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(*_STD declval&lt;pointer&gt;()))</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *_Mypair._Myval2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _NODISCARD _CONSTEXPR23 pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _Mypair._Myval2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD _CONSTEXPR23 pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Mypair._Myval2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_CONSTEXPR23 <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(_Mypair._Myval2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_CONSTEXPR23 pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _STD <span class="built_in">exchange</span>(_Mypair._Myval2, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_CONSTEXPR23 <span class="type">void</span> <span class="title">reset</span><span class="params">(pointer _Ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        pointer _Old = _STD <span class="built_in">exchange</span>(_Mypair._Myval2, _Ptr);</span><br><span class="line">        <span class="keyword">if</span> (_Old) &#123;</span><br><span class="line">            _Mypair._Get_first()(_Old);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制操作设置为delete</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;)            = <span class="keyword">delete</span>;</span><br><span class="line">    unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>, <span class="keyword">class</span>&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">unique_ptr</span>;</span><br><span class="line">    <span class="comment">// _Mypair first是删除器，second是指针</span></span><br><span class="line">    _Compressed_pair&lt;_Dx, pointer&gt; _Mypair;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>unique_ptr</code>实现粗略看比较简单，数据成员比较重要的就是<code>_Mypair</code>，里面存放者删除器和指针，在析构的时候就调用删除器删除指针。</p>
<h2 id="share-ptr"><a href="#share-ptr" class="headerlink" title="share_ptr"></a>share_ptr</h2><p><code>share_ptr</code>通过引用计数的方式来控制资源的释放，允许多个指针指向同一个资源（共享），每多一个<code>std::shared_ptr</code>对资源的引用，资源引用计数将增加1，每一个指向该资源的<code>std::shared_ptr</code>对象析构时，资源引用计数减1，最后一个<code>std::shared_ptr</code>对象析构时，发现资源计数为0，将释放其持有的资源。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化方式1</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方式2</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp2;</span><br><span class="line">sp<span class="number">2.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">123</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方式3</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp3;</span><br><span class="line">sp3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>自定义删除器，<code>shared_ptr</code>自定义删除器比<code>unique_ptr</code> 简单一些，不会影响指针指针的类型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用auto和lambda表达式定义自定义删除器</span></span><br><span class="line">    <span class="keyword">auto</span> customDeleter = [](<span class="type">int</span>* ptr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;自定义删除器被调用，释放资源：&quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用auto和lambda表达式实现自定义删除器的shared_ptr</span></span><br><span class="line">    <span class="keyword">auto</span> sptr = std::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>), customDeleter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用shared_ptr访问资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sptr指向的整数是: &quot;</span> &lt;&lt; *sptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当最后一个shared_ptr销毁时，自定义删除器会被调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在<code>shared_ptr</code>有两个指针，一个指针指向资源，一个指针指向控制块，所以<code>shared_ptr</code>大小其实是普通指针的两倍，并且每次<code>shared_ptr</code>操作都会对控制块进行操作（对引用技术进行操作），所以效率没有<code>unique_ptr</code>高。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/share_ptr示意.png" alt=""></p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>先看类图</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/share_ptr类图.png" alt=""></p>
<ol>
<li><code>shared_ptr</code> 继承<code>_Ptr_base</code>，关于指针和控制块的部分都是在<code>_Ptr_base</code>中，<code>shared_ptr</code>调用<code>_Ptr_base</code>中内容进行引用计算的增加和减少</li>
<li><code>_Ptr_base</code>重要的数据成员：<code>_Ptr</code>、<code>_Rep</code>两个指针一个指向资源、一个指向控制块（<code>_Ref_count_base</code>）</li>
<li><code>_Ref_count_base</code>（控制块）是个纯虚类，里面有uses和weaks两个引用控制块</li>
<li><code>_Ref_count_base</code>有三个实现类<code>_Ref_count</code>、<code>_Ref_count_resource</code>、<code>_Ref_count_resource_alloc</code>，分别代表普通引用计数、带删除器的引用计数、带删除器和分配器的引用计数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> : <span class="keyword">public</span> _Ptr_base&lt;_Ty&gt; &#123; <span class="comment">// class for reference counted resource management</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> _Mybase = _Ptr_base&lt;_Ty&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">typename</span> _Mybase::element_type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _HAS_CXX17</span></span><br><span class="line">    <span class="keyword">using</span> weak_type = weak_ptr&lt;_Ty&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _HAS_CXX17</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">shared_ptr</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">shared_ptr</span><span class="params">(<span class="type">nullptr_t</span>)</span> <span class="keyword">noexcept</span> </span>&#123;&#125; <span class="comment">// construct empty shared_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;<span class="type">conditional_t</span>&lt;is_array_v&lt;_Ty&gt;, _Can_array_delete&lt;_Ux&gt;, _Can_scalar_delete&lt;_Ux&gt;&gt;,</span><br><span class="line">                        _SP_convertible&lt;_Ux, _Ty&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>(_Ux* _Px) &#123; <span class="comment">// construct shared_ptr object that owns _Px</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">constexpr</span> (is_array_v&lt;_Ty&gt;) &#123;</span><br><span class="line">            _Setpd(_Px, default_delete&lt;_Ux[]&gt;&#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _Temporary_owner&lt;_Ux&gt; _Owner(_Px);</span><br><span class="line">            <span class="comment">// 此函数和enable_share_from_this相关</span></span><br><span class="line">            _Set_ptr_rep_and_enable_shared(_Owner._Ptr, <span class="keyword">new</span> _Ref_count&lt;_Ux&gt;(_Owner._Ptr));</span><br><span class="line">            _Owner._Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_move_constructible&lt;_Dx&gt;, _Can_call_function_object&lt;_Dx&amp;, _Ux*&amp;&gt;,</span><br><span class="line">                        _SP_convertible&lt;_Ux, _Ty&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(_Ux* _Px, _Dx _Dt) &#123; <span class="comment">// construct with _Px, deleter</span></span><br><span class="line">        _Setpd(_Px, _STD <span class="built_in">move</span>(_Dt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_move_constructible&lt;_Dx&gt;, _Can_call_function_object&lt;_Dx&amp;, _Ux*&amp;&gt;,</span><br><span class="line">                        _SP_convertible&lt;_Ux, _Ty&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(_Ux* _Px, _Dx _Dt, _Alloc _Ax) &#123; <span class="comment">// construct with _Px, deleter, allocator</span></span><br><span class="line">        _Setpda(_Px, _STD <span class="built_in">move</span>(_Dt), _Ax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dx</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_move_constructible&lt;_Dx&gt;, _Can_call_function_object&lt;_Dx&amp;, <span class="type">nullptr_t</span>&amp;&gt;&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">nullptr_t</span>, _Dx _Dt) &#123; <span class="comment">// construct with nullptr, deleter</span></span><br><span class="line">        _Setpd(<span class="literal">nullptr</span>, _STD <span class="built_in">move</span>(_Dt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dx</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_move_constructible&lt;_Dx&gt;, _Can_call_function_object&lt;_Dx&amp;, <span class="type">nullptr_t</span>&amp;&gt;&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">nullptr_t</span>, _Dx _Dt, _Alloc _Ax) &#123; <span class="comment">// construct with nullptr, deleter, allocator</span></span><br><span class="line">        _Setpda(<span class="literal">nullptr</span>, _STD <span class="built_in">move</span>(_Dt), _Ax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Right, element_type* _Px) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// construct shared_ptr object that aliases _Right</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Alias_construct_from(_Right, _Px);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr&lt;_Ty2&gt;&amp;&amp; _Right, element_type* _Px) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// move construct shared_ptr object that aliases _Right</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Alias_move_construct_from(_STD <span class="built_in">move</span>(_Right), _Px);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&amp; _Other) <span class="keyword">noexcept</span> &#123; <span class="comment">// construct shared_ptr object that owns same resource as _Other</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Copy_construct_from(_Other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// construct shared_ptr object that owns same resource as _Other</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Copy_construct_from(_Other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123; <span class="comment">// construct shared_ptr object that takes resource from _Right</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Move_construct_from(_STD <span class="built_in">move</span>(_Right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr&lt;_Ty2&gt;&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123; <span class="comment">// construct shared_ptr object that takes resource from _Right</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Move_construct_from(_STD <span class="built_in">move</span>(_Right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>(<span class="type">const</span> weak_ptr&lt;_Ty2&gt;&amp; _Other) &#123; <span class="comment">// construct shared_ptr object that owns resource *_Other</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;_Construct_from_weak(_Other)) &#123;</span><br><span class="line">            _Throw_bad_weak_ptr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;_SP_pointer_compatible&lt;_Ux, _Ty&gt;,</span><br><span class="line">                        is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Ux, _Dx&gt;::pointer, element_type*&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="comment">// 从unique_ptr进行构造</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>(unique_ptr&lt;_Ux, _Dx&gt;&amp;&amp; _Other) &#123;</span><br><span class="line">        <span class="keyword">using</span> _Fancy_t   = <span class="keyword">typename</span> unique_ptr&lt;_Ux, _Dx&gt;::pointer;</span><br><span class="line">        <span class="keyword">using</span> _Raw_t     = <span class="keyword">typename</span> unique_ptr&lt;_Ux, _Dx&gt;::element_type*;</span><br><span class="line">        <span class="keyword">using</span> _Deleter_t = <span class="type">conditional_t</span>&lt;is_reference_v&lt;_Dx&gt;, <span class="keyword">decltype</span>(_STD <span class="built_in">ref</span>(_Other.<span class="built_in">get_deleter</span>())), _Dx&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> _Fancy_t _Fancy = _Other.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_Fancy) &#123;</span><br><span class="line">            <span class="type">const</span> _Raw_t _Raw = _Fancy;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> _Rx =</span><br><span class="line">                <span class="keyword">new</span> _Ref_count_resource&lt;_Fancy_t, _Deleter_t&gt;(_Fancy, _STD forward&lt;_Dx&gt;(_Other.<span class="built_in">get_deleter</span>()));</span><br><span class="line">            _Set_ptr_rep_and_enable_shared(_Raw, _Rx);</span><br><span class="line">            _Other.<span class="built_in">release</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构的时候调用_Decref减少引用</span></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() <span class="keyword">noexcept</span> &#123; <span class="comment">// release resource</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Decref();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">shared_ptr</span>(_Right).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">shared_ptr</span>(_Right).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123; <span class="comment">// take resource from _Right</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>(_STD <span class="built_in">move</span>(_Right)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;_Ty2&gt;&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123; <span class="comment">// take resource from _Right</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>(_STD <span class="built_in">move</span>(_Right)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;_SP_pointer_compatible&lt;_Ux, _Ty&gt;,</span><br><span class="line">                        is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Ux, _Dx&gt;::pointer, element_type*&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&lt;_Ux, _Dx&gt;&amp;&amp; _Right) &#123; <span class="comment">// move from unique_ptr</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>(_STD <span class="built_in">move</span>(_Right)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(shared_ptr&amp; _Other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Swap(_Other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// release resource and convert to empty shared_ptr object</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>().<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;<span class="type">conditional_t</span>&lt;is_array_v&lt;_Ty&gt;, _Can_array_delete&lt;_Ux&gt;, _Can_scalar_delete&lt;_Ux&gt;&gt;,</span><br><span class="line">                        _SP_convertible&lt;_Ux, _Ty&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">reset</span>(_Ux* _Px) &#123; <span class="comment">// release, take ownership of _Px</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>(_Px).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_move_constructible&lt;_Dx&gt;, _Can_call_function_object&lt;_Dx&amp;, _Ux*&amp;&gt;,</span><br><span class="line">                        _SP_convertible&lt;_Ux, _Ty&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">reset</span>(_Ux* _Px, _Dx _Dt) &#123; <span class="comment">// release, take ownership of _Px, with deleter _Dt</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>(_Px, _Dt).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>,</span><br><span class="line">        <span class="type">enable_if_t</span>&lt;conjunction_v&lt;is_move_constructible&lt;_Dx&gt;, _Can_call_function_object&lt;_Dx&amp;, _Ux*&amp;&gt;,</span><br><span class="line">                        _SP_convertible&lt;_Ux, _Ty&gt;&gt;,</span><br><span class="line">            <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">reset</span>(_Ux* _Px, _Dx _Dt, _Alloc _Ax) &#123; <span class="comment">// release, take ownership of _Px, with deleter _Dt, allocator _Ax</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>(_Px, _Dt, _Ax).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> _Mybase::get;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span> = _Ty, <span class="type">enable_if_t</span>&lt;!disjunction_v&lt;is_array&lt;_Ty2&gt;, is_void&lt;_Ty2&gt;&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _NODISCARD _Ty2&amp; <span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span> = _Ty, <span class="type">enable_if_t</span>&lt;!is_array_v&lt;_Ty2&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _NODISCARD _Ty2* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span> = _Ty, <span class="keyword">class</span> _Elem = element_type, <span class="type">enable_if_t</span>&lt;is_array_v&lt;_Ty2&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _NODISCARD _Elem&amp; <span class="keyword">operator</span>[](<span class="type">ptrdiff_t</span> _Idx) <span class="type">const</span> <span class="keyword">noexcept</span> <span class="comment">/* strengthened */</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>()[_Idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>() != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_UxptrOrNullptr</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Setpd(<span class="type">const</span> _UxptrOrNullptr _Px, _Dx _Dt) &#123; <span class="comment">// take ownership of _Px, deleter _Dt</span></span><br><span class="line">        _Temporary_owner_del&lt;_UxptrOrNullptr, _Dx&gt; _Owner(_Px, _Dt);</span><br><span class="line">        _Set_ptr_rep_and_enable_shared(</span><br><span class="line">            _Owner._Ptr, <span class="keyword">new</span> _Ref_count_resource&lt;_UxptrOrNullptr, _Dx&gt;(_Owner._Ptr, _STD <span class="built_in">move</span>(_Dt)));</span><br><span class="line">        _Owner._Call_deleter = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_UxptrOrNullptr</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Setpda(<span class="type">const</span> _UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax) &#123; <span class="comment">// take ownership of _Px, deleter _Dt, allocator _Ax</span></span><br><span class="line">        <span class="keyword">using</span> _Alref_alloc = _Rebind_alloc_t&lt;_Alloc, _Ref_count_resource_alloc&lt;_UxptrOrNullptr, _Dx, _Alloc&gt;&gt;;</span><br><span class="line"></span><br><span class="line">        _Temporary_owner_del&lt;_UxptrOrNullptr, _Dx&gt; _Owner(_Px, _Dt);</span><br><span class="line">        _Alref_alloc _Alref(_Ax);</span><br><span class="line">        _Alloc_construct_ptr&lt;_Alref_alloc&gt; _Constructor(_Alref);</span><br><span class="line">        _Constructor._Allocate();</span><br><span class="line">        _Construct_in_place(*_Constructor._Ptr, _Owner._Ptr, _STD <span class="built_in">move</span>(_Dt), _Ax);</span><br><span class="line">        _Set_ptr_rep_and_enable_shared(_Owner._Ptr, _Unfancy(_Constructor._Ptr));</span><br><span class="line">        _Constructor._Ptr    = <span class="literal">nullptr</span>;</span><br><span class="line">        _Owner._Call_deleter = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ux</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Set_ptr_rep_and_enable_shared(_Ux* <span class="type">const</span> _Px, _Ref_count_base* <span class="type">const</span> _Rx) <span class="keyword">noexcept</span> &#123; <span class="comment">// take ownership of _Px</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Ptr = _Px;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Rep = _Rx;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(conjunction_v&lt;negation&lt;is_array&lt;_Ty&gt;&gt;, negation&lt;is_volatile&lt;_Ux&gt;&gt;, _Can_enable_shared&lt;_Ux&gt;&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (_Px &amp;&amp; _Px-&gt;_Wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">                _Px-&gt;_Wptr = shared_ptr&lt;<span class="type">remove_cv_t</span>&lt;_Ux&gt;&gt;(*<span class="keyword">this</span>, <span class="keyword">const_cast</span>&lt;<span class="type">remove_cv_t</span>&lt;_Ux&gt;*&gt;(_Px));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Set_ptr_rep_and_enable_shared(<span class="type">nullptr_t</span>, _Ref_count_base* <span class="type">const</span> _Rx) <span class="keyword">noexcept</span> &#123; <span class="comment">// take ownership of nullptr</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Rep = _Rx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Ptr_base</span> &#123; <span class="comment">// base class for shared_ptr and weak_ptr</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> element_type = <span class="type">remove_extent_t</span>&lt;_Ty&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Rep ? _Rep-&gt;_Use_count() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="function">_NODISCARD <span class="type">bool</span> <span class="title">owner_before</span><span class="params">(<span class="type">const</span> _Ptr_base&lt;_Ty2&gt;&amp; _Right)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// compare addresses of manager objects</span></span><br><span class="line">        <span class="keyword">return</span> _Rep &lt; _Right._Rep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Ptr_base(<span class="type">const</span> _Ptr_base&amp;)            = <span class="keyword">delete</span>;</span><br><span class="line">    _Ptr_base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> _Ptr_base&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">_NODISCARD element_type* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> _Ptr_base() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    ~_Ptr_base() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Move_construct_from(_Ptr_base&lt;_Ty2&gt;&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement shared_ptr&#x27;s (converting) move ctor and weak_ptr&#x27;s move ctor</span></span><br><span class="line">        _Ptr = _Right._Ptr;</span><br><span class="line">        _Rep = _Right._Rep;</span><br><span class="line"></span><br><span class="line">        _Right._Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        _Right._Rep = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Copy_construct_from(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement shared_ptr&#x27;s (converting) copy ctor</span></span><br><span class="line">        _Other._Incref();</span><br><span class="line"></span><br><span class="line">        _Ptr = _Other._Ptr;</span><br><span class="line">        _Rep = _Other._Rep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Alias_construct_from(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Other, element_type* _Px) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement shared_ptr&#x27;s aliasing ctor</span></span><br><span class="line">        _Other._Incref();</span><br><span class="line"></span><br><span class="line">        _Ptr = _Px;</span><br><span class="line">        _Rep = _Other._Rep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Alias_move_construct_from(shared_ptr&lt;_Ty2&gt;&amp;&amp; _Other, element_type* _Px) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement shared_ptr&#x27;s aliasing move ctor</span></span><br><span class="line">        _Ptr = _Px;</span><br><span class="line">        _Rep = _Other._Rep;</span><br><span class="line"></span><br><span class="line">        _Other._Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        _Other._Rep = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty0</span>&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">weak_ptr</span>; <span class="comment">// specifically, weak_ptr::lock()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">bool</span> _Construct_from_weak(<span class="type">const</span> weak_ptr&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement shared_ptr&#x27;s ctor from weak_ptr, and weak_ptr::lock()</span></span><br><span class="line">        <span class="keyword">if</span> (_Other._Rep &amp;&amp; _Other._Rep-&gt;_Incref_nz()) &#123;</span><br><span class="line">            _Ptr = _Other._Ptr;</span><br><span class="line">            _Rep = _Other._Rep;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// User增加引用计数</span></span><br><span class="line">    <span class="type">void</span> _Incref() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Rep) &#123;</span><br><span class="line">            _Rep-&gt;_Incref();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// User减少引用计数</span></span><br><span class="line">    <span class="type">void</span> _Decref() <span class="keyword">noexcept</span> &#123; <span class="comment">// decrement reference count</span></span><br><span class="line">        <span class="keyword">if</span> (_Rep) &#123;</span><br><span class="line">            _Rep-&gt;_Decref();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Swap(_Ptr_base&amp; _Right) <span class="keyword">noexcept</span> &#123; <span class="comment">// swap pointers</span></span><br><span class="line">        <span class="function">_STD <span class="title">swap</span><span class="params">(_Ptr, _Right._Ptr)</span></span>;</span><br><span class="line">        <span class="function">_STD <span class="title">swap</span><span class="params">(_Rep, _Right._Rep)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Weakly_construct_from(<span class="type">const</span> _Ptr_base&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123; <span class="comment">// implement weak_ptr&#x27;s ctors</span></span><br><span class="line">        <span class="keyword">if</span> (_Other._Rep) &#123;</span><br><span class="line">            _Ptr = _Other._Ptr;</span><br><span class="line">            _Rep = _Other._Rep;</span><br><span class="line">            _Rep-&gt;_Incwref();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _STL_INTERNAL_CHECK(!_Ptr &amp;&amp; !_Rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Weakly_convert_lvalue_avoiding_expired_conversions(<span class="type">const</span> _Ptr_base&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement weak_ptr&#x27;s copy converting ctor</span></span><br><span class="line">        <span class="keyword">if</span> (_Other._Rep) &#123;</span><br><span class="line">            _Rep = _Other._Rep; <span class="comment">// always share ownership</span></span><br><span class="line">            _Rep-&gt;_Incwref();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_Rep-&gt;_Incref_nz()) &#123;</span><br><span class="line">                _Ptr = _Other._Ptr; <span class="comment">// keep resource alive during conversion, handling virtual inheritance</span></span><br><span class="line">                _Rep-&gt;_Decref();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _STL_INTERNAL_CHECK(!_Ptr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _STL_INTERNAL_CHECK(!_Ptr &amp;&amp; !_Rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">void</span> _Weakly_convert_rvalue_avoiding_expired_conversions(_Ptr_base&lt;_Ty2&gt;&amp;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// implement weak_ptr&#x27;s move converting ctor</span></span><br><span class="line">        _Rep        = _Other._Rep; <span class="comment">// always transfer ownership</span></span><br><span class="line">        _Other._Rep = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_Rep &amp;&amp; _Rep-&gt;_Incref_nz()) &#123;</span><br><span class="line">            _Ptr = _Other._Ptr; <span class="comment">// keep resource alive during conversion, handling virtual inheritance</span></span><br><span class="line">            _Rep-&gt;_Decref();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _STL_INTERNAL_CHECK(!_Ptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _Other._Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// weaks增加引用计数</span></span><br><span class="line">    <span class="type">void</span> _Incwref() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Rep) &#123;</span><br><span class="line">            _Rep-&gt;_Incwref();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// weaks减少引用计数</span></span><br><span class="line">    <span class="type">void</span> _Decwref() <span class="keyword">noexcept</span> &#123; <span class="comment">// decrement weak reference count</span></span><br><span class="line">        <span class="keyword">if</span> (_Rep) &#123;</span><br><span class="line">            _Rep-&gt;_Decwref();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 智能指针关联的原始指针</span></span><br><span class="line">    element_type* _Ptr&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="comment">// 管理智能指针的 控制块</span></span><br><span class="line">    _Ref_count_base* _Rep&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__declspec</span>(novtable) _Ref_count_base &#123; <span class="comment">// common code for reference counting</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_CEE_PURE</span></span><br><span class="line">    <span class="comment">// permanent workaround to avoid mentioning _purecall in msvcurt.lib, ptrustu.lib, or other support libs</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _Destroy() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="function">_STD <span class="title">terminate</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _Delete_this() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="function">_STD <span class="title">terminate</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// ^^^ _M_CEE_PURE / !_M_CEE_PURE vvv</span></span></span><br><span class="line">   <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _Destroy() <span class="keyword">noexcept</span>     = <span class="number">0</span>; <span class="comment">// destroy managed resource</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _Delete_this() <span class="keyword">noexcept</span> = <span class="number">0</span>; <span class="comment">// destroy self</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _M_CEE_PURE</span></span></span><br><span class="line">    <span class="comment">// 强指针的引用计数（原子）</span></span><br><span class="line">    _Atomic_counter_t _Uses  = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 弱指针的引用计数（原子）</span></span><br><span class="line">    _Atomic_counter_t _Weaks = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">constexpr</span> _Ref_count_base() <span class="keyword">noexcept</span> = <span class="keyword">default</span>; <span class="comment">// non-atomic initializations</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 不允许复制</span></span><br><span class="line">    _Ref_count_base(<span class="type">const</span> _Ref_count_base&amp;)            = <span class="keyword">delete</span>;</span><br><span class="line">    _Ref_count_base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> _Ref_count_base&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~_Ref_count_base() <span class="keyword">noexcept</span> &#123;&#125; <span class="comment">// TRANSITION, should be non-virtual</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> _Incref_nz() <span class="keyword">noexcept</span> &#123; <span class="comment">// increment use count if not zero, return true if successful</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; _Volatile_uses = <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">volatile</span> <span class="type">long</span>&amp;&gt;(_Uses);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_CEE_PURE</span></span><br><span class="line">        <span class="type">long</span> _Count = *_Atomic_address_as&lt;<span class="type">const</span> <span class="type">long</span>&gt;(&amp;_Volatile_uses);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="type">long</span> _Count = __iso_volatile_load32(<span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">volatile</span> <span class="type">int</span>*&gt;(&amp;_Volatile_uses));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">while</span> (_Count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">long</span> _Old_value = _INTRIN_RELAXED(_InterlockedCompareExchange)(&amp;_Volatile_uses, _Count + <span class="number">1</span>, _Count);</span><br><span class="line">            <span class="keyword">if</span> (_Old_value == _Count) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _Count = _Old_value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Incref() <span class="keyword">noexcept</span> &#123; <span class="comment">// increment use count</span></span><br><span class="line">        _MT_INCR(_Uses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Incwref() <span class="keyword">noexcept</span> &#123; <span class="comment">// increment weak reference count</span></span><br><span class="line">        _MT_INCR(_Weaks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Decref() <span class="keyword">noexcept</span> &#123; <span class="comment">// decrement use count</span></span><br><span class="line">        <span class="keyword">if</span> (_MT_DECR(_Uses) == <span class="number">0</span>) &#123;</span><br><span class="line">            _Destroy();</span><br><span class="line">            _Decwref();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Decwref() <span class="keyword">noexcept</span> &#123; <span class="comment">// decrement weak reference count</span></span><br><span class="line">        <span class="keyword">if</span> (_MT_DECR(_Weaks) == <span class="number">0</span>) &#123;</span><br><span class="line">            _Delete_this();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> _Use_count() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(_Uses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span>* _Get_deleter(<span class="type">const</span> type_info&amp;) <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不带删除器的引用计数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Ref_count</span> : <span class="keyword">public</span> _Ref_count_base &#123; <span class="comment">// handle reference counting for pointer without deleter</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> _Ref_count(_Ty* _Px) : _Ref_count_base(), _Ptr(_Px) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> _Destroy() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123; <span class="comment">// destroy managed resource</span></span><br><span class="line">        <span class="keyword">delete</span> _Ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Delete_this() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123; <span class="comment">// destroy self</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Ty* _Ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 带删除器的引用计数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Resource</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Ref_count_resource</span> : <span class="keyword">public</span> _Ref_count_base &#123; <span class="comment">// handle reference counting for object with deleter</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _Ref_count_resource(_Resource _Px, _Dx _Dt)</span><br><span class="line">        : _Ref_count_base(), _Mypair(_One_then_variadic_args_t&#123;&#125;, _STD <span class="built_in">move</span>(_Dt), _Px) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __EDG__ <span class="comment">// TRANSITION, VSO-1292293</span></span></span><br><span class="line">    ~_Ref_count_resource() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123;&#125; <span class="comment">// TRANSITION, should be non-virtual</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// ^^^ workaround / no workaround vvv</span></span></span><br><span class="line">    ~_Ref_count_resource() <span class="keyword">noexcept</span> <span class="keyword">override</span> = <span class="keyword">default</span>; <span class="comment">// TRANSITION, should be non-virtual</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ^^^ no workaround ^^^</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* _Get_deleter(<span class="type">const</span> type_info&amp; _Typeid) <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _HAS_STATIC_RTTI</span></span><br><span class="line">        <span class="keyword">if</span> (_Typeid == <span class="built_in">typeid</span>(_Dx)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;_Dx*&gt;(_STD <span class="built_in">addressof</span>(_Mypair._Get_first()));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// _HAS_STATIC_RTTI</span></span></span><br><span class="line">        (<span class="type">void</span>) _Typeid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _HAS_STATIC_RTTI</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> _Destroy() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123; <span class="comment">// destroy managed resource</span></span><br><span class="line">        _Mypair._Get_first()(_Mypair._Myval2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Delete_this() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123; <span class="comment">// destroy self</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Compressed_pair&lt;_Dx, _Resource&gt; _Mypair;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带删除器和分配器 的 引用计数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Resource</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Ref_count_resource_alloc</span> : <span class="keyword">public</span> _Ref_count_base &#123;</span><br><span class="line">    <span class="comment">// handle reference counting for object with deleter and allocator</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _Ref_count_resource_alloc(_Resource _Px, _Dx _Dt, <span class="type">const</span> _Alloc&amp; _Ax)</span><br><span class="line">        : _Ref_count_base(),</span><br><span class="line">          _Mypair(_One_then_variadic_args_t&#123;&#125;, _STD <span class="built_in">move</span>(_Dt), _One_then_variadic_args_t&#123;&#125;, _Ax, _Px) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __EDG__ <span class="comment">// TRANSITION, VSO-1292293</span></span></span><br><span class="line">    ~_Ref_count_resource_alloc() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123;&#125; <span class="comment">// TRANSITION, should be non-virtual</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// ^^^ workaround / no workaround vvv</span></span></span><br><span class="line">    ~_Ref_count_resource_alloc() <span class="keyword">noexcept</span> <span class="keyword">override</span> = <span class="keyword">default</span>; <span class="comment">// TRANSITION, should be non-virtual</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ^^^ no workaround ^^^</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* _Get_deleter(<span class="type">const</span> type_info&amp; _Typeid) <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _HAS_STATIC_RTTI</span></span><br><span class="line">        <span class="keyword">if</span> (_Typeid == <span class="built_in">typeid</span>(_Dx)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;_Dx*&gt;(_STD <span class="built_in">addressof</span>(_Mypair._Get_first()));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// _HAS_STATIC_RTTI</span></span></span><br><span class="line">        (<span class="type">void</span>) _Typeid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _HAS_STATIC_RTTI</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> _Myalty = _Rebind_alloc_t&lt;_Alloc, _Ref_count_resource_alloc&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Destroy() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123; <span class="comment">// destroy managed resource</span></span><br><span class="line">        _Mypair._Get_first()(_Mypair._Myval<span class="number">2.</span>_Myval2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _Delete_this() <span class="keyword">noexcept</span> <span class="keyword">override</span> &#123; <span class="comment">// destroy self</span></span><br><span class="line">        _Myalty _Al = _Mypair._Myval<span class="number">2.</span>_Get_first();</span><br><span class="line">        <span class="keyword">this</span>-&gt;~_Ref_count_resource_alloc();</span><br><span class="line">        _Deallocate_plain(_Al, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Compressed_pair&lt;_Dx, _Compressed_pair&lt;_Myalty, _Resource&gt;&gt; _Mypair;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><code>std::weak_ptr</code> 是 C++ 标准库中的智能指针，用于解决 <code>std::shared_ptr</code> 的循环引用（circular reference）问题。<code>std::weak_ptr</code> 是一种弱引用，不会增加引用计数，也不会拥有被管理的对象。它通常用于解决由 <code>std::shared_ptr</code> 形成的循环引用导致的内存泄漏问题，简单来说<code>weak_ptr</code>就是用来配合<code>share_ptr</code>一起进行使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::weak_ptr&lt;Person&gt; partner;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; n) : <span class="built_in">name</span>(n) &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is created\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Person&gt; alice = std::<span class="built_in">make_shared</span>&lt;Person&gt;(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    std::shared_ptr&lt;Person&gt; bob = std::<span class="built_in">make_shared</span>&lt;Person&gt;(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    alice-&gt;partner = bob;</span><br><span class="line">    bob-&gt;partner = alice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 weak_ptr 创建 shared_ptr，避免循环引用</span></span><br><span class="line">    std::shared_ptr&lt;Person&gt; alicePartner = alice-&gt;partner.<span class="built_in">lock</span>();</span><br><span class="line">    std::shared_ptr&lt;Person&gt; bobPartner = bob-&gt;partner.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alicePartner &amp;&amp; bobPartner) &#123;</span><br><span class="line">        std::cout &lt;&lt; alice-&gt;name &lt;&lt; <span class="string">&quot;&#x27;s partner is: &quot;</span> &lt;&lt; alicePartner-&gt;name &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; bob-&gt;name &lt;&lt; <span class="string">&quot;&#x27;s partner is: &quot;</span> &lt;&lt; bobPartner-&gt;name &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;One of the partners is no longer available\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过前面<code>share_ptr</code>源码的理解，我们也能猜测<code>weak_ptr</code>是通过控制块中<code>weaks</code>进行控制的，从源码角度来说<code>weak_ptr</code>代码里面应该是对<code>weaks</code>进行控制，当有一个新的<code>weak_ptr</code>指向<code>share_ptr</code>式，<code>weaks</code>数量进行增加，</p>
<p>所以内存释放来说：</p>
<ul>
<li>当<code>Uses</code> 为0时，<code>share_ptr</code>指向资源会进行释放</li>
<li>当<code>weaks</code>为0时，控制块内存才最终进行了释放</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">weak_ptr</span> : <span class="keyword">public</span> _Ptr_base&lt;_Ty&gt; &#123; <span class="comment">// class for pointer to reference counted resource</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _M_CEE_PURE</span></span><br><span class="line">    <span class="comment">// When a constructor is converting from weak_ptr&lt;_Ty2&gt; to weak_ptr&lt;_Ty&gt;, the below type trait intentionally asks</span></span><br><span class="line">    <span class="comment">// whether it would be possible to static_cast from _Ty* to const _Ty2*; see N4901 [expr.static.cast]/11.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Primary template, the value is used when the substitution fails.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="keyword">class</span> = <span class="type">const</span> _Ty2*&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> _Must_avoid_expired_conversions_from = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Template specialization, the value is used when the substitution succeeds.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span></span><br><span class="line">        _Must_avoid_expired_conversions_from&lt;_Ty2, <span class="keyword">decltype</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> _Ty2*&gt;(<span class="built_in">static_cast</span>&lt;_Ty*&gt;(<span class="literal">nullptr</span>)))&gt; =</span><br><span class="line">            <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _M_CEE_PURE</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">weak_ptr</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">weak_ptr</span>(<span class="type">const</span> weak_ptr&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Weakly_construct_from(_Other); <span class="comment">// same type, no conversion</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">weak_ptr</span>(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Weakly_construct_from(_Other); <span class="comment">// shared_ptr keeps resource alive during conversion</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">weak_ptr</span>(<span class="type">const</span> weak_ptr&lt;_Ty2&gt;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_CEE_PURE</span></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">bool</span> _Avoid_expired_conversions = <span class="literal">true</span>; <span class="comment">// slow, but always safe; avoids error LNK1179</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// _M_CEE_PURE</span></span></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">bool</span> _Avoid_expired_conversions = _Must_avoid_expired_conversions_from&lt;_Ty2&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _M_CEE_PURE</span></span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_Avoid_expired_conversions)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_Weakly_convert_lvalue_avoiding_expired_conversions(_Other);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_Weakly_construct_from(_Other);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">weak_ptr</span>(weak_ptr&amp;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Move_construct_from(_STD <span class="built_in">move</span>(_Other));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    <span class="built_in">weak_ptr</span>(weak_ptr&lt;_Ty2&gt;&amp;&amp; _Other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_CEE_PURE</span></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">bool</span> _Avoid_expired_conversions = <span class="literal">true</span>; <span class="comment">// slow, but always safe; avoids error LNK1179</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// _M_CEE_PURE</span></span></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">bool</span> _Avoid_expired_conversions = _Must_avoid_expired_conversions_from&lt;_Ty2&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _M_CEE_PURE</span></span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_Avoid_expired_conversions)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_Weakly_convert_rvalue_avoiding_expired_conversions(_STD <span class="built_in">move</span>(_Other));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_Move_construct_from(_STD <span class="built_in">move</span>(_Other));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减少weaks引用计数</span></span><br><span class="line">    ~<span class="built_in">weak_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Decwref();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> weak_ptr&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">weak_ptr</span>(_Right).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> weak_ptr&lt;_Ty2&gt;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">weak_ptr</span>(_Right).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span>=(weak_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">weak_ptr</span>(_STD <span class="built_in">move</span>(_Right)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span>=(weak_ptr&lt;_Ty2&gt;&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">weak_ptr</span>(_STD <span class="built_in">move</span>(_Right)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty2</span>, <span class="type">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;_Ty2&gt;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">weak_ptr</span>(_Right).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// release resource, convert to null weak_ptr object</span></span><br><span class="line">        weak_ptr&#123;&#125;.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(weak_ptr&amp; _Other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Swap(_Other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">bool</span> <span class="title">expired</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">use_count</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD shared_ptr&lt;_Ty&gt; <span class="title">lock</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// convert to shared_ptr</span></span><br><span class="line">        shared_ptr&lt;_Ty&gt; _Ret;</span><br><span class="line">        (<span class="type">void</span>) _Ret._Construct_from_weak(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> _Ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="make-unique和make-shared"><a href="#make-unique和make-shared" class="headerlink" title="make_unique和make_shared"></a><code>make_unique</code>和<code>make_shared</code></h2><p>现代C++建议多使用<code>make_unique</code>和<code>make_shared</code>，原因主要是两点</p>
<ul>
<li><strong>性能优势</strong>：<code>std::make_shared</code>可以在单个内存分配中<strong>同时分配控制块和对象内存</strong>，而直接使用<code>std::shared_ptr</code>则需要分别进行两次内存分配。这样可以提高内存访问的效率并减少内存碎片。（仅仅针对<code>make_shared</code>）</li>
<li><strong>异常安全性</strong>：<code>std::make_shared</code>可以确保在内存分配失败时不会泄漏内存，因为它是原子操作，要么成功创建<code>std::shared_ptr</code>，要么不创建，不会出现中间状态。</li>
</ul>
<p>第二点异常安全性的解释：</p>
<p>假设我们有个函数按照某种优先级处理<code>Widget</code>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw, <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure><br>现在假设我们有一个函数来计算相关的优先级，<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">computePriority</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>并且我们在调用<code>processWidget</code>时使用了<code>new</code>而不是<code>std::make_shared</code>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget),  <span class="comment">//潜在的资源泄漏！</span></span><br><span class="line">              <span class="built_in">computePriority</span>());</span><br></pre></td></tr></table></figure><br>在运行时，一个函数的实参必须先被计算，这个函数再被调用，所以在调用<code>processWidget</code>之前，必须执行以下操作，<code>processWidget</code>才开始执行：</p>
<ul>
<li>表达式<code>new Widget</code>必须计算，例如，一个<code>Widget</code>对象必须在堆上被创建</li>
<li>负责管理<code>new</code>出来指针的<code>std::shared_ptr&lt;Widget&gt;</code>构造函数必须被执行</li>
<li><code>computePriority</code>必须运行</li>
</ul>
<p>编译器不需要按照执行顺序生成代码。<code>new Widget</code>必须在<code>std::shared_ptr</code>的构造函数被调用前执行，因为<code>new</code>出来的结果作为构造函数的实参，但<code>computePriority</code>可能在这之前，之后，或者之间执行。也就是说，编译器可能按照这个执行顺序生成代码：</p>
<ol>
<li>执行<code>new Widget</code></li>
<li>执行<code>computePriority</code></li>
<li>运行<code>std::shared_ptr</code>构造函数<br>如果按照这样生成代码，并且在运行时<code>computePriority</code>产生了异常，那么第一步动态分配的<code>Widget</code>就会泄漏。因为它永远都不会被第三步的<code>std::shared_ptr</code>所管理了。<br>使用<code>std::make_shared</code>可以防止这种问题。调用代码看起来像是这样：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">make_shared</span>&lt;Widget&gt;(),   <span class="comment">//没有潜在的资源泄漏</span></span><br><span class="line">    <span class="built_in">computePriority</span>());</span><br></pre></td></tr></table></figure>
在运行时，<code>std::make_shared</code>和<code>computePriority</code>其中一个会先被调用。如果是<code>std::make_shared</code>先被调用，在<code>computePriority</code>调用前，动态分配<code>Widget</code>的原始指针会安全的保存在作为返回值的<code>std::shared_ptr</code>中。如果<code>computePriority</code>产生一个异常，那么<code>std::shared_ptr</code>析构函数将确保管理的<code>Widget</code>被销毁。如果首先调用<code>computePriority</code>并产生一个异常，那么<code>std::make_shared</code>将不会被调用，因此也就不需要担心动态分配<code>Widget</code>（会泄漏）。<br>当然除了使用<code>std::make_shared&lt;Widget&gt;()</code>，还有其他解法比如：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(spw, <span class="built_in">computePriority</span>());  <span class="comment">// 正确，但是没优化，见下</span></span><br></pre></td></tr></table></figure>
但是能够一行代码解释清楚最好还是使用一行代码，所以还是建议使用<code>make_shared</code></li>
</ol>
<h3 id="make-shared不适用场景"><a href="#make-shared不适用场景" class="headerlink" title="make_shared不适用场景"></a>make_shared不适用场景</h3><ol>
<li>需要自定义删除器。make函数不能自定义删除器</li>
<li>需要精确精确的分配、释放对象大小的内存（重载了<code>operator new</code>和<code>operator delete</code>）的类，因为make_shared，因为make_shared使用std::allocate_shared进行内存分配，<code>std::allocate_shared</code>需要的内存总大小不等于动态分配的对象大小，还需要再加上控制块大小</li>
<li>对于大对象来说，<code>std::weak_ptr</code>s比对应的<code>std::shared_ptr</code>s活得更久的情况也不建议使用make_shared。因为make_shared申请的内存是包括资源和内存块的内容，只有最后一个<code>std::shared_ptr</code>和最后一个指向它的<code>std::weak_ptr</code>已被销毁，整块内存才会释放。而普通的方式创建的<code>shared_ptr</code>，最后一个<code>shared_ptr</code>被销毁就将对象的内存销毁了，控制块的还保留</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReallyBigType</span> &#123; … &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pBigObj =                          <span class="comment">//通过std::make_shared</span></span><br><span class="line">    std::<span class="built_in">make_shared</span>&lt;ReallyBigType&gt;();  <span class="comment">//创建一个大对象</span></span><br><span class="line">                    </span><br><span class="line">…           <span class="comment">//创建std::shared_ptrs和std::weak_ptrs</span></span><br><span class="line">            <span class="comment">//指向这个对象，使用它们</span></span><br><span class="line"></span><br><span class="line">…           <span class="comment">//最后一个std::shared_ptr在这销毁，</span></span><br><span class="line">            <span class="comment">//但std::weak_ptrs还在</span></span><br><span class="line"></span><br><span class="line">…           <span class="comment">//在这个阶段，原来分配给大对象的内存还分配着</span></span><br><span class="line"></span><br><span class="line">…           <span class="comment">//最后一个std::weak_ptr在这里销毁；</span></span><br><span class="line">            <span class="comment">//控制块和对象的内存被释放</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReallyBigType</span> &#123; … &#125;;              <span class="comment">//和之前一样</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;ReallyBigType&gt; <span class="title">pBigObj</span><span class="params">(<span class="keyword">new</span> ReallyBigType)</span></span>;</span><br><span class="line">                                        <span class="comment">//通过new创建大对象</span></span><br><span class="line"></span><br><span class="line">…           <span class="comment">//像之前一样，创建std::shared_ptrs和std::weak_ptrs</span></span><br><span class="line">            <span class="comment">//指向这个对象，使用它们</span></span><br><span class="line">            </span><br><span class="line">…           <span class="comment">//最后一个std::shared_ptr在这销毁,</span></span><br><span class="line">            <span class="comment">//但std::weak_ptrs还在；</span></span><br><span class="line">            <span class="comment">//对象的内存被释放</span></span><br><span class="line"></span><br><span class="line">…           <span class="comment">//在这阶段，只有控制块的内存仍然保持分配</span></span><br><span class="line"></span><br><span class="line">…           <span class="comment">//最后一个std::weak_ptr在这里销毁；</span></span><br><span class="line">            <span class="comment">//控制块内存被释放</span></span><br></pre></td></tr></table></figure>
<h2 id="enable-share-from-this"><a href="#enable-share-from-this" class="headerlink" title="enable_share_from_this"></a>enable_share_from_this</h2><p>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个<strong>std::shared_ptr</strong>对象给外部使用，这个时候我们就需要enable_shared_from_this。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">getShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, this is MyClass!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个std::shared_ptr指向MyClass对象</span></span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用getShared()函数获取指向当前对象的std::shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr2 = ptr-&gt;<span class="built_in">getShared</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用ptr2调用对象的成员函数</span></span><br><span class="line">    ptr2-&gt;<span class="built_in">printMessage</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码分析：</p>
<p><code>enable_shared_from_this</code>中有一个<code>_Wptr</code>，将<code>_Wptr</code>和<code>this</code>对应的<code>share_ptr</code>进行关联，从而后续通过<code>shared_from_this</code>从此<code>_Wptr</code>得到<code>share_ptr</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">enable_shared_from_this</span> &#123; <span class="comment">// provide member functions that create shared_ptr to this</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在_Can_enable_shared中使用</span></span><br><span class="line">    <span class="keyword">using</span> _Esft_type = enable_shared_from_this;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD shared_ptr&lt;_Ty&gt; <span class="title">shared_from_this</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Ty&gt;(_Wptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD shared_ptr&lt;<span class="type">const</span> _Ty&gt; <span class="title">shared_from_this</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> _Ty&gt;(_Wptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD weak_ptr&lt;_Ty&gt; <span class="title">weak_from_this</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Wptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD weak_ptr&lt;<span class="type">const</span> _Ty&gt; <span class="title">weak_from_this</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Wptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">enable_shared_from_this</span><span class="params">()</span> <span class="keyword">noexcept</span> : _Wptr() &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">enable_shared_from_this</span>(<span class="type">const</span> enable_shared_from_this&amp;) <span class="keyword">noexcept</span> : _Wptr() &#123;</span><br><span class="line">        <span class="comment">// construct (must value-initialize _Wptr)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enable_shared_from_this&amp; <span class="keyword">operator</span>=(<span class="type">const</span> enable_shared_from_this&amp;) <span class="keyword">noexcept</span> &#123; <span class="comment">// assign (must not change _Wptr)</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">enable_shared_from_this</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yty</span>&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">shared_ptr</span>;</span><br><span class="line">    <span class="comment">// 弱指针</span></span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Ty&gt; _Wptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么这个是什么时候将<code>_Wptr</code>和<code>share_ptr</code> 关联的呢？是通过<code>_Set_ptr_rep_and_enable_shared</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Ux* _Px)</span> </span>&#123; <span class="comment">// construct shared_ptr object that owns _Px</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_array_v&lt;_Ty&gt;)</span> </span>&#123;</span><br><span class="line">            _Setpd(_Px, default_delete&lt;_Ux[]&gt;&#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _Temporary_owner&lt;_Ux&gt; _Owner(_Px);</span><br><span class="line">            <span class="comment">// 此函数和enable_share_from_this相关</span></span><br><span class="line">            _Set_ptr_rep_and_enable_shared(_Owner._Ptr, <span class="keyword">new</span> _Ref_count&lt;_Ux&gt;(_Owner._Ptr));</span><br><span class="line">            _Owner._Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>_Set_ptr_rep_and_enable_shared</code>函数中会进行判断，如果是<code>_Can_enable_shared</code>就会关联</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _Set_ptr_rep_and_enable_shared(_Ux* <span class="type">const</span> _Px, _Ref_count_base* <span class="type">const</span> _Rx) <span class="keyword">noexcept</span> &#123; <span class="comment">// take ownership of _Px</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_Ptr = _Px;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Rep = _Rx;</span><br><span class="line">    <span class="comment">//在这个函数中</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(conjunction_v&lt;negation&lt;is_array&lt;_Ty&gt;&gt;, negation&lt;is_volatile&lt;_Ux&gt;&gt;, _Can_enable_shared&lt;_Ux&gt;&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (_Px &amp;&amp; _Px-&gt;_Wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">                <span class="comment">//将_Wptr和shared_ptr关联</span></span><br><span class="line">                _Px-&gt;_Wptr = shared_ptr&lt;<span class="type">remove_cv_t</span>&lt;_Ux&gt;&gt;(*<span class="keyword">this</span>, <span class="keyword">const_cast</span>&lt;<span class="type">remove_cv_t</span>&lt;_Ux&gt;*&gt;(_Px));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>_Can_enable_shared</code>的实现使用了<code>SFINAE</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yty</span>, <span class="keyword">class</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> _Can_enable_shared : false_type &#123;&#125;; <span class="comment">// detect unambiguous and accessible inheritance from enable_shared_from_this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yty</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Can_enable_shared</span>&lt;_Yty, <span class="type">void_t</span>&lt;<span class="keyword">typename</span> _Yty::_Esft_type&gt;&gt;</span><br><span class="line">    : is_convertible&lt;<span class="type">remove_cv_t</span>&lt;_Yty&gt;*, <span class="keyword">typename</span> _Yty::_Esft_type*&gt;::type &#123;</span><br><span class="line">    <span class="comment">// is_convertible is necessary to verify unambiguous inheritance</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>先说结论<strong>智能指针</strong>线程不安全。</p>
<p><code>share_ptr</code>有两部分指向资源的指针 和指向控制块的指针，其中控制块部分中<strong>引用计数</strong>是原子的操作可以说它是安全的，其他部分都没有保障，比如指针的指向。</p>
<p>所以智能指针是线程不安全的</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/share_ptr示意.png" alt=""></p>
<p>想要对智能指针安全操作可以参考muduo代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/智能指针多线程1.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/cpp/智能指针多线程2.png" alt=""></p>
<h2 id="智能指针自己的实现"><a href="#智能指针自己的实现" class="headerlink" title="智能指针自己的实现"></a>智能指针自己的实现</h2><h3 id="unique-ptr实现"><a href="#unique-ptr实现" class="headerlink" title="unique_ptr实现"></a>unique_ptr实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KSmartPointUni</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">KSmartPointUni</span>();</span><br><span class="line">	<span class="built_in">KSmartPointUni</span>(T* ptr);</span><br><span class="line">	~<span class="built_in">KSmartPointUni</span>();</span><br><span class="line">	<span class="built_in">KSmartPointUni</span>(KSmartPointUni&amp;&amp; ptr);</span><br><span class="line">	KSmartPointUni&amp; <span class="keyword">operator</span>=(KSmartPointUni&amp;&amp; ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">KSmartPointUni</span>(<span class="type">const</span> KSmartPointUni&amp; ptr) = <span class="keyword">delete</span>; <span class="comment">// 不允许拷贝</span></span><br><span class="line">	KSmartPointUni&amp; <span class="keyword">operator</span>=(<span class="type">const</span> KSmartPointUni&amp; ptr) = <span class="keyword">delete</span>;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="type">const</span>; <span class="comment">// 返回*m_ptr对象</span></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>; <span class="comment">// 返回m_ptr对象</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> KSmartPointUni&lt;T&gt;::<span class="built_in">KSmartPointUni</span>() :<span class="built_in">m_ptr</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> KSmartPointUni&lt;T&gt;::<span class="built_in">KSmartPointUni</span>(T* ptr) : <span class="built_in">m_ptr</span>(ptr)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> KSmartPointUni&lt;T&gt;::~<span class="built_in">KSmartPointUni</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> KSmartPointUni&lt;T&gt;::<span class="built_in">KSmartPointUni</span>(KSmartPointUni&lt;T&gt;&amp;&amp; ptr)</span><br><span class="line">&#123;</span><br><span class="line">	m_ptr = ptr.m_ptr;</span><br><span class="line">	ptr.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> KSmartPointUni&lt;T&gt;&amp; KSmartPointUni&lt;T&gt;::<span class="keyword">operator</span>=(KSmartPointUni&amp;&amp; ptr)</span><br><span class="line">&#123;</span><br><span class="line">	m_ptr = ptr.m_ptr;</span><br><span class="line">	ptr.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> T&amp; KSmartPointUni&lt;T&gt;::<span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> T* KSmartPointUni&lt;T&gt;::<span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="share-ptr的实现"><a href="#share-ptr的实现" class="headerlink" title="share_ptr的实现"></a>share_ptr的实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySharedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MySharedPtr</span>(T* ptr = <span class="literal">nullptr</span>); <span class="comment">//构造</span></span><br><span class="line">	~<span class="built_in">MySharedPtr</span>(); <span class="comment">// 析构</span></span><br><span class="line">	<span class="built_in">MySharedPtr</span>(<span class="type">const</span> MySharedPtr&lt;T&gt;&amp; sp);</span><br><span class="line">	MySharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MySharedPtr&lt;T&gt;&amp; sp);</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*(); <span class="comment">// 返回*m_ptr对象</span></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;(); <span class="comment">// 返回m_ptr对象</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">useCount</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 采取引用计数</span></span><br><span class="line">	T* m_ptr;</span><br><span class="line">    <span class="comment">// 控制块</span></span><br><span class="line">	<span class="type">int</span>* m_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> MySharedPtr&lt;T&gt;::<span class="built_in">MySharedPtr</span>(T* ptr) :<span class="built_in">m_ptr</span>(ptr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		m_count = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_count = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> MySharedPtr&lt;T&gt;::~<span class="built_in">MySharedPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line">	(*m_count)--;</span><br><span class="line">	<span class="keyword">if</span> ((*m_count) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_count)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_ptr;</span><br><span class="line">			m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (m_count)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_count;</span><br><span class="line">			m_count = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> MySharedPtr&lt;T&gt;::<span class="built_in">MySharedPtr</span>(<span class="type">const</span> MySharedPtr&lt;T&gt;&amp; sp)</span><br><span class="line">&#123;</span><br><span class="line">	m_ptr = sp.m_ptr;</span><br><span class="line">	m_count = sp.m_count;</span><br><span class="line">	(*m_count)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> MySharedPtr&lt;T&gt;&amp; MySharedPtr&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> MySharedPtr&lt;T&gt;&amp; sp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;sp) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	(*m_count)--;</span><br><span class="line">	<span class="keyword">if</span> ((*m_count) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_ptr)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_ptr;</span><br><span class="line">			m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (m_count)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_count;</span><br><span class="line">			m_count = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	m_ptr = sp.m_ptr;</span><br><span class="line">	m_count = sp.m_count;</span><br><span class="line">	(*m_count)++;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> T&amp; MySharedPtr&lt;T&gt;::<span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> T* MySharedPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> MySharedPtr&lt;T&gt;::<span class="built_in">useCount</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *m_count;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> T* MySharedPtr&lt;T&gt;::<span class="built_in">get</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解计算机系统第3章练习题</title>
    <url>/2022/10/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统第3章练习题"><a href="#深入理解计算机系统第3章练习题" class="headerlink" title="深入理解计算机系统第3章练习题"></a>深入理解计算机系统第3章练习题</h1><h2 id="练习题3-1假设下面的值存放在指明的内存地址和寄存器中"><a href="#练习题3-1假设下面的值存放在指明的内存地址和寄存器中" class="headerlink" title="练习题3.1假设下面的值存放在指明的内存地址和寄存器中:"></a>练习题3.1假设下面的值存放在指明的内存地址和寄存器中:</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221025203611818.png" alt="image-20221025203611818"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作数</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%rax</td>
<td style="text-align:center">0x100</td>
</tr>
<tr>
<td style="text-align:center">0x104</td>
<td style="text-align:center">0xAB</td>
</tr>
<tr>
<td style="text-align:center">$0x108</td>
<td style="text-align:center">0x108</td>
</tr>
<tr>
<td style="text-align:center">(%rax)</td>
<td style="text-align:center">0xFF</td>
</tr>
<tr>
<td style="text-align:center">4(%rax)</td>
<td style="text-align:center">0xAB</td>
</tr>
<tr>
<td style="text-align:center">9(%rax,%rdx)</td>
<td style="text-align:center">0x11</td>
</tr>
<tr>
<td style="text-align:center">260(%rcx,%rdx)</td>
<td style="text-align:center">0x13</td>
</tr>
<tr>
<td style="text-align:center">0xFC(,%rcx,4)</td>
<td style="text-align:center">0xFF</td>
</tr>
<tr>
<td style="text-align:center">(%rax,%rdx,4)</td>
<td style="text-align:center">0x11</td>
</tr>
</tbody>
</table>
</div>
<span id="more"></span>
<h2 id="练习题3-2对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。-例如，mov-可以被重写成movb、movw、movl或者movq。）"><a href="#练习题3-2对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。-例如，mov-可以被重写成movb、movw、movl或者movq。）" class="headerlink" title="练习题3.2对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。(例如，mov 可以被重写成movb、movw、movl或者movq。）"></a>练习题3.2对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。(例如，mov 可以被重写成movb、movw、movl或者movq。）</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221025222250940.png" alt="image-20221025222250940"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl %eax, (%rsp)		;%eax是2个字的，传输2字，所以是movl</span><br><span class="line">movw (%rax), %dx		;%dx是1个字的，传输1字，所以是movw</span><br><span class="line">movb $0xFF, %b1			;%b1是1个字节的，传输1字，所以是movb</span><br><span class="line">movb (%rsp,%rdx,4), %dl ;%dl是1个字的，传输1字，所以是movb</span><br><span class="line">movq (%rdx), %rax		;%rax是4个字的，传输1字，所以是movq</span><br><span class="line">movbw %dx, (%rax)		;%dx是1个字的，传输1字，所以是movw</span><br></pre></td></tr></table></figure>
<h2 id="练习题3-3当我们调用汇编器的时候，下面代码的每一行都会产生一个错误消息。解释每一行都是哪里出了错。"><a href="#练习题3-3当我们调用汇编器的时候，下面代码的每一行都会产生一个错误消息。解释每一行都是哪里出了错。" class="headerlink" title="练习题3.3当我们调用汇编器的时候，下面代码的每一行都会产生一个错误消息。解释每一行都是哪里出了错。"></a>练习题3.3当我们调用汇编器的时候，下面代码的每一行都会产生一个错误消息。解释每一行都是哪里出了错。</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221026110728710.png" alt="image-20221026110728710"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movb $0xF, (%ebx) 		;内存引用的寄存器必须是四个字的，改成movb $0xF, (%rbx)</span><br><span class="line">movl %rax, (%rsp) 		;%rax是四个字而l代表两个字，改成movl %eax, (%rsp) 或者 movq %rax, (%rsp)</span><br><span class="line">movw (%rax), 4(%rsp)	;两个操作数不能都是内存引用</span><br><span class="line">movb %al, %sl			;没有寄存器名字叫%sl</span><br><span class="line">movq %rax,$0x123		;立即数不能作为des操作数</span><br><span class="line">movl %eax, %rdx			;答案上说目标操作数大小不正确（destination operand incorrect size），这个有点不太理解</span><br><span class="line">movb %si, 8(%rbp)		;%si是一个字而b代表一个字节，改成movb %sil, 8(%rbp) 或者 movw %si, 8(%rbp)</span><br></pre></td></tr></table></figure>
<h2 id="练习题3-4假设变量sp和dp被声明为类型"><a href="#练习题3-4假设变量sp和dp被声明为类型" class="headerlink" title="练习题3.4假设变量sp和dp被声明为类型"></a>练习题3.4假设变量sp和dp被声明为类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">src_t</span> *sp;</span><br><span class="line"><span class="type">dest_t</span> *dp;</span><br></pre></td></tr></table></figure>
<p>这里src_t和dest_t是用typedef声明的数据类型。我们想使用适当的数据传送指令来实现下面的操作;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*dp = (<span class="type">dest_t</span>) *sp;</span><br></pre></td></tr></table></figure>
<p>假设 sp 和 dp 的值分别存储在寄存器 %rdi 和 %rsi 中。对于表中的每个表项，给出实现指定数据传送的两条指令。其中第一条指令应该从内存中读数，做适当的转换，并设置寄存器 %rax 的适当部分。然后，第二条指令要把 %rax 的适当部分写到内存。在这两种情况中，寄存器的部分可以是 %rax、%eax、%ax 或 %al，两者可以互不相同。</p>
<p>记住，当执行强制类型转换既涉及大小变化又涉及 C 语言中符号变化时，操作应该先改变大小。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">src_t</th>
<th style="text-align:center">dest_t</th>
<th style="text-align:left">指令</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">long</td>
<td style="text-align:left">movq (%rdi), %rax <br/>movq %rax, (%rsi)</td>
<td style="text-align:center">long 为 8 字节，目标字节数也为 8，所以都用 movq 。</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">int</td>
<td style="text-align:left">movsbl (%rdi), %eax<br/> movl %eax, (%rsi)</td>
<td style="text-align:center">因为源有符号，所以用 movs 。又因为是 char 到 int ，所以使用 bl 。</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">unsigned</td>
<td style="text-align:left">movsbl (%rdi), %eax<br/> movl %eax, (%rsi)</td>
<td style="text-align:center">同上。</td>
</tr>
<tr>
<td style="text-align:center">unsigned char</td>
<td style="text-align:center">long</td>
<td style="text-align:left">movzbl (%rdi), %eax<br/> movq %rax, (%rsi)</td>
<td style="text-align:center">需要把字节扩展成四字，由于是 unsigned，所以用零扩展。</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">char</td>
<td style="text-align:left">movl (%rdi), %edx<br/> movb %al, (%rsi)</td>
<td style="text-align:center">原始字节还是要读出来的，但是只传送低位字节，即按目标大小进行截断。源有无符号无所谓。</td>
</tr>
<tr>
<td style="text-align:center">unsigned</td>
<td style="text-align:center">unsigned char</td>
<td style="text-align:left">movl (%rdi), %al<br/> movb %al, (%rsi)</td>
<td style="text-align:center">本质同上。</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">short</td>
<td style="text-align:left">movsbw (%rdi), %ax<br/> movw %ax, (%rsi)</td>
<td style="text-align:center">需要进行符号拓展。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题3-5已知信息如下。将一个原型为"><a href="#练习题3-5已知信息如下。将一个原型为" class="headerlink" title="练习题3.5已知信息如下。将一个原型为"></a>练习题3.5已知信息如下。将一个原型为</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">decode1</span><span class="params">(<span class="type">long</span> *p, <span class="type">long</span> *yp, <span class="type">long</span> *zp)</span>;</span><br></pre></td></tr></table></figure>
<p>的函数编译成汇编代码，得到如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  void decode1(1ong *xp, long *yp, long *zp);</span><br><span class="line">  xp in %rdi, yp in %rsi, zp in %rdx</span><br><span class="line">decode1:</span><br><span class="line">  movq  (%rdi), %r8</span><br><span class="line">  movq  (%rsi), %rcx</span><br><span class="line">  movq  (%rdx), %rax</span><br><span class="line">  movq  %r8, (%rsi)</span><br><span class="line">  movq  (%rcx), (%rdx)</span><br><span class="line">  movq  (%rax), (%rdi)</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>参数 xp、yp 和 zp 分别存储在对应的寄存器 %rdi、%rsi 和 %rdx 中。</p>
<p>请写出等效于上面汇编代码的 decode1 的 C 代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">decode1</span><span class="params">(<span class="type">long</span> *p, <span class="type">long</span> *yp, <span class="type">long</span> *zp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> x = *xp;</span><br><span class="line">	<span class="type">long</span> y = *yp;</span><br><span class="line">	<span class="type">long</span> z = *zp;</span><br><span class="line">	</span><br><span class="line">    *yp = x;</span><br><span class="line">    *zp = y;</span><br><span class="line">    *xp = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题3-6-假设寄存器-rax-的值为-x，-rcx-的值为-y。填写下表，指明下面每条汇编代码指令存储在寄存器-rdx-中的值："><a href="#练习题3-6-假设寄存器-rax-的值为-x，-rcx-的值为-y。填写下表，指明下面每条汇编代码指令存储在寄存器-rdx-中的值：" class="headerlink" title="练习题3.6 假设寄存器 %rax 的值为 x，%rcx 的值为 y。填写下表，指明下面每条汇编代码指令存储在寄存器 %rdx 中的值："></a>练习题3.6 假设寄存器 %rax 的值为 x，%rcx 的值为 y。填写下表，指明下面每条汇编代码指令存储在寄存器 %rdx 中的值：</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">leaq 6 (%rax), %rdx</td>
<td style="text-align:center"><code>x + 6</code></td>
</tr>
<tr>
<td style="text-align:center">leaq (%rax, %rcx), %rdx</td>
<td style="text-align:center"><code>x + y</code></td>
</tr>
<tr>
<td style="text-align:center">leaq (%rax, %rcx, 4), %rdx</td>
<td style="text-align:center"><code>x + 4y</code></td>
</tr>
<tr>
<td style="text-align:center">leaq 7 (%rax, %rax, 8), %rdx</td>
<td style="text-align:center"><code>9x + 7</code></td>
</tr>
<tr>
<td style="text-align:center">leaq 0xA (, %rcx, 4), %rdx</td>
<td style="text-align:center"><code>4y + 10</code></td>
</tr>
<tr>
<td style="text-align:center">leaq 9 (%rax, %rcx, 2), %rdx</td>
<td style="text-align:center"><code>x + 2y + 9</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题3-7考虑下面的代码，我们省略了被计算的表达式："><a href="#练习题3-7考虑下面的代码，我们省略了被计算的表达式：" class="headerlink" title="练习题3.7考虑下面的代码，我们省略了被计算的表达式："></a>练习题3.7考虑下面的代码，我们省略了被计算的表达式：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">scale2</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = ____________________;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 GCC 编译实际的函数得到如下的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  long scale2(long x, long y, long z)</span><br><span class="line">  x in %rdi, y in %rsi, z in %rdx</span><br><span class="line">scale2:</span><br><span class="line">  leaq  (%rdi, %rdi, 4), %rax</span><br><span class="line">  leaq  (%rax, %rsi, 2), %rax</span><br><span class="line">  leaq  (%rax, %rdx, 8), %rax</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>填写出 C 代码中缺失的表达式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> t = <span class="number">5</span>*x + <span class="number">2</span>*y + <span class="number">8</span>*z</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-8-假设下面的值存放指定的内存地址和寄存器中："><a href="#练习题-3-8-假设下面的值存放指定的内存地址和寄存器中：" class="headerlink" title="练习题 3.8 假设下面的值存放指定的内存地址和寄存器中："></a>练习题 3.8 假设下面的值存放指定的内存地址和寄存器中：</h2><p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221027211920652.png" alt="image-20221027211920652"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221027211934019.png" alt="image-20221027211934019"></p>
<p>填写下表，给出下面指令的效果，说明将被更新的寄存器或内存位置，以及得到的值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">目的</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">addq %rcx, (%rax)</td>
<td style="text-align:center">0x100</td>
<td style="text-align:center">0xFF + 0x1 = 0x100</td>
</tr>
<tr>
<td style="text-align:center">subq %rdx, 8 (%rax)</td>
<td style="text-align:center">0x108</td>
<td style="text-align:center">0xAB - 0x3 = 0xA8</td>
</tr>
<tr>
<td style="text-align:center">imulq $16, (%rax, %rdx, 8)</td>
<td style="text-align:center">0x100 + 0x3 * 8 = 0x118</td>
<td style="text-align:center">0x11 * 16 = 0x110</td>
</tr>
<tr>
<td style="text-align:center">incq 16 (%rax)</td>
<td style="text-align:center">0x110</td>
<td style="text-align:center">0x14</td>
</tr>
<tr>
<td style="text-align:center">decq %rcx</td>
<td style="text-align:center">%rcx</td>
<td style="text-align:center">0x0</td>
</tr>
<tr>
<td style="text-align:center">subq %rdx, %rax</td>
<td style="text-align:center">%rax</td>
<td style="text-align:center">0x0FD</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-9设我们想生成以下-C-函数的汇编代码："><a href="#练习题-3-9设我们想生成以下-C-函数的汇编代码：" class="headerlink" title="练习题 3.9设我们想生成以下 C 函数的汇编代码："></a>练习题 3.9设我们想生成以下 C 函数的汇编代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">shift_left4_rightn</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    x &lt;&lt;= <span class="number">4</span>;</span><br><span class="line">    x &gt;&gt;= n;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这段汇编代码执行实际的移位，并将最后的结果放在寄存器 %rax 中。此处省略了两条关键的指令。参数 x 和 n 分别存放在寄存器 %rdi 和 %rsi 中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  long shift_left4_rightn(long x, long n)</span><br><span class="line">  x in %rdi, n in %rsi</span><br><span class="line">shift_left4_rightn:</span><br><span class="line">  movq  %rdi, %rax    Get x</span><br><span class="line">  ________________    x &lt;&lt;= 4</span><br><span class="line">  movl  %esi, %ecx    Get n (4 bytes)</span><br><span class="line">  ________________    x &gt;&gt;= n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据右边的注释，填出缺失的指令。请使用算术右移操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">salq  $4, %rax      x &lt;&lt;= 4</span><br><span class="line">sarq  %cl, %rax     x &gt;&gt;= n</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-10-下面的函数是图3-11a中函数一个变种，其中有些表达式用空格替代"><a href="#练习题-3-10-下面的函数是图3-11a中函数一个变种，其中有些表达式用空格替代" class="headerlink" title="练习题 3.10 下面的函数是图3-11a中函数一个变种，其中有些表达式用空格替代:"></a>练习题 3.10 下面的函数是图3-11a中函数一个变种，其中有些表达式用空格替代:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">arith2</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t1 = _____;</span><br><span class="line">    <span class="type">long</span> t2 = _____;</span><br><span class="line">    <span class="type">long</span> t3 = _____;</span><br><span class="line">    <span class="type">long</span> t4 = _____;</span><br><span class="line">    <span class="keyword">return</span> t4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现这些表达式的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  long arith2(long x, long y, long z)</span><br><span class="line">  x in %rdi, y in %rsi, z in %rdx</span><br><span class="line">arith2:</span><br><span class="line">  orq   %rsi, %rdi</span><br><span class="line">  sarq  $3, %rdi</span><br><span class="line">  notq  %rdi</span><br><span class="line">  movq  %rdx, %rax</span><br><span class="line">  subq  %rdi, %rax</span><br><span class="line">  ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基于这些汇编代码，填写 C 语言代码中缺失的部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> t1 = x | y;</span><br><span class="line"><span class="type">long</span> t2 = t1 &gt;&gt; <span class="number">3</span>;</span><br><span class="line"><span class="type">long</span> t3 = ~ t2;</span><br><span class="line"><span class="type">long</span> t4 = z - t3;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-11常常可以看见以下形式的汇编代码行："><a href="#练习题-3-11常常可以看见以下形式的汇编代码行：" class="headerlink" title="练习题 3.11常常可以看见以下形式的汇编代码行："></a>练习题 3.11常常可以看见以下形式的汇编代码行：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xorq %rdx, %rdx</span><br></pre></td></tr></table></figure>
<p>但是在产生这段汇编代码的 C 代码中，并没有出现 EXCLUSIVE-OR 操作。</p>
<p>A. 解释这条特殊的 EXCLUSIVE-OR 指令的效果，它实现了什么有用的操作。</p>
<p>B. 更直接地表达这个操作的汇编代码是什么？</p>
<p>C. 比较同样一个操作的两种不同实现的编码字节长度。</p>
<blockquote>
<p>A. 这个指令用来将寄存器 %rdx 设置为 0，运用了对任意 x，x^x=0 这一属性。它对应于 C 语句 x=0 。</p>
<p>B. 将寄存器 %rdx 设置为 0 的更直接的方法是用指令 movq $0, %rdx 。</p>
<p>C. 汇编和反汇编这段代码，我们发现使用 xorq 的版本只需要 3 个字节，而使用 movq 的版本需要 7 个字节。其他将 %rdx 设置为 0 的方法都依赖于这样一个属性，即任何更新低位 4 字节的指令都会把高位字节设置为 0 。因此，我们可以使用 xorl %edx, %edx（2 字节）或 movl $0, %edx（5 字节）。</p>
</blockquote>
<h2 id="练习题-3-12-考虑如下函数，它计算两个无符号-64-位数的商和余数："><a href="#练习题-3-12-考虑如下函数，它计算两个无符号-64-位数的商和余数：" class="headerlink" title="练习题 3.12 考虑如下函数，它计算两个无符号 64 位数的商和余数："></a>练习题 3.12 考虑如下函数，它计算两个无符号 64 位数的商和余数：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uremdiv</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x, <span class="type">unsigned</span> <span class="type">long</span> y, <span class="type">unsigned</span> <span class="type">long</span> *qp, <span class="type">unsigned</span> <span class="type">long</span> *rp)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> q = x / y;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r = x % y;</span><br><span class="line">    *qp = q;</span><br><span class="line">    *rp = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改有符号除法的汇编代码来实现这个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  void uremdiv(unsigned long x, unsigned long y, unsigned long *qp, unsigned long *rp)</span><br><span class="line">  x in %rdi, y in %rsi, qp in %rdx, rp in %rcx</span><br><span class="line">uremdiv:</span><br><span class="line">  movq  %rdx, %r8      Copy qp</span><br><span class="line">  movq  %rdi, %rax     Move x to lower 8 bytes of dividend</span><br><span class="line">  movl  $0, %edx       Set upper 8 bytes of divended to 0</span><br><span class="line">  divq  %rsi           Divide by y</span><br><span class="line">  movq  %rax, (%r8)    Store quotient at qp</span><br><span class="line">  movq  %rdx, (%rcx)   Store remainder at rp</span><br><span class="line">  ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-13-虑下列的-C-语言代码："><a href="#练习题-3-13-虑下列的-C-语言代码：" class="headerlink" title="练习题 3.13 虑下列的 C 语言代码："></a>练习题 3.13 虑下列的 C 语言代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(<span class="type">data_t</span> a, <span class="type">data_t</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a COMP b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它给出了参数 a 和 b 之间比较的一般形式，这里，参数的数据类型 <code>data_t</code>（通过 <code>typedef</code>）被声明为表 3-1 中列出的某种整数类型，可以是有符号的也可以是无符号的。 COMP 通过 <code>#define</code> 来定义。</p>
<p>假设 a 在 %rdi 中某个部分，b 在 %rsi 中某个部分。对于下面每个指令序列，确定哪种数据类型 <code>data_t</code> 和比较 COMP 会导致编译器产生这样的代码。（可能有多个正确答案，请列出所有的正确答案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221030184524281.png" alt="image-20221030184524281"></p>
<p>A.后缀 ‘l’ 和寄存器指示符表明是 32 位操作数，而且调用的是有符号的小于比较。所以 <code>data_t</code> 一定是 int 。</p>
<p>B.后缀 ‘w’ 和寄存器指示符表明是 16 位操作数，而且调用的是有符号的大于等于。所以 <code>data_t</code> 一定是 short。</p>
<p>C.后缀 ‘b’ 和寄存器指示符表明是 8 位操作数，而且调用的是无符号小于等于。所以 <code>data_t</code> 一定是 unsigned char 。</p>
<p>D.后缀 ‘q’ 和寄存器指示符表明是 64 位操作数，同时比较符号是 <code>!=</code> ，有符号、无符号和指针参数都是一样的。所以 <code>data_t</code> 可以是 long、unsigned long 或 char * 。</p>
<h2 id="练习题-3-14-考虑下面的-C-语言代码："><a href="#练习题-3-14-考虑下面的-C-语言代码：" class="headerlink" title="练习题 3.14 考虑下面的 C 语言代码："></a>练习题 3.14 考虑下面的 C 语言代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">data_t</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a TEST <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它给出了参数 a 和 0 之间比较的一般形式，这里，我们可以用 <code>typedef</code> 来声明 <code>data_t</code> ，从而设置参数的数据类型，用 <code>#define</code> 来声明 TEST，从而设置比较的类型。对于下面每个指令序列，确定哪种数据类型 <code>data_t</code> 和比较 <code>TEST</code> 会导致编译器产生这样的代码。（可能有多个正确答案，请列出所有的正确答案。）</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221030192217880.png" alt="image-20221030192217880"></p>
<p>A.后缀 ‘q’ 和寄存器指示符表明是 64 位操作数，而且调用有符号大于等于，所以 <code>data_t</code> 一定是 long 。</p>
<p>B.后缀 ‘w’ 和寄存器指示符表明是 16 位操作数，比较符 <code>==</code> 对于有无符号都是一样的。所以 <code>data_t</code> 可以是 <code>short</code> 或者 <code>unsigned short</code> 。</p>
<p>C.后缀 ‘b’ 和寄存器指示符表明是 8 位操作数，使用的是无符号大于，所以 <code>data_t</code> 一定是 <code>unsigned char</code> 。</p>
<p>D.后缀 ‘l’ 和寄存器指示符表明是 32 位操作数，使用的是带符号的小于等于，所以 <code>data_t</code> 一定是 <code>int</code> 。</p>
<h2 id="练习题-3-15在下面这些反汇编二进制代码节选中，有些信息被-X-代替了。回答下列关于这些指令的问题。"><a href="#练习题-3-15在下面这些反汇编二进制代码节选中，有些信息被-X-代替了。回答下列关于这些指令的问题。" class="headerlink" title="练习题 3.15在下面这些反汇编二进制代码节选中，有些信息被 X 代替了。回答下列关于这些指令的问题。"></a>练习题 3.15在下面这些反汇编二进制代码节选中，有些信息被 X 代替了。回答下列关于这些指令的问题。</h2><p>A. 下面 je 指令的目标是什么？（在此，你不需要知道任何有关 callq 指令的信息。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4003fa: 74 02    je    XXXXXX</span><br><span class="line">4003fc: ff do    callq *%rax</span><br></pre></td></tr></table></figure>
<p>je 指令的目标为 <code>0x4003fc + 0x02 = 0x4003fe</code> 。</p>
<p>B. 下面 je 指令的目标是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40042f: 74 f4    je   XXXXXX</span><br><span class="line">400431: 5d       pop  %rbp</span><br></pre></td></tr></table></figure>
<p>je 指令的目标为 <code>0x400431 - 12（由于 0xf4 是 -12 的一个字节的补码表示）= 0x400425</code> 。</p>
<p>C. ja 和 pop 指令的地址是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XXXXXX: 77 02    ja   400547</span><br><span class="line">XXXXXX: 5d       pop  %rbp</span><br></pre></td></tr></table></figure>
<p>跳转目标是绝对地址 <code>0x400547</code> 。根据字节编码，一定在距离 pop 指令 <code>0x2</code> 的地址处。所以，pop 指令地址为 <code>0x400547 - 0x2 = 0x400545</code> 。<strong>注意，ja 指令的编码需要 2 个字节。</strong>所以 ja 指令的地址为 <code>0x400543</code> 处。</p>
<p>D. 在下面的代码中，跳转目标的编码是 PC 相对的，且是一个 4 字节补码数。字节按照从最低位到最高位的顺序列出，反映出 x86-64 的小端法字节顺序。跳转目标的地址是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4005e8: e9 73 ff ff ff     jmp  XXXXXX</span><br><span class="line">4005ed: 90                 nop</span><br></pre></td></tr></table></figure>
<p>以相反的顺序来读这些字节，我们看到目标偏移量是 <code>0xffffff73</code> ，或者十进制数 <code>-141</code> 。所以跳转目标为 <code>0x4005ed - 141 = 0x400560</code> 。</p>
<h2 id="练习题-3-16已知下列-C-代码："><a href="#练习题-3-16已知下列-C-代码：" class="headerlink" title="练习题 3.16已知下列 C 代码："></a>练习题 3.16已知下列 C 代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cond</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; a &gt; *p)</span><br><span class="line">        *p = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 会产生下面的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># void cond(long a, long *p)</span><br><span class="line"># a in %rdi, p in %rsi</span><br><span class="line">cond:</span><br><span class="line">  testq  %rsi, %rsi   # 测试 p</span><br><span class="line">  je     .L1          # 如果是 0 就跳转到 L1 </span><br><span class="line">  comq   %rdi, (%rsi) # 比较 *p 和 a</span><br><span class="line">  jge    .L1          # 如果 *p &gt;= a，跳转到 L1</span><br><span class="line">  movq   %rdi, (%rsi) # *p = a</span><br><span class="line">.L1:</span><br><span class="line">  rep; ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. 按照图 3-16b 中所示的风格，用 C 语言写一个 goto 版本，执行同样的计算，并模拟汇编代码的控制流。像示例中那样给汇编代码加上注解可能会有所帮助。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">goto_cond</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    <span class="keyword">if</span> (*p &gt;= a)</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    *p = a;</span><br><span class="line">  done:</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>B. 请说明为什么 C 语言代码中只有一个 if 语句，而汇编代码包含两个条件分支。</p>
<p>第一个条件分支是 &amp;&amp; 表达式实现的一部分。如果对 p 为非空的测试失败，代码会跳过对 <code>a &gt; *p</code> 的测试。</p>
<h2 id="练习题-3-17将-if-语句翻译成-goto-代码的另一种可行的规则如下："><a href="#练习题-3-17将-if-语句翻译成-goto-代码的另一种可行的规则如下：" class="headerlink" title="练习题 3.17将 if 语句翻译成 goto 代码的另一种可行的规则如下："></a>练习题 3.17将 if 语句翻译成 goto 代码的另一种可行的规则如下：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    t = test-expr;</span><br><span class="line">    if (t)</span><br><span class="line">        goto true;</span><br><span class="line">    else-statement</span><br><span class="line">    goto done;</span><br><span class="line">true:</span><br><span class="line">    then-statement</span><br><span class="line">done:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. 基于这种规则，重写 absdiff_se 的 goto 版本。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">gotodiff_se_alt</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">        <span class="keyword">goto</span> x_lt_y;</span><br><span class="line">    go_cnt++</span><br><span class="line">    result = x - y;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">x_lt_y:</span><br><span class="line">    lt_cnt++;</span><br><span class="line">    result = y - x;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B. 你能想出选用一种规则而不选用另一种规则的理由吗？</p>
<p>大多数情况下，可以在这两种方式中任意选择。但是原来的方法对常见的没有 else 语句的情况更好一些。对于这种情况，我们只用简单地将翻译规则修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    t = test-expr;</span><br><span class="line">    if (!t)</span><br><span class="line">        goto done;</span><br><span class="line">    then-statement</span><br><span class="line">done:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-18从如下形式的-C-语言代码开始："><a href="#练习题-3-18从如下形式的-C-语言代码开始：" class="headerlink" title="练习题 3.18从如下形式的 C 语言代码开始："></a>练习题 3.18从如下形式的 C 语言代码开始：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">test</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = ___________;</span><br><span class="line">    <span class="keyword">if</span> (______) &#123;</span><br><span class="line">        <span class="keyword">if</span> (______)</span><br><span class="line">            val = ______;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            val = ______;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (______)</span><br><span class="line">        val = ______;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 产生如下的汇编代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># long test(long x, long y, long z)</span></span><br><span class="line"><span class="meta"># x in %rdi, y in %rsi, z in %rdx</span></span><br><span class="line">test:</span><br><span class="line">  leaq  (%rdi, %rsi), %rax  <span class="meta"># long temp1 = x + y</span></span><br><span class="line">  addq  %rdx, %rax          # temp1 = temp1 + z</span><br><span class="line">  cmpq  $<span class="number">-3</span>, %rdi           # 比较 x 和 <span class="number">-3</span></span><br><span class="line">  jge   .L2                 <span class="meta"># x &gt;= -3 时跳转到 L2</span></span><br><span class="line">  cmpq  %rdx, %rsi          # 比较 y 和 z</span><br><span class="line">  jge   .L3                 <span class="meta"># y &gt;= z 时跳转到 L3</span></span><br><span class="line">  movq  %rdi, %rax          # temp1 = x</span><br><span class="line">  imulq %rsi, %rax          # temp1 = temp1 * y</span><br><span class="line">  ret                       <span class="meta"># return</span></span><br><span class="line">.L3:</span><br><span class="line">  movq  %rsi, %rax          # 此时 x &lt; <span class="number">-3</span>，y &gt;= z；temp1 = y</span><br><span class="line">  imulq %rdx, %rax          # temp1 = temp1 * z</span><br><span class="line">  ret                       <span class="meta"># return</span></span><br><span class="line">.L2:</span><br><span class="line">  cmpq  $<span class="number">2</span>, %rdi            # 此时 x &gt;= <span class="number">-3</span>；比较 x 和 <span class="number">2</span></span><br><span class="line">  jle   .L4                 <span class="meta"># x &lt;= 2 时跳转到 L4</span></span><br><span class="line">  movq  %rdi, %rax          # temp1 = x</span><br><span class="line">  imulq %rdx, %rax          # temp1 = temp1 * z</span><br><span class="line">.L4:</span><br><span class="line">  rep; ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>填写 C 代码中缺失的表达式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">test</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, longz)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = x + y + z;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">-3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; z)</span><br><span class="line">            val = x * y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            val = y * z;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">2</span>) </span><br><span class="line">        val = x * z;</span><br><span class="line">   <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-20-下面的-C-函数中，我们对-OP-操作的定义是不完整的：下面的-C-函数中，我们对-OP-操作的定义是不完整的：下面的-C-函数中，我们对-OP-操作的定义是不完整的："><a href="#练习题-3-20-下面的-C-函数中，我们对-OP-操作的定义是不完整的：下面的-C-函数中，我们对-OP-操作的定义是不完整的：下面的-C-函数中，我们对-OP-操作的定义是不完整的：" class="headerlink" title="练习题 3.20 下面的 C 函数中，我们对 OP 操作的定义是不完整的：下面的 C 函数中，我们对 OP 操作的定义是不完整的：下面的 C 函数中，我们对 OP 操作的定义是不完整的："></a>练习题 3.20 下面的 C 函数中，我们对 OP 操作的定义是不完整的：下面的 C 函数中，我们对 OP 操作的定义是不完整的：下面的 C 函数中，我们对 OP 操作的定义是不完整的：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> OP _________ <span class="comment">/* Unknown operator */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">arith</span><span class="params">(<span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x OP <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当编译时，GCC 会产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># long arith(long x)</span><br><span class="line"># x in %rdi</span><br><span class="line">arith:</span><br><span class="line">  leaq  7(%rdi), %rax   # temp = x + 7</span><br><span class="line">  testq %rdi, %rdi      # Test x</span><br><span class="line">  cmovns %rdi, %rax     # if x &gt;= 0, temp = x</span><br><span class="line">  sarq   $3, %rax       # result = temp &gt;&gt; 3 (= x / 8)</span><br><span class="line">  ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. OP 进行的是什么操作？</p>
<p>运算符是 ‘/’ 。可以看到这是一个通过右移实现除以 2 的 3 次幂的例子。在移位 <code>k = 3</code> 之前，如果被除数是负数的话，必须加上偏移量 2k−1=7 （向上舍入）。</p>
<p>B. 给代码添加注释，解释它是如何工作的。</p>
<h2 id="练习题-3-21-C-代码开始的形式如下："><a href="#练习题-3-21-C-代码开始的形式如下：" class="headerlink" title="练习题 3.21 C 代码开始的形式如下："></a>练习题 3.21 C 代码开始的形式如下：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">test</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = _____;</span><br><span class="line">    <span class="keyword">if</span> (_____) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_____)</span><br><span class="line">            val = ______;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            val = ______;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (______)</span><br><span class="line">        val = ________;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 会产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># long test(long x, long y)</span><br><span class="line"># x in %rdi, y in %rsi</span><br><span class="line">test:</span><br><span class="line">  leaq  0(, %rdi, 8), %rax  # long temp = 8 * x</span><br><span class="line">  testq %rsi, %rsi          # test y</span><br><span class="line">  jle   .L2                 # y &lt;= 0</span><br><span class="line">  movq  %rsi, %rax          # temp = y</span><br><span class="line">  subq  %rdi, %rax          # temp = temp - x</span><br><span class="line">  movq  %rdi, %rdx          # long temp2 = x</span><br><span class="line">  andq  %rsi, %rdx          # temp2 = temp2 &amp; y</span><br><span class="line">  cmpq  %rsi, %rdi          # 比较 x 和 y</span><br><span class="line">  cmovge %rdx, %rax         # x &gt;= y, temp = temp2</span><br><span class="line">  ret</span><br><span class="line">.L2:</span><br><span class="line">  addq  %rsi, %rdi          # x = x + y</span><br><span class="line">  cmpq  $-2, $rsi           # 比较 y 和 -2</span><br><span class="line">  cmovle %rdi, %rax         # y &lt;= -2, temp = x + y</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>填补 C 代码中缺失的表达式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">test</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">8</span> * x;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">            val = y - x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            val = x &amp; y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y &lt;= <span class="number">-2</span>)</span><br><span class="line">        val = x + y;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-22"><a href="#练习题-3-22" class="headerlink" title="练习题 3.22"></a>练习题 3.22</h2><p>A. 用一个 32 位 int 表示 n! ，最大的 n 的值是多少？</p>
<p>如果构建一张使用数据类型 int 来计算的阶乘表，得到下面这样的结果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>n</th>
<th>n!</th>
<th>OK?</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>Y</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>Y</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>Y</td>
</tr>
<tr>
<td>4</td>
<td>24</td>
<td>Y</td>
</tr>
<tr>
<td>5</td>
<td>120</td>
<td>Y</td>
</tr>
<tr>
<td>6</td>
<td>720</td>
<td>Y</td>
</tr>
<tr>
<td>7</td>
<td>5040</td>
<td>Y</td>
</tr>
<tr>
<td>8</td>
<td>40320</td>
<td>Y</td>
</tr>
<tr>
<td>9</td>
<td>362880</td>
<td>Y</td>
</tr>
<tr>
<td>10</td>
<td>3628800</td>
<td>Y</td>
</tr>
<tr>
<td>11</td>
<td>39916800</td>
<td>Y</td>
</tr>
<tr>
<td>12</td>
<td>479001600</td>
<td>Y</td>
</tr>
<tr>
<td>13</td>
<td>1932053504</td>
<td>N</td>
</tr>
</tbody>
</table>
</div>
<p>当 <code>n = 13</code> 时发生溢出，可以通过$x/n$看它是否等于$(n-1)!$进行判断。</p>
<p>B. 如果用一个 64 位 long 表示，最大的 n 的值是多少？</p>
<p>用long表示的话，最大的 n 值为 20，才溢出，也就是知道20！long类型才溢出。</p>
<h2 id="练习题-3-23-已知-C-代码如下："><a href="#练习题-3-23-已知-C-代码如下：" class="headerlink" title="练习题 3.23 已知 C 代码如下："></a>练习题 3.23 已知 C 代码如下：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">dw_loop</span><span class="params">(<span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="type">long</span> y = x * x;</span><br><span class="line">    <span class="type">long</span> *p = &amp;x;</span><br><span class="line">    <span class="type">long</span> n = <span class="number">2</span> * x;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x += y;</span><br><span class="line">        (*p)++;</span><br><span class="line">        n--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 产生的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># long dw_loop(long x)</span><br><span class="line"># x initially in %rdi</span><br><span class="line"></span><br><span class="line">long dw_loop(long x)</span><br><span class="line">dw_loop:</span><br><span class="line">    movq   %rdi, %rax            # Copy x to %rax   </span><br><span class="line">    movq   %rdi, %rcx               </span><br><span class="line">    imulq  %rdi, %rcx            # Compute y = x*x   </span><br><span class="line">    leaq   (%rdi, %rdi), %rdx    # Compute n = x+x   </span><br><span class="line"></span><br><span class="line">  .L2:                           # loop:</span><br><span class="line">    leaq   1(%rcx, %rax), %rax   # Compute x += y + 1   </span><br><span class="line">    subq   $1, %rdx              # Decrement n   </span><br><span class="line">    testq  %rdx, %rdx            # Test n   </span><br><span class="line">    jg     .L2                   # If &gt; 0, goto loop   </span><br><span class="line">    rep;ret                      # Return   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. 哪些寄存器用来存放程序值 x、y 和 n ？</p>
<p><code>%rax</code> 存放 x ，<code>%rcx</code> 存放 y ，<code>%rdx</code> 存放 n 。</p>
<p>B. 编译器如何消除对指针变量 p 和表达式 <code>(*p)++</code> 隐含的指针间接引用的需求？</p>
<p>编译器认为指针 p 总是指向 x ，因此表达式 <code>(*p)++</code> 就能够实现 x 加一。代码通过 <code>leaq</code> 指令，把这个加一和加 y 组合起来。</p>
<p>C. 对汇编代码添加一些注释，描述程序操作。</p>
<h2 id="练习题-3-24对于如下-C-代码："><a href="#练习题-3-24对于如下-C-代码：" class="headerlink" title="练习题 3.24对于如下 C 代码："></a>练习题 3.24对于如下 C 代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop_while</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = ____;</span><br><span class="line">    <span class="keyword">while</span> (____) &#123;</span><br><span class="line">        result = ____;</span><br><span class="line">        a = ____ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以命令行选项 <code>-Og</code> 运行 GCC 产生如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># long loop_while(long a, long b)</span><br><span class="line"># a in %rdi, b in %rsi</span><br><span class="line">loop_while:</span><br><span class="line">    movl   $1, %eax            </span><br><span class="line">    jmp    .L2                 </span><br><span class="line"></span><br><span class="line">  .L3:</span><br><span class="line">    leaq   (%rdi, %rsi), %rdx  </span><br><span class="line">    imulq  %rdx, %rax          </span><br><span class="line">    addq   $1, %rdi            </span><br><span class="line"></span><br><span class="line">  .L2:</span><br><span class="line">    cmpq   %rsi, %rdi          </span><br><span class="line">    jl     .L3                 </span><br><span class="line">    rep; ret                   </span><br></pre></td></tr></table></figure>
<p>可以看到编译器使用了跳转到中间的翻译方法，在用 jmp 跳转到标号 .L2 开始测试。填写 C 代码中缺失的部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop_while</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a &lt; b) &#123;</span><br><span class="line">        result = result * (a + b);</span><br><span class="line">        a = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-25对于如下-C-代码："><a href="#练习题-3-25对于如下-C-代码：" class="headerlink" title="练习题 3.25对于如下 C 代码："></a>练习题 3.25对于如下 C 代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop_while2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = ____;</span><br><span class="line">    <span class="keyword">while</span> (____) &#123;</span><br><span class="line">        result = ____;</span><br><span class="line">        b = ____ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以命令行选项 <code>-ol</code> 运行 GCC ，产生如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># a in %rdi, b in %rsi</span><br><span class="line">loop_while2:</span><br><span class="line">    testq   %rsi, %rsi      </span><br><span class="line">    jle     .L8             </span><br><span class="line">    movq    %rsi, %rax      </span><br><span class="line">  .L7:</span><br><span class="line">    imulq   %rdi, %rax      </span><br><span class="line">    subq    %rdi, %rsi      </span><br><span class="line">    testq   %rsi, %rsi      </span><br><span class="line">    jg      .L7             </span><br><span class="line">    rep; ret                </span><br><span class="line">  .L8:</span><br><span class="line">    movq    %rsi, %rax      </span><br><span class="line">    ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到编译器使用了 guarded-do 的翻译方法，使用了 <code>jle</code> 指令使得当初始测试不成立时，忽略循环代码。填写缺失的 C 代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop_while2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = b;</span><br><span class="line">    <span class="keyword">while</span> (b&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        result = result * a;</span><br><span class="line">        b = b - a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-26-函数-fun-a-有如下整体结构："><a href="#练习题-3-26-函数-fun-a-有如下整体结构：" class="headerlink" title="练习题 3.26 函数 fun_a 有如下整体结构："></a>练习题 3.26 函数 fun_a 有如下整体结构：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fun_a</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC C 编译器产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># long fun_a(unsigned long x)</span><br><span class="line"># x in %rdi</span><br><span class="line">long fun_a(unsigned long x)</span><br><span class="line"></span><br><span class="line">fun_a:</span><br><span class="line">    movl   $0, eax      </span><br><span class="line">    jmp    .L5          </span><br><span class="line"></span><br><span class="line">  .L6:</span><br><span class="line">    xorq   %rdi, %rax   </span><br><span class="line">    shrq   %rdi         # Shift right by 1</span><br><span class="line"></span><br><span class="line">  .L5:</span><br><span class="line">    testq  %rdi, %rdi   </span><br><span class="line">    jne    .L6          </span><br><span class="line">    andl   $1, %eax     </span><br><span class="line">    ret                 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>逆向工程这段代码的操作，然后完成下面作业：</p>
<p>A. 确定这段代码使用的循环翻译方法。</p>
<p>使用的是跳转到中间翻译方法。汇编中使用了 <code>jmp</code> 指令。</p>
<p>B. 根据汇编代码版本填写完 C 代码中缺失的部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fun_a</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        val ^= x ;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> val &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C. 用自然语言描述这个函数是计算什么的。</p>
<p>这个代码计算参数 x 的奇偶性。也就是，如果 x 中有奇数个 1，就返回 1，如果有偶数个 1，就返回 0。</p>
<h2 id="练习题-3-27"><a href="#练习题-3-27" class="headerlink" title="练习题 3.27"></a>练习题 3.27</h2><p>先把 <code>fact_for</code> 转换成 while 循环，再进行 guarded-do 变化，写出 <code>fact_for</code> 的 goto 代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_for_gd_goto</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    loop:</span><br><span class="line">        result *= i;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= n)</span><br><span class="line">            <span class="keyword">goto</span> loop;</span><br><span class="line">    done:</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-28函数-fun-b-有如下整体结构："><a href="#练习题-3-28函数-fun-b-有如下整体结构：" class="headerlink" title="练习题 3.28函数 fun_b 有如下整体结构："></a>练习题 3.28函数 <code>fun_b</code> 有如下整体结构：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fun_b</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( ... ; ... ; ... ) &#123;</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GCC 编译器产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># long fun_b(unsigned long x)</span><br><span class="line"># x in %rdi</span><br><span class="line"></span><br><span class="line">fun_b:</span><br><span class="line">    movl   $64, %edx        # %edx 寄存器中存入 64</span><br><span class="line">    movl   $0, %eax         # 对应 long val = 0</span><br><span class="line"></span><br><span class="line">  .L10:</span><br><span class="line">    movq   %rdi, %rcx       # long temp = x</span><br><span class="line">    andl   $1, %ecx         # temp = temp ^ 0x1  x 的最低位</span><br><span class="line">    addq   %rax, %rax       # val = val * 2</span><br><span class="line">    orq    %rcx, %rax       # val = val | temp 最低位如果是 1，就是真</span><br><span class="line">    shrq   %rdi             # 逻辑右移 1 位</span><br><span class="line">    subq   $1, %rdx         # 装入寄存器，减去 1</span><br><span class="line">    jne    .L10             # %rdx 不是 0 的情况下继续循环</span><br><span class="line">    rep; ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>逆向工程这段代码的操作，然后完成下面的工作：</p>
<p>A. 根据汇编代码版本填写 C 代码中缺失的部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fun_b</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">64</span> ; i!=<span class="number">0</span> ; i-- ) &#123;</span><br><span class="line">        val = (val &lt;&lt; <span class="number">1</span>) | (x &amp; <span class="number">0x1</span>);</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>B. 解释循环前为什么没有初识测试也没有初始跳转到循环内部的测试部分。</p>
<p>这段代码使用 guarded-do 变换生成的，但是编译器发现因为 i 初始化成了 64，所以一定会满足测试 <code>i != 0</code> ，因此初始的测试是没必要的。</p>
<p>C. 用自然语言描述这个函数是计算什么的。</p>
<p>这段代码把 x 中的位反过来，创造一个镜像。实现的方法是：将 x 的位从左往右移，然后再填入这些位，就像是把 val 从右往左移。</p>
<h2 id="练习题-3-29"><a href="#练习题-3-29" class="headerlink" title="练习题 3.29"></a>练习题 3.29</h2><p>在 C 语言中执行 continue 语句会导致程序跳到当前循环迭代的结尾。当处理 continue 语句时，将 for 循环翻译成 while 循环的描述规则需要一些改进。例如，当考虑下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Example of for loop containing a continue statement */</span></span><br><span class="line"><span class="comment">/* Sum even numbers between 0 and 9 */</span></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. 如果我们简单地直接应用将 for 循环翻译到 while 循环的规则，会得到什么呢？产生的代码会有什么错误呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Naive translation of for loop into while loop */</span></span><br><span class="line"><span class="comment">/* WARNING: This is buggy code */</span></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="comment">/* This will cause an infinite loop */</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为 continue 语句会阻止索引变量 i 被修改，所以这段代码是无限循环。</p>
<p>B. 如何用 goto 语句来替代 continue 语句，保证 while 循环的行为同 for 循环的行为完全一样？</p>
<p>通用的解决方法是用 goto 语句替代 continue 语句，它会跳过循环体中余下的部分，直接跳到 update 部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Correct translation of for loop into while loop */</span></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">goto</span> update;</span><br><span class="line">    sum += i;</span><br><span class="line">    update:</span><br><span class="line">        i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-30下面的-C-函数省略了-switch-语句的主体。在-C-代码中，情况标号是不连续的，而有些情况有多个标号。"><a href="#练习题-3-30下面的-C-函数省略了-switch-语句的主体。在-C-代码中，情况标号是不连续的，而有些情况有多个标号。" class="headerlink" title="练习题 3.30下面的 C 函数省略了 switch 语句的主体。在 C 代码中，情况标号是不连续的，而有些情况有多个标号。"></a>练习题 3.30下面的 C 函数省略了 switch 语句的主体。在 C 代码中，情况标号是不连续的，而有些情况有多个标号。</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch2</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        .</span><br><span class="line">        .  <span class="comment">// Body of switch statement omitted</span></span><br><span class="line">        .</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在编译该函数时，GCC 为程序的初始部分生成了以下汇编代码，变量 x 在寄存器 <code>%rdi</code> 中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># void switch2(long x, long *dest)</span><br><span class="line"># x in %rdi</span><br><span class="line">switch2:</span><br><span class="line">    addq    $1, %rdi    # x = x + 1 ，由于将索引控制在 0 开始，所以 x 的最小值是 -1      </span><br><span class="line">    cmpq    $8, %rdi    # 比较 x - 8，其实就是 x + 1 - 8 &gt; 0 ，则原始的 x 最大标号是 7       </span><br><span class="line">    ja      .L2         # 超过 8 就跳转到 L2，L2 相当于 default   </span><br><span class="line">    jmp     *.L4(, %rdi, 8)    # 没有超过 8 就进入跳转表</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为跳转表生成以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.L4</span><br><span class="line">    quad:   .L9    # -1</span><br><span class="line">    quad:   .L5    # 0</span><br><span class="line">    quad:   .L6    # 1</span><br><span class="line">    quad:   .L7    # 2</span><br><span class="line">    quad:   .L2    # default</span><br><span class="line">    quad:   .L7    # 4</span><br><span class="line">    quad:   .L8    # 5</span><br><span class="line">    quad:   .L2    # default </span><br><span class="line">    quad:   .L5    # 7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. switch 语句内情况标号的值分别是多少？</p>
<p>-1、0、1、2、4、5 和 7</p>
<p>B. C 代码中哪些情况有多个标号？</p>
<p><code>.L5</code> 的情况为 0 和 7，<code>.L7</code> 的情况标号为 2 和 4。</p>
<h2 id="练习题-3-31"><a href="#练习题-3-31" class="headerlink" title="练习题 3.31"></a>练习题 3.31</h2><p>对于一个通用结构的 C 函数 switcher:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switcher</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b, <span class="type">long</span> c, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">    <span class="keyword">case</span> ____:     <span class="comment">/* Case A */</span></span><br><span class="line">        c = ____;</span><br><span class="line">        <span class="comment">/* Fall through */</span></span><br><span class="line">    <span class="keyword">case</span> ____:     <span class="comment">/* Case B */</span></span><br><span class="line">        val = ____;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ____:     <span class="comment">/* Case C */</span></span><br><span class="line">    <span class="keyword">case</span> ____:     <span class="comment">/* Case D */</span></span><br><span class="line">        val = ____;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ____:     <span class="comment">/* Case E */</span></span><br><span class="line">        val = ____;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = ____;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 产生如下所示的汇编代码和跳转表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221108153523592.png" alt="image-20221108153523592"></p>
<p>填写 C 代码中缺失的部分。除了情况标号 C 和 D 的顺序之外，将不同情况填入这个模板的方式是唯一的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switcher</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b, <span class="type">long</span> c, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:     <span class="comment">/* Case A */</span></span><br><span class="line">        c = b ^ <span class="number">15</span>;</span><br><span class="line">        <span class="comment">/* Fall through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:     <span class="comment">/* Case B */</span></span><br><span class="line">        val = c + <span class="number">112</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> :     <span class="comment">/* Case C */</span></span><br><span class="line">    <span class="keyword">case</span> :     <span class="comment">/* Case D */</span></span><br><span class="line">        val =  (c + b) &lt;&lt; <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> :     <span class="comment">/* Case E */</span></span><br><span class="line">        val = a;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = b;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-32"><a href="#练习题-3-32" class="headerlink" title="练习题 3.32"></a>练习题 3.32</h2><p>下面列出的是两个函数 first 和 last 的反汇编代码，以及 main 函数调用 first 的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Disassembly of last(long u, long v)</span><br><span class="line"># u in %rdi, v in %rsi</span><br><span class="line">0000000000400540 &lt;last&gt;:</span><br><span class="line">  400540:  48 89 f8          mov   %rdi, %rax     # L1: u</span><br><span class="line">  400543:  48 0f af c6       imul  %rsi, %rax     # L2: u*v</span><br><span class="line">  400547:  c3                req                  # L3: Return</span><br><span class="line">  </span><br><span class="line"># Disassembly of first(long x)</span><br><span class="line"># x in %rdi</span><br><span class="line">0000000000400548 &lt;first&gt;:</span><br><span class="line">   400548: 48 8d 77 01       lea   0x1(%rdi), %rsi  # F1: x+1</span><br><span class="line">   40054c: 48 83 ef 01       sub   $0x1, %rdi       # F2: x-1</span><br><span class="line">   400500: e8 eb ff ff ff    callq 400540 &lt;last&gt;    # F3: Call last(x-1, x+1)</span><br><span class="line">   400555: f3 c3             repz  retq             # F4: Return</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   400560: e8 e3 ff ff ff    callq 400548 &lt;first&gt;   # M1: Call first(10)</span><br><span class="line">   400565: 48 89 c2          mov   %rax, %rdx       # M2: Resume</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从 main 调用 first(10) 开始，到程序返回 main 时为止，填写下表记录指令执行的过程。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">指令</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">状态值</th>
<th style="text-align:center">(指令执行前)</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标号</td>
<td style="text-align:center">PC</td>
<td style="text-align:center">指令</td>
<td style="text-align:center">%rdi</td>
<td style="text-align:center">%rsi</td>
<td style="text-align:center">%rax</td>
<td style="text-align:center">%rsp</td>
<td style="text-align:center"><em>%rsp</em></td>
<td style="text-align:center">描述</td>
</tr>
<tr>
<td style="text-align:center">M1</td>
<td style="text-align:center">0x400560</td>
<td style="text-align:center">callq</td>
<td style="text-align:center">10</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0x7fffffffe820</td>
<td style="text-align:center">-</td>
<td style="text-align:center">调用 first(10)</td>
</tr>
<tr>
<td style="text-align:center">F1</td>
<td style="text-align:center">0x400548</td>
<td style="text-align:center">leq</td>
<td style="text-align:center">10</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0x7fffffffe818</td>
<td style="text-align:center">0x400565</td>
<td style="text-align:center">first 的入口</td>
</tr>
<tr>
<td style="text-align:center">F2</td>
<td style="text-align:center">0x40054c</td>
<td style="text-align:center">sub</td>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0x7fffffffe818</td>
<td style="text-align:center">0x400565</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">F3</td>
<td style="text-align:center">0x400550</td>
<td style="text-align:center">callq</td>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0x7fffffffe810</td>
<td style="text-align:center">0x400565</td>
<td style="text-align:center">调用 last(9, 11)</td>
</tr>
<tr>
<td style="text-align:center">L1</td>
<td style="text-align:center">0x400540</td>
<td style="text-align:center">mov</td>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0x7fffffffe810</td>
<td style="text-align:center">0x400555</td>
<td style="text-align:center">last 的入口</td>
</tr>
<tr>
<td style="text-align:center">L2</td>
<td style="text-align:center">0x400543</td>
<td style="text-align:center">imul</td>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">9</td>
<td style="text-align:center">0x7fffffffe810</td>
<td style="text-align:center">0x400555</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">L3</td>
<td style="text-align:center">0x400547</td>
<td style="text-align:center">retq</td>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">99</td>
<td style="text-align:center">0x7fffffffe810</td>
<td style="text-align:center">0x400555</td>
<td style="text-align:center">从 last 返回 99</td>
</tr>
<tr>
<td style="text-align:center">F4</td>
<td style="text-align:center">0x400555</td>
<td style="text-align:center">repz repq</td>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">99</td>
<td style="text-align:center">0x7fffffffe818</td>
<td style="text-align:center">0x400565</td>
<td style="text-align:center">从 first 返回 99</td>
</tr>
<tr>
<td style="text-align:center">M2</td>
<td style="text-align:center">0x400565</td>
<td style="text-align:center">mov</td>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">99</td>
<td style="text-align:center">0x7fffffffe820</td>
<td style="text-align:center">-</td>
<td style="text-align:center">继续执行 main</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-33"><a href="#练习题-3-33" class="headerlink" title="练习题 3.33"></a>练习题 3.33</h2><p>C 函数 <code>procprob</code> 有 4 个参数 u、a、v 和 b，每个参数要么是一个有符号数，要么是一个指向有符号数的指针，这里的数大小不同。该函数的函数体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*u += a;</span><br><span class="line">*v += b;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">sizeof</span>(a) + <span class="keyword">sizeof</span>(b);</span><br></pre></td></tr></table></figure>
<p>编译得到如下 x86-64 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procprob:</span><br><span class="line">  movslq  %edi, %rdi</span><br><span class="line">  addq    %rdi, (%rdx)</span><br><span class="line">  addb    %sil, (%rcx)</span><br><span class="line">  movl    $6, %eax</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>确定 4 个参数的合法顺序和类型。</p>
<p>因为代码的 return 里返回的是 6，所以可以知道 a 和 b 两个数一个是 4 位长，一个是 2 位长。</p>
<p>假如 a 是 4 位长度， 则一开始扩展 %edi 符号实际上操作的是 a， 那么之后把 a 加到 (%rdx) 上边，说明 %rdx 中是 u。对应的，%sil 中是 b，%rcx 中是 v。</p>
<p>a 通过 %edi 作为第一个参数传递，把它从 4 个字节转换成 8 个字节，再加到 %rdx 指向的 8 个字节上。这就意味着 a 必定是 int 类型，u 一定是 long <em> 类型。还可以看到 b 的低位字节被加到了 %rcx 指向的字节。这就意味着 v 一定是 char </em> 。</p>
<p>假如 b 是 4 位长度,，则一开始扩展 %edi 符号实际上操作的是 b ，那么之后把 b 加到 (%rdx) 上边，说明 %rdx 中是 v。对应的，%sil 中是 a，%rcx 中是 u 。</p>
<p>所以两种情况是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">procprob</span><span class="params">(<span class="type">int</span> a, <span class="type">short</span> b, <span class="type">long</span> *u, <span class="type">char</span> *v)</span>`</span><br><span class="line"><span class="type">int</span> <span class="title function_">procprob</span><span class="params">(<span class="type">int</span> b, <span class="type">short</span> a, <span class="type">long</span> *v, <span class="type">char</span> *u)</span></span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-34"><a href="#练习题-3-34" class="headerlink" title="练习题 3.34"></a>练习题 3.34</h2><p>一个函数 P 生成名为 a0 ~ a7 的局部变量，然后调用函数 Q ，没有参数。GCC 为 P 的第一部分产生如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># long P(long x)</span><br><span class="line"># x in %rdi</span><br><span class="line">P:</span><br><span class="line">    pushq   %r15</span><br><span class="line">    pushq   %r14</span><br><span class="line">    pushq   %r13</span><br><span class="line">    pushq   %r12</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    pushq   %rbx    </span><br><span class="line"></span><br><span class="line">    subq    $24, %rsp      </span><br><span class="line"></span><br><span class="line">    movq    %rdi, %rbx     </span><br><span class="line">    leaq    1(%rdi), %r15  </span><br><span class="line">    leaq    2(%rdi), %r14  </span><br><span class="line">    leaq    3(%rdi), %r13  </span><br><span class="line">    leaq    4(%rdi), %r12  </span><br><span class="line">    leaq    5(%rdi), %rbp  </span><br><span class="line"></span><br><span class="line">    leaq    6(%rdi), %rax  </span><br><span class="line">    mov     %rax, (%rsp)   </span><br><span class="line">    leaq    7(%rdi), %rdx  </span><br><span class="line">    movq    %rdx, 8(%rsp)  </span><br><span class="line">    movl    $0, %eax       </span><br><span class="line">    call    Q              </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. 确定哪些局部值存储在被调用者保存寄存器中。</p>
<p>局部值 a0 ~ a5 分别保存被调用者保存寄存器 %rbx、%r15、%r14、%13、%12 和 %rbp。</p>
<p>B. 确定哪些局部变量存储在栈上。</p>
<p>局部值 a6 和 a7 存放在栈中相对于栈指针偏移量为 0 和 8 的地方。</p>
<p>C. 解释为什么不能把所有的局部值都存储在被调用者保存寄存器中。</p>
<p>存储完 6 个局部变量后，程序用完了所有的被调用者保存寄存器，所以剩下的两个值保存在栈上。</p>
<h2 id="练习题-3-35-一个具有通用结构的-C-函数如下："><a href="#练习题-3-35-一个具有通用结构的-C-函数如下：" class="headerlink" title="练习题 3.35 一个具有通用结构的 C 函数如下："></a>练习题 3.35 一个具有通用结构的 C 函数如下：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rfun</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(______)&#123;</span><br><span class="line">        <span class="keyword">return</span> ______;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nx = ______;</span><br><span class="line">    <span class="type">long</span> rv = rfun(nx);</span><br><span class="line">    <span class="keyword">return</span> ______;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GCC 产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># long rfun(unsigned long x)</span><br><span class="line"># x in %rdi</span><br><span class="line"></span><br><span class="line">rfun:</span><br><span class="line">    pushq   %rbx           </span><br><span class="line">    movq    %rdi, %rbx     </span><br><span class="line">    movl    %0, %eax       </span><br><span class="line">    testq   %rdi, %rdi     </span><br><span class="line">    je      .L2            </span><br><span class="line">    shrq    $2, %rdi       </span><br><span class="line">    callq   rfun           </span><br><span class="line">    addq    %rbx, %rax     </span><br><span class="line"></span><br><span class="line">  .L2</span><br><span class="line">    popq    %rbx           </span><br><span class="line">    ret                    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. rfun 存储在被调用者保存器 %rbx 中的值是什么？</p>
<p>寄存器 %rbx 保存参数 x 的值</p>
<p>B. 填写上述 C 代码中缺失的表达式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rfun</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nx = x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">	<span class="type">long</span> rv = rfun(nx);</span><br><span class="line">    <span class="keyword">return</span> x + rv ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-36"><a href="#练习题-3-36" class="headerlink" title="练习题 3.36"></a>练习题 3.36</h2><p>考虑下面的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> S[<span class="number">7</span>];</span><br><span class="line"><span class="type">short</span> *T[<span class="number">3</span>];</span><br><span class="line"><span class="type">short</span> **U[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span>   V[<span class="number">8</span>];</span><br><span class="line"><span class="type">double</span> *W[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>填写下表，描述每个数组的元素大小、整个数组的大小以及元素 i 的地址：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数组</th>
<th style="text-align:center">元素大小</th>
<th style="text-align:center">整个数组的大小</th>
<th style="text-align:center">起始地址</th>
<th style="text-align:center">元素 i</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">2</td>
<td style="text-align:center">14</td>
<td style="text-align:center">$x_S$</td>
<td style="text-align:center">$x_S+2i$</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">8</td>
<td style="text-align:center">24</td>
<td style="text-align:center">$x_T$</td>
<td style="text-align:center">$x_T+8i$</td>
</tr>
<tr>
<td style="text-align:center">U</td>
<td style="text-align:center">8</td>
<td style="text-align:center">48</td>
<td style="text-align:center">$x_U$</td>
<td style="text-align:center">$x_U+8i$</td>
</tr>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32</td>
<td style="text-align:center">$x_V$</td>
<td style="text-align:center">$x_V+4i$</td>
</tr>
<tr>
<td style="text-align:center">W</td>
<td style="text-align:center">8</td>
<td style="text-align:center">32</td>
<td style="text-align:center">$x_W$</td>
<td style="text-align:center">$x_W+8i$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-37"><a href="#练习题-3-37" class="headerlink" title="练习题 3.37"></a>练习题 3.37</h2><p>假设短整形数组 S 的地址 $x_S$ 和整数索引 i 分别存放在寄存器 <code>%rdx</code> 和 <code>%rcx</code> 中。对下面每个表达式，给出它的类型、值的表达式和汇编代码实现。如果结果是指针的话，要保存在寄存器 <code>%rax</code> 中，如果数据类型为 short，就保存在寄存器元素 <code>%ax</code> 中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">值</th>
<th style="text-align:center">汇编代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>S + 1</code></td>
<td style="text-align:center">short*</td>
<td style="text-align:center">$x_S+2$</td>
<td style="text-align:center"><code>leaq 2(%rdx), %rax</code></td>
</tr>
<tr>
<td style="text-align:center"><code>S[3]</code></td>
<td style="text-align:center">short</td>
<td style="text-align:center">$M[x_S+6]$</td>
<td style="text-align:center"><code>movw 6(%rdx), %ax</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;S[i]</code></td>
<td style="text-align:center">short*</td>
<td style="text-align:center">$x_S+2i$</td>
<td style="text-align:center"><code>leaq (%rdx, %rcx, 2), %rax</code></td>
</tr>
<tr>
<td style="text-align:center"><code>S[4*i+1]</code></td>
<td style="text-align:center">short</td>
<td style="text-align:center">$M[x_S+8_i+2]$</td>
<td style="text-align:center"><code>movw 2(%rdx, %rcx, 8), %ax</code></td>
</tr>
<tr>
<td style="text-align:center"><code>S + i - 5</code></td>
<td style="text-align:center">short*</td>
<td style="text-align:center">$x_S+2i−10$</td>
<td style="text-align:center"><code>leaq -10(%rdx, %rcx, 2), %rax</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-38"><a href="#练习题-3-38" class="headerlink" title="练习题 3.38"></a>练习题 3.38</h2><p>考虑下面的源码，其中 M 和 N 是用 <code>#define</code> 声明的常数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> P[M][N];</span><br><span class="line"><span class="type">long</span> Q[N][M];</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">sum_element</span><span class="params">(<span class="type">long</span> i, <span class="type">long</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> P[i][j] + Q[j][i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译这个程序中，GCC 产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># long sum_element(long i, long j)</span><br><span class="line"># i in %rdi, j in %rsi</span><br><span class="line"></span><br><span class="line">sum_element:</span><br><span class="line">    leaq   0(,%rdi, 8),  %rdx       # %rdx = 8i</span><br><span class="line">    subq   %rdi, %rdx               # %rdx - i = 7i</span><br><span class="line">    addq   %rsi, %rdx               # %rdx = 7i + j</span><br><span class="line">    leaq   (%rsi, %rsi, 4), %rax    # %rax = 5j</span><br><span class="line">    addq   %rax, %rdi               # %rdi = i + 5j</span><br><span class="line">    movq   Q(, %rdi, 8), %rax       # M[xQ + 8(5j + i)]</span><br><span class="line">    movq   P(, %rdx, 8), %rax       # M[xP + 8(7i + j)]</span><br><span class="line">    ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运用逆向工程技能，根据这段汇编代码，确定 M 和 N 的值。</p>
<p>P 有 7 列，Q 有 5 列，得到 <code>M=5</code> 和 <code>M=7</code> 。</p>
<h2 id="练习题3-39"><a href="#练习题3-39" class="headerlink" title="练习题3.39"></a>练习题3.39</h2><p>利用等式3.1来解释图3-37b的C代码中Aptr、Bptr和 Bend的初始值计算(第3~5行)是如何正确反映fix_prod_ele的汇编代码中它们的计算(第3~5行)的。</p>
<p>对于L=4，C=16和j=0，指针Aptr等于$x_A＋4×(16i＋0)=x_A+64i$。</p>
<p>对于L=4，C=16，i=0和j=k，指针 Bptr等于$x_B+4×(16×0+k)=x_B+4k$。</p>
<p>对于L=4，C=16，i=16和j=k，Bend等于$x_B+4×(16×16+k)=x_B+1024+4k$。</p>
<h2 id="练习题-3-41考虑下面的结构声明："><a href="#练习题-3-41考虑下面的结构声明：" class="headerlink" title="练习题 3.41考虑下面的结构声明："></a>练习题 3.41考虑下面的结构声明：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prob</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">    &#125; s;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">prob</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个声明说明一个结构可以嵌套在另一个结构中，就像数组可以嵌套在结构中、数组可以嵌套在数组中一样。</p>
<p>下面的过程（省略了某些表达式）对这个结构进行操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sp_init</span><span class="params">(<span class="keyword">struct</span> prob *sp)</span> &#123;</span><br><span class="line">    sp-&gt;s.x = _____;</span><br><span class="line">    sp-&gt;p   = _____;</span><br><span class="line">    sp-&gt;next= _____;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A. 下列字段的偏移量是多少（以字节为单位）？</p>
<p>p: 指针 p 是第一个元素，偏移量为 0<br>s.x: 是紧接在 p 之后的结构内第一个元素，偏移量为 8<br>s.y: x 的长度为 4，所以偏移量为 12<br>next: y 的长度为 4，所以偏移量为 16</p>
<p>B. 这个结构总共需要多少字节？<br>指针长度为 8，int为4，总共24字节。</p>
<p>C. 编译器为 <code>sp_init</code> 的主体产生的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># void sp_init(struct prob *sp)</span><br><span class="line"># sp in %rdi</span><br><span class="line">sp_init:</span><br><span class="line">movl 12(%rdi), %eax     # Get sp-&gt;s.y</span><br><span class="line">movl %eax, 8(%rdi)      # Save in sp-&gt;s.x</span><br><span class="line">leaq 8(%rdi), %rax      # Compute &amp;(sp-&gt;s.x)</span><br><span class="line">movq %rax, (%rdi)       # Store in sp-&gt;p</span><br><span class="line">movq %rdi, 16(%rdi)     # Store sp in sp-&gt;next</span><br><span class="line">ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据这些信息，填写 <code>sp_init</code> 代码中缺失的表达式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sp_init</span><span class="params">(<span class="keyword">struct</span> prob *sp)</span> &#123;</span><br><span class="line">    sp-&gt;s.x = sp-&gt;s.y ;</span><br><span class="line">    sp-&gt;p   = &amp;(sp-&gt;s.x);</span><br><span class="line">    sp-&gt;next= sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-42下面的代码给出了类型-ELE-的结构声明以及函数-fun-的原型："><a href="#练习题-3-42下面的代码给出了类型-ELE-的结构声明以及函数-fun-的原型：" class="headerlink" title="练习题 3.42下面的代码给出了类型 ELE 的结构声明以及函数 fun 的原型："></a>练习题 3.42下面的代码给出了类型 ELE 的结构声明以及函数 fun 的原型：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fun</span><span class="params">(<span class="keyword">struct</span> ELE *ptr)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当编译 fun 的代码时，GCC 会产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># long fun(struct ELE *ptr)</span><br><span class="line"># ptr in %rdi</span><br><span class="line"></span><br><span class="line">fun:</span><br><span class="line">    movl   $0, %eax          # result = 0</span><br><span class="line">    jmp    .L2               # Goto middle</span><br><span class="line">  .L3:                       # loop:</span><br><span class="line">    addq   (%rdi), %rax      # result += ptr-&gt;v</span><br><span class="line">    movq   8(%rdi), %rdi     # ptr = ptr-&gt;p</span><br><span class="line">  .L2:                       # middle:</span><br><span class="line">    testq  %rdi, %rdi        # Test ptr</span><br><span class="line">    jne    .L3               # If != NULL, goto loop</span><br><span class="line">    rep; ret                </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. 利用逆向工程技巧写出 fun 的 C 代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fun</span><span class="params">(<span class="keyword">struct</span> ELE *ptr)</span> &#123;</span><br><span class="line">	<span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr)&#123;</span><br><span class="line">        val += ptr-&gt;v;</span><br><span class="line">        ptr = ptr-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B. 描述这个结构实现的数据结构以及 fun 执行的操作。</p>
<p>每个结构都是一个单链表中的元素，字段 v 是元素的值，字段 p 是指向下一个元素的指针。函数 fun 计算列表中元素值的和。</p>
<h2 id="习题-3-43"><a href="#习题-3-43" class="headerlink" title="习题 3.43"></a>习题 3.43</h2><p>假设给你个任务，检查一下 C 编译器为结构和联合的访问产生正确的代码。你写了下面的结构声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">long</span> u;</span><br><span class="line">        <span class="type">short</span> v;</span><br><span class="line">        <span class="type">char</span> w;</span><br><span class="line">    &#125; t1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">        <span class="type">char</span> *p;</span><br><span class="line">    &#125; t2;</span><br><span class="line">&#125; u_type;</span><br></pre></td></tr></table></figure>
<p>你写了一组具有下面这种形式的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get</span><span class="params">(u_type *up, type *dest)</span> &#123;</span><br><span class="line">    *dest = expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这组函数有不一样的访问表达式 expr，而且根据 expr 的类型来设置目的数据类型 type 。然后再检查编译这些函数时产生的代码，看看它们是否与你预期的一样。</p>
<p>假设在这些函数中，up 和 dest 分别被加载到寄存器 <code>%rdi</code> 和 <code>%rsi</code> 中。填写下表中的数据类型 type，并用 1 ~ 3 条指令序列来计算表达式，并将结果存储到 dest 中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>expr</th>
<th>type</th>
<th>代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>up-&gt;t1.u</code></td>
<td>long</td>
<td><code>movq (%rdi), %rax movq %rax, (%rsi)</code></td>
</tr>
<tr>
<td><code>up-&gt;t1.v</code></td>
<td>short</td>
<td><code>movw 8(%rdi), %ax movw %ax, (%rsi)</code></td>
</tr>
<tr>
<td><code>&amp;up-&gt;t1.w</code></td>
<td>char*</td>
<td><code>addq $10, %rdi movq %rdi, (%rsi)</code></td>
</tr>
<tr>
<td><code>up-&gt;t2.a</code></td>
<td>int*</td>
<td><code>movq %rdi, (%rsi)</code></td>
</tr>
<tr>
<td><code>up-&gt;t2.a[up-&gt;t1.u]</code></td>
<td>int</td>
<td><code>movq (%rdi), %rax movl (%rdi, %rax, 4), %eax movl %eax, (%rsi)</code></td>
</tr>
<tr>
<td><code>*up-&gt;t2.p</code></td>
<td>char</td>
<td><code>movq 8(%rdi), %rax movb (%rax), %al movb %al, (%rsi)</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-44-对下面每个结构声明，确定每个字段的偏移量，结构总的大小，以及在-x86-64-下它的对齐要求："><a href="#练习题-3-44-对下面每个结构声明，确定每个字段的偏移量，结构总的大小，以及在-x86-64-下它的对齐要求：" class="headerlink" title="练习题 3.44 对下面每个结构声明，确定每个字段的偏移量，结构总的大小，以及在 x86-64 下它的对齐要求："></a>练习题 3.44 对下面每个结构声明，确定每个字段的偏移量，结构总的大小，以及在 x86-64 下它的对齐要求：</h2><p>A. <code>struct P1 &#123;int i; char c; int j; char d&#125;;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>i</th>
<th>c</th>
<th>j</th>
<th>d</th>
<th>总共</th>
<th>对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>8</td>
<td>12</td>
<td>16</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<p>B. <code>struct P2 &#123;int i; char c; char d; long j&#125;;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>i</th>
<th>c</th>
<th>d</th>
<th>j</th>
<th>总共</th>
<th>对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>5</td>
<td>8</td>
<td>16</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p>​    C. <code>struct P3 &#123;short w[3]; char c[3]&#125;;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>w</th>
<th>c</th>
<th>总共</th>
<th>对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>6</td>
<td>10</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>D. <code>struct P4 &#123;short w[5]; char *c[3]&#125;;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>w</th>
<th>c</th>
<th>总共</th>
<th>对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>16</td>
<td>40</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p>E. <code>struct P5 &#123;struct P3 a[2]; struct P2 t&#125;;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th>t</th>
<th>总共</th>
<th>对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>24</td>
<td>40</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-45"><a href="#练习题-3-45" class="headerlink" title="练习题 3.45"></a>练习题 3.45</h2><p>对于下列结构声明回答后续问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>  *a;    </span><br><span class="line">    <span class="type">short</span>  b;    </span><br><span class="line">    <span class="type">double</span> c;   </span><br><span class="line">    <span class="type">char</span>   d;     </span><br><span class="line">    <span class="type">float</span>  e;    </span><br><span class="line">    <span class="type">char</span>   f;     </span><br><span class="line">    <span class="type">long</span>   g;     </span><br><span class="line">    <span class="type">int</span>    h;      </span><br><span class="line">&#125; rec;</span><br></pre></td></tr></table></figure>
<p>A. 这个结构中所以的字段的字节偏移量是多少？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
<th>g</th>
<th>h</th>
</tr>
</thead>
<tbody>
<tr>
<td>大小</td>
<td>8</td>
<td>2</td>
<td>8</td>
<td>1</td>
<td>4</td>
<td>1</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>偏移量</td>
<td>0</td>
<td>8</td>
<td>16</td>
<td>24</td>
<td>28</td>
<td>32</td>
<td>40</td>
<td>48</td>
</tr>
</tbody>
</table>
</div>
<p>B. 这个结构总的大小是多少？</p>
<p>总共 56 个字节长。</p>
<p>C. 重新排列这个结构中的字段，以最小化浪费的空间，然后再给出重排过的结构的字节偏移量和总的大小。</p>
<p>当所有的数据元素的长度都是 2 的幂时，一种行之有效的策略是按照大小的降序排列结构的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>   *a;</span><br><span class="line">    <span class="type">double</span>  c; </span><br><span class="line">    <span class="type">long</span>    g;</span><br><span class="line">    <span class="type">float</span>   e;</span><br><span class="line">    <span class="type">int</span>     h;</span><br><span class="line">    <span class="type">short</span>   b;</span><br><span class="line">    <span class="type">char</span>    d;</span><br><span class="line">    <span class="type">char</span>    f;</span><br><span class="line">&#125; rec;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>得到的偏离量如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>a</th>
<th>c</th>
<th>g</th>
<th>e</th>
<th>h</th>
<th>b</th>
<th>d</th>
<th>f</th>
</tr>
</thead>
<tbody>
<tr>
<td>大小</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>4</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>偏移量</td>
<td>0</td>
<td>8</td>
<td>16</td>
<td>24</td>
<td>28</td>
<td>32</td>
<td>34</td>
<td>35</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>这个结构要填充 4 个字节以满足 8 字节对齐的要求，所以总共是 40 个字节。</p>
</blockquote>
<h2 id="练习题-3-47"><a href="#练习题-3-47" class="headerlink" title="练习题 3.47"></a>练习题 3.47</h2><p>在运行 Linux 版本 2.6.16 的机器上运行栈检查代码 10 000 次，我们获得地址的范围从最小的 <code>0xffffb754</code> 到最大的 <code>0xffffd754</code> 。</p>
<p>A. 地址的大概范围是多大？</p>
<p><code>0xffffd754 - 0xffffd754 = 0x00002000</code> 大约 $2^{13}$ 个地址的范围。</p>
<p>B. 如果我们尝试一个有 128 字节 nop sled 的缓冲区溢出，要想穷尽所有的起始地址，需要尝试多少次？</p>
<p>$2^7$ 为 128，$2^{13}÷2^7=2^6$ ，需要 64 次尝试。</p>
<h2 id="练习题3-49"><a href="#练习题3-49" class="headerlink" title="练习题3.49"></a>练习题3.49</h2><p>在这道题中，我们要探究图3-43b第5～11行代码背后的逻辑，它分配了变长大小的数组p。正如代码的注释表明的，$s_1$表示执行第4行的 subq指令之后栈指针的地址。这条指令为局部变量i分配空间。$s_2$表示执行第4行的subq 指令之后栈指针的值。这条指令为局部数组p 分配存储。最后，p表示第10～11行的指令赋给寄存器%r8和%rcx的值。这两个寄存器都用来引用数组p。</p>
<p>图3-44的右边画出了$s_1$、$s_2$和p指示的位置。图中还画出了$s_2$和p的值之间可能有一个偏移量为$e_2$字节的位置，该空间是未被使用的。数组p的结尾和s指示的位置之间还可能有一个偏移量为$e_1$字节的地方。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221110194157270.png" alt="image-20221110194157270"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/3-43b" alt="3-43b"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/os/image-20221110194231170.png" alt="image-20221110194231170"></p>
<p><strong>A.用数学语言解释第5～7行中计算s2的逻辑。提示:想想—16的位级表示以及它在第6行andq指令中的作用。</strong></p>
<p>第5行的leaq指令计算值8n＋22，然后第6行的andq指令把它向下舍入到最接近的16的倍数。当n是奇数时，结果值会是8n+8，当n是偶数时，结果值会是8n+16，这个值减去$s_1$就得到$s_2$。</p>
<p><strong>解释：</strong></p>
<p>第5行汇编得到8n+22。</p>
<p>第6行8n+22与立即数-16进行与运算。按照最高位为符号位来说，-16的二进制为<code>1 0000</code>，因为符号拓展值不变，所以-16的8字节表示为<code>.... 1111 0000</code>，省略号全为1。所以第6行是要将8n+22与<code>.... 1111 0000</code>进行与运算，这会导致8n+22的低4位如果谁有1都会被舍弃掉，原文描述为：“把它向下舍入到最接近的16的倍数”，因为是舍弃低4位所以是“向下舍入”。按照本人描述为：舍弃掉权值为8,4,2,1的二进制位，只留下权值大于等于8的二进制位。</p>
<p>所以，与$-16进行与运算后，结果将会是16的倍数。倍数可能是0,1…</p>
<p>当n为偶数时，将8n+22拆分为8n和22。既然n为偶数，则8n为16的倍数，那么<code>8n and $-16 = 8n</code>。<code>22 and $-16 = 16</code>。将两个结果加起来就是<code>8n + 16</code>。<br>当n为奇数时，将8n+22拆分为8(n-1)和30。既然n-1为偶数，则8(n-1)为16的倍数，那么<code>8(n-1) and $-16 = 8(n-1)</code>。<code>30 and $-16 = 16</code>。将两个结果加起来就是8n + 8.</p>
<p>还有就是这个22，其实可以替换为16-23中一个数都可以，把这个数称为m，那么要求m或者m+8在和与<code>$-16</code>进行与运算后，结果必须为16，从这个要求就可以得出这个范围。</p>
<p><strong>B.用数学语言解释第8～10行中计算p的逻辑。提示:可以参考2.3.7节中有关除以2的幂的讨论。</strong></p>
<p>该序列中的三条指令将s2舍入到最近的8的倍数。它们利用了2.3.7节中实现除以⒉的幂用到的偏移和移位的组合。</p>
<p><strong>解释：</strong></p>
<p>在第8行，将%rsp加上7即$2^3-1$，假设%rsp栈指针为x，在第9行右移3位，这里将产生$⌈x/2^3⌉$即$⌈x/8⌉$。<br>第10行乘以8，相当于左移3位。可以想象，当%rsp刚好是8的倍数时，执行完8-10行，不变，因为向上取整时为本身。当%rsp不是8的倍数时，执行完8-10行，为%rsp+8，因为向上取整时加1了。</p>
<p>换个角度，7的二进制为111，当%rsp的低三位是000时，加上111不会使得第4位加1；当%rsp的低三位不是000而是其他情况时，加上111肯定使得第4位加1。然后第9,10行的操作是先右移3位，再左移3位，这就相当于把低3位的二进制值清0。</p>
<p>总结一下：要么%rsp不变，要么%rsp向上舍入到最接近8的倍数。</p>
<p><strong>C.对于下面n和$s_1$的值，跟踪代码的执行，确定$s_2$、$p$、$e_1$和$e_2$的结果值。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>n</th>
<th>$s_1$</th>
<th>$s_2$</th>
<th>$p$</th>
<th>$e_1$</th>
<th>$e_2$</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>2065</td>
<td>2017</td>
<td>2024</td>
<td>1</td>
<td>7</td>
</tr>
<tr>
<td>6</td>
<td>2064</td>
<td>2000</td>
<td>2000</td>
<td>16</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>解释：</strong></p>
<p>在第7行汇编分配栈空间时，是将$e_1$和$e_2$和数组的空间一起考虑的了。</p>
<p>当第10行汇编执行，才会确定了$e_1$和$e_2$的大小。因为只有这个时候才知道了数组空间的开始地址和结束地址。注意这个图里面，$e_1$和$e_2$不一定都是8个字节。</p>
<p>当$s_1$为刚好为8的倍数时,$e_1$和$e_2$就没什么用了，起码不需要它俩来8K对齐了，因为本来就是8K对齐的。</p>
<p>当$s_1$不是8的倍数时，$e_1$和$e_2$可以用来保证数组每个元素8K对齐。</p>
<p><strong>D.这段代码为$s_2$和p的值提供了什么样的对齐属性?</strong></p>
<p>可以看到$s_2$的计算方式会保留$s_1$的偏移量为最接近的16的倍数。还可以看到p会以8的倍数对齐，正是对8字节元素数组建议使用的。</p>
<h2 id="练习题-3-50"><a href="#练习题-3-50" class="headerlink" title="练习题 3.50"></a>练习题 3.50</h2><p>对于下面的 C 代码，表达式 <code>val1</code> ~ <code>val4</code> 分别对应程序值 i、f、d 和 l：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">fcvt2</span><span class="params">(<span class="type">int</span> *ip, <span class="type">float</span> *fp, <span class="type">double</span> *dp, <span class="type">long</span> l)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = *ip;</span><br><span class="line">    <span class="type">float</span> f = *fp;</span><br><span class="line">    <span class="type">double</span> d = *dp;</span><br><span class="line">    *ip = (<span class="type">int</span>)     val1;</span><br><span class="line">    *fp = (<span class="type">float</span>)   val2;</span><br><span class="line">    *dp = (<span class="type">double</span>)  val3;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>) val4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据该函数如下的 x86-64 代码，确定这个映射关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># double fcvt2(int *ip, float *fp, double *dp, long l)</span><br><span class="line"># ip in %rdi, fp in %rsi, dp in %rdx, l in %rcx</span><br><span class="line"># Result returned in %xmm0</span><br><span class="line"></span><br><span class="line">fcvt2:</span><br><span class="line">    movl        (%rdi), %eax        # 把 ip 的值放入 %eax</span><br><span class="line">    vmovss      (%rsi), %xmm0       # 传送单精度数, 把 fp 放入 %xmm0</span><br><span class="line">    vcvttsd2si  (%rdx), %r8d        # 双精度转 32 位整数，dp 放入 %r8d</span><br><span class="line">    movl        %r8d, (%rdi)        # 转换后写入 ip 对应的内存位置</span><br><span class="line">    vcvtsi2ss   %eax, %xmm1, %xmm1  # 32 位整数转单精度浮点数</span><br><span class="line">    vmovss      %xmm1, (%rsi)       # 转换后写入 fp 对应的地址</span><br><span class="line">    vcvtsi2sdq  %rcx, %xmm1, %xmm1  # 64 位整数转为双精度浮点</span><br><span class="line">    vmovsd      %xmm1, (%rdx)       # 转换后写入到 dp 对应的地址</span><br><span class="line">    vunpcklps   %xmm0, %xmm0, %xmm0 # 单精度转换为双精度</span><br><span class="line">    vcvtps2pd   %xmm0, %xmm0        </span><br><span class="line">    ret                             </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>取出位于 dp 的值，转换成 int，再存储到 ip。因此推断出 <code>val1</code> 是 d。</li>
<li>取出位于 ip 的值，转换成 float，再存储到 fp。因此推断出 <code>val2</code> 是 i。</li>
<li>l 的值转换成 double，并存储在 dp。因此推断出 <code>val3</code> 是 l。</li>
<li>fp 的值被转换成双精度，值通过寄存器 <code>%xmm0</code> 返回。因此推断出 <code>val4</code> 是 f。</li>
</ul>
<h2 id="练习题-3-51"><a href="#练习题-3-51" class="headerlink" title="练习题 3.51"></a>练习题 3.51</h2><p>下面的 C 函数将类型为 <code>src_t</code> 的参数转换为类型为 <code>dst_t</code> 的返回值，这里两种参数类型都用 <code>typedef</code> 定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">dest_t</span> <span class="title function_">cvt</span><span class="params">(<span class="type">src_t</span> x)</span>&#123;</span><br><span class="line">    <span class="type">dest_t</span> y = (<span class="type">dest_t</span>) x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 x86-64 上执行这段代码，假设参数 x 在 <code>%xmm0</code> 中，或者在寄存器 <code>%rdi</code> 的某个适当的命名中（即 <code>%rdi</code> 或 <code>%edi</code>）。用一条或两条指令来完成类型转换，并把结果值复制到寄存器 <code>%rax</code> 的某个适当命令部分中（整数结果），或 <code>%xmm0</code> 中（浮点结果）。给出这条或这些指令，包括源和目的寄存器。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Tx</th>
<th>Ty</th>
<th>指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>long</td>
<td>double</td>
<td><code>vcvtsi2sdq %rdi, %xmm0</code></td>
</tr>
<tr>
<td>double</td>
<td>int</td>
<td><code>vcvvttsd2si %xmm0, %eax</code></td>
</tr>
<tr>
<td>double</td>
<td>float</td>
<td><code>vunpcklpd %xmm0, %xmm0, %xmm0 vcvtpd2ps %xmm0, %xmm0</code></td>
</tr>
<tr>
<td>long</td>
<td>float</td>
<td><code>vcvtsi2ssq %rdi, %xmm0, %xmm0</code></td>
</tr>
<tr>
<td>float</td>
<td>long</td>
<td><code>vcvttss2siq %xmm0, %rax</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题-3-52"><a href="#练习题-3-52" class="headerlink" title="练习题 3.52"></a>练习题 3.52</h2><p>对于下面每个函数声明，确定参数的寄存器分配：</p>
<p>A. <code>double g1(double a, long b, float c, int d);</code></p>
<p>a 在 <code>%xmm0</code> ，b 在 <code>%rdi</code> 中，c 在 <code>%xmm1</code> 中，d 在 <code>%esi</code> 中。</p>
<p>B. <code>double g2(int a, double *b, float *c, long d);</code></p>
<p>a 在 <code>%edi</code> 中，b 在 <code>%rsi</code> 中，c 在 <code>%rdx</code> 中，d 在 <code>%rcx</code> 中。</p>
<p>C. <code>double g3(double *a, double b, int c, float d);</code></p>
<p>a 在 <code>%rdi</code> 中，b 在 <code>%xmm0</code> 中，c 在 <code>%esi</code> 中，d 在 <code>%xmm1</code> 中。</p>
<p>D. <code>double g4(float a, int *b, float c, double d);</code></p>
<p>a 在 <code>%xmm0</code> 中，b 在 <code>%rdi</code> 中，c 在 <code>%xmm1</code> 中，d 在 <code>%xmm2</code> 中。</p>
<h2 id="练习题-3-53"><a href="#练习题-3-53" class="headerlink" title="练习题 3.53"></a>练习题 3.53</h2><p>对于下面的 C 函数，4 个参数的类型由 <code>typedef</code> 定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">funct1</span><span class="params">(<span class="type">art1_t</span> p, <span class="type">arg2_t</span> q, <span class="type">arg3_t</span> r, <span class="type">arg4_t</span> s)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p/(q+r) - s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时，GCC 产生如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Assembly</span><br><span class="line"># double funct1(art1_t p, arg2_t q, arg3_t r, arg4_t s)</span><br><span class="line"># Refer to arguments as i1(%rdi), i2(%esi), f1(%xmm0), and f2(%xmm1)</span><br><span class="line"></span><br><span class="line">funct1:</span><br><span class="line">    vcvtsi2ssq      %rsi, %xmm2, %xmm2      # Get i2 and convert from long to float</span><br><span class="line">    vaddss          %xmm0, %xmm2, %xmm0     # Add f1 (type float)</span><br><span class="line">    vcvtsi2ss       %edi, %xmm2, %xmm2      # Get i1 and convert from int to float</span><br><span class="line">    vdivss          %xmm0, %xmm2, %xmm0     # Compute i1 / (i2 + f1)</span><br><span class="line">    vunpcklps       %xmm0, %xmm0, %xmm0</span><br><span class="line">    vcvtps2pd       %xmm0, %xmm0            # Convert to double</span><br><span class="line">    vsubsd          %xmm1, %xmm0, %xmm0     # Compute i1 / (i2 + f1) - f2(double)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>确定 4 个参数类型的可能组合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">funct1a</span><span class="params">(<span class="type">int</span> p, <span class="type">float</span> q, <span class="type">long</span> r, <span class="type">double</span> s)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">funct1b</span><span class="params">(<span class="type">int</span> p, <span class="type">long</span> q, <span class="type">float</span> r, <span class="type">double</span> s)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-3-54-函数-func2-具有如下原型："><a href="#练习题-3-54-函数-func2-具有如下原型：" class="headerlink" title="练习题 3.54 函数 func2 具有如下原型："></a>练习题 3.54 函数 <code>func2</code> 具有如下原型：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">funct2</span><span class="params">(<span class="type">double</span> w, <span class="type">int</span> x, <span class="type">float</span> y, <span class="type">long</span> z)</span>;</span><br></pre></td></tr></table></figure>
<p>GCC 为该函数产生如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Assembly</span><br><span class="line"># double funct2(double w, int x, float y,long z)</span><br><span class="line"># w in %xmm0, x in %edi, y in %xmm1, z in %rsi</span><br><span class="line"></span><br><span class="line">funct2:</span><br><span class="line">    vcvtsi2ss       %edi, %xmm2, %xmm2      # Convert x to float</span><br><span class="line">    vmulss          %xmm1, %xmm2, %xmm1     # Multiply by y</span><br><span class="line">    vunpcklps       %xmm1, %xmm1, %xmm1</span><br><span class="line">    vcvtps2pd       %xmm1, %xmm2            # Convert x*y to double</span><br><span class="line">    vcvtsi2sdq      %rsi, %xmm1, %xmm1      # Convert z to double</span><br><span class="line">    vdivsd          %xmm1, %xmm0, %xmm0     # Compute w/z</span><br><span class="line">    vsudsd          %xmm0, %xmm2, %xmm0     # Subtract from x*y</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>写出 <code>funct2</code> 的 C 语言版本。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">funct2</span><span class="params">(<span class="type">double</span> w, <span class="type">int</span> x, <span class="type">float</span> y,<span class="type">long</span> z)</span>&#123;</span><br><span class="line">    <span class="type">float</span> temp = (<span class="type">float</span>) x;</span><br><span class="line">    y = y * temp;</span><br><span class="line">    <span class="type">double</span> temp2 = (<span class="type">double</span>) y;</span><br><span class="line">    <span class="type">double</span> temp3 = (<span class="type">double</span>) z;</span><br><span class="line">    w = w / temp3;</span><br><span class="line">    <span class="keyword">return</span> y - w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">funct2</span><span class="params">(<span class="type">double</span> w, <span class="type">int</span> x, <span class="type">float</span> y,<span class="type">long</span> z)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y * x - w / z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统第2章</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络编程基础API</title>
    <url>/2022/08/09/Linux/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/</url>
    <content><![CDATA[<h1 id="Linux网络编程基础API"><a href="#Linux网络编程基础API" class="headerlink" title="Linux网络编程基础API"></a>Linux网络编程基础API</h1><p>学习《Linux高性能服务器编程》第五章Linux网络编程基础API，为了印象深刻一些，多动手多实践，所以记下这个笔记。</p>
<span id="more"></span>
<h2 id="socket地址API"><a href="#socket地址API" class="headerlink" title="socket地址API"></a>socket地址API</h2><h3 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h3><p>计算机硬件有两种储存数据的方式：<strong>大端字节序（big endian）</strong>和<strong>小端字节序（little endian）</strong>。</p>
<ul>
<li><strong>大端字节序</strong>：高位字节在前，低位字节在后，符合人类读写数值的方法。</li>
<li><strong>小端字节序</strong>：低位字节在前，高位字节在后</li>
</ul>
<p>想要判别机器的字节序可以使用如下的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">byteorder</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="type">short</span> value;</span><br><span class="line">		<span class="type">char</span> union_bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">	&#125; test;</span><br><span class="line">	test.value = <span class="number">0x0102</span>;</span><br><span class="line">	<span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;big endian\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;little endian\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unknown...\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	byteorder();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220809181538872.png" alt="image-20220809181538872"></p>
<p>这段代码使用的原理是<strong>union变量所占用的内存长度等于最长的成员的内存长度。</strong></p>
<p>所以<code>test</code>中<code>value</code>和<code>union_bytes</code>是共用一段内存的。因为在c中<code>short</code>是16位也就是2字节，<code>char</code>是8位也就是1字节，所以<code>union_bytes</code>数组的大小是2。</p>
<p>我们给<code>value</code>赋值为<code>0x0102</code>。如果是机器是高位存储，那么<code>union_bytes</code>数组第一个元素存储<code>0x01</code>，第二个元素存储<code>0x02</code>，如果是机器是高位存储，那么<code>union_bytes</code>数组第一个元素存储<code>0x02</code>，第二个元素存储<code>0x01</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220809185922374.png" alt="image-20220809185922374"></p>
<p>扩展到32位，四字节来说以<code>0x12345678</code>为例，那么</p>
<p><strong>大端字节序</strong>：0x12345678</p>
<p><strong>小端字节序</strong>：0x78563412</p>
<p>总结来说就是大端字节序和小端字节序的区别就是以<strong>字节</strong>为单位的存储方式不同。</p>
<p>在网络中两台使用不同字节序的主机之间直接传递时，接收端必然会造成错误。书中说解决的方法是发送端总是把要发送的数据转化成大端字节序数据再发送，接受端知道传送过来的数据总是采用大端字节序，所以接收端根据自身采用的字节序再对数据进行一定的处理（小端进行转换，大端就不转换）。</p>
<p>Linux提供了4个函数来完成主机字节序和网络字节序之间的转换:</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220810153657086.png" alt="image-20220810153657086"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span> <span class="params">(<span class="type">uint32_t</span> __netlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span> <span class="params">(<span class="type">uint16_t</span> __netshort)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span> <span class="params">(<span class="type">uint32_t</span> __hostlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span> <span class="params">(<span class="type">uint16_t</span> __hostshort)</span>;</span><br></pre></td></tr></table></figure>
<p>它们的含义是就是首字母缩写（这谁看的出来），比如”htonl”表示“host to network long”，即将长整型（32bit）的主机字节序数据转化为网络字节序数据。这四个函数中，长整型<code>uint32_t</code>函数通常用来转换IP地址，短整型<code>uint16_t</code>函数用来转化端口号。</p>
<p>简单示例展示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="number">258</span>;</span><br><span class="line">    <span class="type">uint16_t</span> p = htons(port);</span><br><span class="line">    port = ntohs(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;htons :%u \n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ntohs :%u \n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220810181643405.png" alt="image-20220810181643405"></p>
<p><code>513</code>二进制：<code>0000 0010 0000 0001</code></p>
<p><code>258</code>二进制：<code>0000 0001 0000 0010</code></p>
<p>可以看出两者字节序是不同的</p>
<h3 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h3><h4 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h4><h5 id="sockaddr"><a href="#sockaddr" class="headerlink" title="sockaddr"></a>sockaddr</h5><p>socket网络接口中表示socket地址的是结构体<code>sockaddr</code>，他的定义在头<code>&lt;bits/socket.h&gt;</code>中，我看在我的电脑上看到的是如下的定义（各个版本不同，可能实现不同，我这里和书上就不大相同）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220810185029006.png" alt="image-20220810185029006"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Structure describing a generic socket address.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sa_);	<span class="comment">/* Common data: address family and length.  */</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];		<span class="comment">/* Address data.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>__SOCKADDR_COMMON</code>定义在<code>&lt;bits/sockaddr.h&gt;</code>中</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220810185204703.png" alt="image-20220810185204703"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/sockaddr.h&gt;</span></span></span><br><span class="line"><span class="comment">/* POSIX.1g specifies this type name for the `sa_family&#x27; member.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This macro is used to declare the initial common members</span></span><br><span class="line"><span class="comment">   of the data types used for socket addresses, `struct sockaddr&#x27;,</span></span><br><span class="line"><span class="comment">   `struct sockaddr_in&#x27;, `struct sockaddr_un&#x27;, etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	__SOCKADDR_COMMON(sa_prefix) sa_family_t sa_prefix##family</span></span><br></pre></td></tr></table></figure>
<p><code>__SOCKADDR_COMMON</code>是定义的一个函数，它返回一个<code>sa_family_t</code>类型的数据，数据的名字是<code>sa_prefixfamily</code>，其中<code>sa_prefix</code>是你传进去的值。比如：<code>__SOCKADDR_COMMON (sa_)</code>其实就是返回<code>sa_family_t sa_family</code>。</p>
<p>所以<code>sockaddr</code>其实就是两个成员，一个是<code>sa_family_t</code>（地址族）类型的变量<code>sa_family</code>，一个<code>char</code>数组类型的变量<code>sa_data</code></p>
<p><code>sa_family_t</code>常见的协议族（protocol family，也称domain）和对应的地址族如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">协议族</th>
<th style="text-align:center">地址族</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF_UNIX</td>
<td style="text-align:center">AF_UNIX</td>
<td style="text-align:center">UNIX本地协议族</td>
</tr>
<tr>
<td style="text-align:center">PF_INET</td>
<td style="text-align:center">AF_INET</td>
<td style="text-align:center">IPv4协议族</td>
</tr>
<tr>
<td style="text-align:center">PF_INET6</td>
<td style="text-align:center">AF_INET6</td>
<td style="text-align:center">IPv6协议族</td>
</tr>
</tbody>
</table>
</div>
<p>宏PF_*和AF_*都定义在<code>&lt;bits/socket.h&gt;</code>当中，两者的值相同，所以两者可以混用</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811094342093.png" alt="image-20220811094342093"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811094510529.png" alt="image-20220811094510529"></p>
<p><code>sa_data</code>成员用于存放socket地址值。不同的协议族的地址值有不同的含义和长度。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">协议族</th>
<th style="text-align:center">地址值含义和长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF_UNIX</td>
<td style="text-align:center">文件的路径名，长度可达108字节</td>
</tr>
<tr>
<td style="text-align:center">PF_INET</td>
<td style="text-align:center">16bit端口号和32bit IPv4地址，共6字节</td>
</tr>
<tr>
<td style="text-align:center">PF_INET6</td>
<td style="text-align:center">16bit端口号，32bit流标识，128bit IPv6地址，32bit范围ID，共26字节</td>
</tr>
</tbody>
</table>
</div>
<h5 id="sockaddr-storage"><a href="#sockaddr-storage" class="headerlink" title="sockaddr_storage"></a>sockaddr_storage</h5><p>可以看出14字节的<code>sa_data</code>根本无法容纳多数协议族的地址值。所以，Linux中定义了新的通用socket地址结构体（其实就是把存放地址的数组加大了）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Structure large enough to hold any socket address (with the historical</span></span><br><span class="line"><span class="comment">   exception of AF_UNIX).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ss_aligntype	unsigned long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SS_PADSIZE \</span></span><br><span class="line"><span class="meta">  (_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (ss_);	<span class="comment">/* Address family, etc.  */</span></span><br><span class="line">    <span class="type">char</span> __ss_padding[_SS_PADSIZE];</span><br><span class="line">    __ss_aligntype __ss_align;	<span class="comment">/* Force desired alignment.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>_SS_SIZE</code>、<code>__SOCKADDR_COMMON_SIZE</code>在<code>&lt;bits/sockaddr.h&gt;</code>当中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/sockaddr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE	(sizeof (unsigned short int))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of struct sockaddr_storage.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SS_SIZE 128</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811135111456.png" alt="image-20220811135111456"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811135134566.png" alt="image-20220811135134566"></p>
<p>这个结构体提供了足够大的空间用于存放地址值，并且是内存对齐的。</p>
<p><code>ss_</code>（其实是<code>ss_family</code>）是<code>sa_family_t</code>类型（介绍<code>sockaddr</code>有提到），即<code>unsigned short int</code>类型，2字节。</p>
<p><code>__ss_align</code>是<code>__ss_aligntype</code>类型，即<code>unsigned long int</code>类型，4字节</p>
<p><code>__ss_padding</code>是<code>char</code>类型数组，大小为<code>_SS_PADSIZE</code>，而<code>_SS_PADSIZE=_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype)=128-2-4=122</code>字节，完全足够保存地址值。</p>
<p>综上<code>sockaddr_storage</code>是128字节大小，保证了内存对齐。</p>
<h4 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h4><p>上面两种通用的socket地址使用起来显然不够方便，因为将IP地址和端口等信息直接放在同一个<code>char</code>数组中，那要得到IP地址和端口信息都得费好大劲进行操作。因此，Linux为各个协议族提供了专门的socket地址结构体。</p>
<p>UNIX本地协议族使用<code>sockaddr_un</code>，数据结构很简单，只有一个保存地址族类型的<code>sun_</code>（其实是<code>sun_family</code>）和保存文件位置的<code>sun_path</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Structure describing the address of an AF_LOCAL (aka AF_UNIX) socket.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sun_);</span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];		<span class="comment">/* Path name.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>IPv4协议族使用<code>sockaddr_in</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Structure describing an Internet socket address.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin_);</span><br><span class="line">    <span class="type">in_port_t</span> sin_port;			<span class="comment">/* Port number.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>		<span class="comment">/* Internet address.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr&#x27;.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr)</span><br><span class="line">			   - __SOCKADDR_COMMON_SIZE</span><br><span class="line">			   - <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>)</span><br><span class="line">			   - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>in_port_t</code>定义、<code>in_addr_t</code>结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Type to represent a port.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811143542024.png" alt="image-20220811143542024"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811143600470.png" alt="image-20220811143600470"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811143622907.png" alt="image-20220811143622907"></p>
<p>可以看的出来<code>sin_</code>（其实是<code>sin_family</code>）存放地址族类型，<code>sin_port</code>存放端口，<code>sin_addr</code>存放地址。<code>sin_zero</code>为了让<code>sockaddr_in</code>大小和<code>sockaddr</code>相同，为什么有这个成员，个人感觉这是因为所以<strong>专用socket</strong>在实际使用中都需要转化为<strong>通用socket地址类型</strong><code>socketaddr</code>，因为socket编程接口使用的是参数类型是<code>socketaddr</code>。</p>
<p>IPv6协议族使用<code>sockaddr_in6</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Ditto, for IPv6.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin6_);</span><br><span class="line">    <span class="type">in_port_t</span> sin6_port;	<span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_flowinfo;	<span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>	<span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_scope_id;	<span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>in6_addr</code>如下，因为IPv6不是学习重点，这里就不过多展开介绍。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* IPv6 address */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span>	__u6_addr8[<span class="number">16</span>];</span><br><span class="line">	<span class="type">uint16_t</span> __u6_addr16[<span class="number">8</span>];</span><br><span class="line">	<span class="type">uint32_t</span> __u6_addr32[<span class="number">4</span>];</span><br><span class="line">      &#125; __in6_u;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s6_addr			__in6_u.__u6_addr8</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_MISC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> s6_addr16		__in6_u.__u6_addr16</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> s6_addr32		__in6_u.__u6_addr32</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>除此之外需要注意：所有<strong>专用socket地址</strong>（以及<code>sockaddr_storage</code>）类型的变量在实际使用时都需要转化为<strong>通用socket地址</strong>类型<code>sockaddr</code>（强制转换即可)，因为所有socket编程接口使用的地址参数的类型都是sockaddr。</p>
<h3 id="IP地址转化函数"><a href="#IP地址转化函数" class="headerlink" title="IP地址转化函数"></a>IP地址转化函数</h3><p>通常来说，人们更喜欢用点分十进制的字符串来表示IPv4地址，但是在编程的过程中，我们需要把这个字符串转化为整数才能使用，但是输出的时候我们又需要把整数转化成点分十进制的字符串，这样方便观察。所以系统提供了3个函数用于点分十进制的字符串IPv4地址和整数的IPv4地址之间的转化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert Internet host address from numbers-and-dots notation in CP</span></span><br><span class="line"><span class="comment">   into binary data in network byte order.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">in_addr_t</span> <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__cp)</span> __THROW;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert Internet host address from numbers-and-dots notation in CP</span></span><br><span class="line"><span class="comment">   into binary data and store the result in the structure INP.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">inet_aton</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__cp, <span class="keyword">struct</span> in_addr *__inp)</span> __THROW;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert Internet number in IN to ASCII representation.  The return value</span></span><br><span class="line"><span class="comment">   is a pointer to an internal array containing the string.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">inet_ntoa</span> <span class="params">(<span class="keyword">struct</span> in_addr __in)</span> __THROW;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>inet_addr</code>函数将用点分十进制字符串表示的IPv4地址转化为用网络字节序整数表示的IPv4地址。它失败时返回 <code>INADDR_NONE</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">in_addr_t</span> ip = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.167.14&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ip == INADDR_NONE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip convert by inet_addr %u \n&quot;</span>, ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811170759741.png" alt="image-20220811170759741"></p>
<p><code>inet_aton</code>功能和<code>inet_addr</code>相同，但是将结果存在在<code>in_addr_t</code>指向的地址结构当中，函数成功返回1，失败返回0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">inet_aton</span>(<span class="string">&quot;192.168.167.14&quot;</span>, &amp;ip);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip convert by inet_aton %u \n&quot;</span>, ip.s_addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811171444397.png" alt="image-20220811171444397"></p>
<p><code>inet_ntoa</code>函数将整数的IPv4地址转化为点分十进制字符串的IPv4。成功时返回转换的字符串地址值，失败时返回-1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">inet_aton</span>(<span class="string">&quot;192.168.167.14&quot;</span>, &amp;ip);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip convert by inet_aton %u \n&quot;</span>, ip.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ip_str = <span class="built_in">inet_ntoa</span>(ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address :%s \n&quot;</span>, ip_str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811173503409.png" alt="image-20220811173503409"></p>
<p>需要注意的是<code>inet_ntoa</code>函数内部使用一个静态变量存储转化的结果，函数的返回值指向该静态内存，因此<code>inet_ntoa</code>是不可重入的，这一点需要多注意。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">inet_aton</span>(<span class="string">&quot;192.168.167.14&quot;</span>, &amp;ip);</span><br><span class="line">    <span class="type">char</span> *ip_str1 = <span class="built_in">inet_ntoa</span>(ip);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inet_aton</span>(<span class="string">&quot;192.168.167.15&quot;</span>, &amp;ip);</span><br><span class="line">    <span class="type">char</span> *ip_str2 = <span class="built_in">inet_ntoa</span>(ip);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address :%s \n&quot;</span>, ip_str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address :%s \n&quot;</span>, ip_str2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811180430697.png" alt="image-20220811180430697"></p>
<p>除此之外，下面两个函数也能完成前三个函数的功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Convert from presentation format of an Internet number in buffer</span></span><br><span class="line"><span class="comment">   starting at CP to the binary network format and store result for</span></span><br><span class="line"><span class="comment">   interface type AF in buffer starting at BUF.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">inet_pton</span> <span class="params">(<span class="type">int</span> __af, <span class="type">const</span> <span class="type">char</span> *__restrict __cp,</span></span></span><br><span class="line"><span class="params"><span class="function">		      <span class="type">void</span> *__restrict __buf)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert a Internet address in binary network format for interface</span></span><br><span class="line"><span class="comment">   type AF in buffer starting at CP to presentation form and place</span></span><br><span class="line"><span class="comment">   result in buffer of length LEN astarting at BUF.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span> <span class="params">(<span class="type">int</span> __af, <span class="type">const</span> <span class="type">void</span> *__restrict __cp,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="type">char</span> *__restrict __buf, <span class="type">socklen_t</span> __len)</span></span></span><br><span class="line"><span class="function">     __THROW</span>;</span><br></pre></td></tr></table></figure>
<p><code>inet_pton</code>函数将用字符串表示的P地址<code>__cp</code>（用点分十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址）转换成用网络字节序整数表示的IP地址，并把转换结果存储于<code>__buf</code>指向的内存中。其中，<code>__af</code>参数指定地址族，可以是<code>AF_INET</code>或者<code>AF_INET6</code>。<code>inet_pton</code>成功时返回1，失败则返回0并设置<code>errno</code>。</p>
<p><code>__restrict</code>emmm目前找不到定义，但是看了下<code>restrict</code>关键字，是指告诉编译器传入的两个指针不指向同一数据，方便进行优化用来提升性能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ip_str[] = <span class="string">&quot;192.168.167.42&quot;</span>;</span><br><span class="line">    <span class="type">in_addr_t</span> ip;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">inet_pton</span>(AF_INET, ip_str, &amp;ip);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ip error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip convert by inet_pton %u \n&quot;</span>, ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> in_ip;</span><br><span class="line">    ret = <span class="built_in">inet_pton</span>(AF_INET, ip_str, &amp;in_ip);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ip error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip convert by inet_pton %u \n&quot;</span>, in_ip.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811183002035.png" alt="image-20220811183002035"></p>
<p><code>inet_ntop</code>函数进行相反的转换，前三个参数的含义与<code>inet_pton</code>的参数相同，最后一个参数 <code>__len</code>指定目标存储单元的大小。下面的两个宏能帮助我们指定这个大小(分别用于IPv4和IPv6):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure>
<p><code>inet_ntop</code>成功时返回目标存储单元的地址，失败则返回NULL并设置errno。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ip_str[] = <span class="string">&quot;192.168.167.42&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> in_ip;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">inet_pton</span>(AF_INET, ip_str, &amp;in_ip);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ret)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ip error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip convert by inet_pton %u \n&quot;</span>, in_ip.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ip_str2[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip_str3 = <span class="built_in">inet_ntop</span>(AF_INET, &amp;in_ip, ip_str2, <span class="built_in">sizeof</span>(ip_str2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ip_str3 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ip error \n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address :%s \n&quot;</span>, ip_str2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address :%s \n&quot;</span>, ip_str3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811220718920.png" alt="image-20220811220718920"></p>
<p>值得注意的是<code>ip_str2</code>和<code>ip_str3</code>的地址相同，也就是说传入参数和返回值相同，虽然不知道为啥这样设计。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220811221357471.png" alt="image-20220811221357471"></p>
<h2 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h2><p>socket使用系统调用可以创建一个socket</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>
<p><code>domain</code>参数是告诉系统使用的是那个底层协议族，一般都是使用IPv4，所以使用<code>AF_INET</code>即可。关于<code>socket</code>系统调用支持的所有协议族，可以查看man手册（虽然参数名不一样，但是并无大碍）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812095854483.png" alt="image-20220812095854483"></p>
<p><code>type</code>参数指定服务类型。服务类型主要有<code>SOCK_STREAM</code>服务（流服务）和<code>SOCK_UGRAM</code>（数据报）服务。对TCP/IP协议族而言，其值取<code>SOCK_STREAM</code>表示传输层使用TCP协议，取<code>SOCK_DGRAM</code>表示传输层使用UDP协议。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812101617247.png" alt="image-20220812101617247"></p>
<p>并且从Linux内核2.6.17起，增加了<code>SOCK_NONBLOCK</code>和<code>SOCK_CLOEXEC</code>这两个标志值，表示将新创建的socket设为非阻塞，以及fork调用创建子进程时在子进程中关闭该socket。在Linux内核2.6.17前，需要调用<code>fcntl</code>进行设置。</p>
<p><code>protocol</code>参数设置具体的协议。但是在前两个参数确定的情况下，这个参数的值基本上唯一的，所有几乎在所有情况下，我们都把这个值设置为0，表示使用默认协议。</p>
<p>socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lfd = <span class="number">0</span>;</span><br><span class="line">    lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//创建一个 socket</span></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h2><p>创建socket时，我们指定了地址族，但是并没有给定具体的地址，这样作为服务器别人是访问不到我们的。将一个socket 与socket地址绑定称为给socket命名。命名socket的系统调用是bind。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p><code>bind</code>将<code>addr</code>所指的socket地址分配给未命名的<code>sockfd</code>文件描述符，<code>addrlen</code>参数指出该socket地址的长度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812104757237.png" alt="image-20220812104757237"></p>
<p><code>bind</code>成功时返回0，失败则返回-1并设置<code>errno</code>。其中两种常见的<code>errno</code>是<code>EACCES</code>和<code>EADDRINUSE</code>，它们的含义分别是:</p>
<ul>
<li><code>EACCES</code>，被绑定的地址是受保护的地址，仅超级用户能够访问。比如普通用户将socket绑定到知名服务端口（端口号为0~1023）上时，<code>bind</code>将返回<code>EACCES</code>错误。</li>
<li><code>EADDRINUSE</code>，被绑定的地址正在使用中。比如将socket绑定到一个处于<code>TIME_WAIT</code>状态的socket地址。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812105430276.png" alt="image-20220812105430276"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> lfd = <span class="number">0</span>, cfd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clit_addr; <span class="comment">// 定义服务器地址结构 和 客户端地址结构</span></span><br><span class="line">    <span class="type">socklen_t</span> clit_addr_len;                 <span class="comment">// 客户端地址结构大小</span></span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;                <span class="comment">// IPv4</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);         <span class="comment">// 转为网络字节序的 端口号</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 获取本机任意有效IP</span></span><br><span class="line"></span><br><span class="line">    lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//创建一个 socket</span></span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)); <span class="comment">//给服务器socket绑定地址结构（IP+port)</span></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h2><p>socket被命名后，还需要调用<code>listen</code>创建一个监听队列来存放处理的客户连接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812112118847.png" alt="image-20220812112118847"></p>
<p><code>sockfd</code>参数指定被监听的socket。<code>backlog</code>参数提示内核监听队列的最大长度。监听队列的长度如果超过<code>backlog</code>，服务器将不受理新的客户连接，客户端也将收到<code>ECONNREFUSED</code>错误信息。</p>
<p>在内核版本2.2之前的Linux中，<code>backlog</code>参数是指所有处于半连接状态（<code>SYN_RCVD</code>）和完全连接状态（<code>ESTABLISHED</code>)的socket 的上限。但自内核版本2.2之后，它只表示处于完全连接状态的socket的上限，处于半连接状态的socket的上限则由<code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>内核参数定义。<code>backlog</code>参数的典型值是5。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812113608890.png" alt="image-20220812113608890"></p>
<p><code>listen</code>成功时返回0，失败则返回-1并设置<code>erron</code>。</p>
<p>本来想测试<code>backlog</code>这个参数的效果，但是怎么也成功不了，不知道原因，以后有机会再进行尝试吧。</p>
<h2 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h2><p>接受连接通过<code>accept</code>进行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812143816774.png" alt="image-20220812143816774"></p>
<p><code>sockfd</code>指执行过<code>listen</code>的监听套接字的文件描述符。</p>
<p><code>addr</code>是传出参数，用来获取接受连接的远端socket地址，地址的长度由<code>addrlen</code>参数指出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(sock, (sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = accept(sock, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> remote[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN), ntohs(client.sin_port));</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812151534158.png" alt="image-20220812151534158"></p>
<p>并且<strong>书上面的实验</strong>说明了<code>accept</code>直接从监听队列中取出连接，而不论连接处于何种状态，更不关心任何网络状况的变化。比如：客户端在服务器<code>accept</code>之前就断网了，<code>accept</code>还是可以正常进行，它并不会返回错误。</p>
<h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><p>发动连接一般是客户端进行的，通过系统调用<code>connect</code>与服务器进行连接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812154447716.png" alt="image-20220812154447716"></p>
<p><code>sockfd</code>参数由socket系统调用返回一个<code>socket</code>。<code>addr</code>参数是服务器监听的<code>socket</code>地址。<code>addrlen</code>参数指这个地址长度。</p>
<p><code>connect</code>成功时返回0。一旦成功建立连接，<code>sockfd</code>就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。<code>connect</code>失败则返回-1并设置<code>errno</code>。其中两种常见的<code>errno</code>是<code>ECONNREFUSED</code>和<code>ETIMEDOUT</code>，它们的含义如下:</p>
<ul>
<li><code>ECONNREFUSED</code>表示目标端口不存在，连接被拒绝。</li>
<li><code>ETIMEDOUT</code>表示连接超时。</li>
</ul>
<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>关闭连接一般来说使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>
<p><code>fd</code>参数是待关闭的socket。不过，<code>close</code>并不会立即关闭这个连接，而是将<code>fd</code>的引用数量减1，直到<code>fd</code>引用数量为0，才真正关闭连接。在多进程程序中，一次<code>fork</code>系统调用默认将父进程中<code>socket</code>的引用计算加1，因此必须在子进程和父进程都对该<code>socket</code>进行<code>close</code>调用才能将连接关闭。</p>
<p>如果想立刻终止连接，直接调用<code>shutdown</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812160846669.png" alt="image-20220812160846669"></p>
<p><code>sockfd</code>参数是待关闭的socket，<code>howto</code>参数决定了<code>shutdown</code>的行为。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">可选值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SHUT_RD</td>
<td style="text-align:left">关闭sockfd上读的这一半。应用程序不能再针对socket文件描述符执行读操作，并且该sockct接收缓冲区中的数据都被丢弃。</td>
</tr>
<tr>
<td style="text-align:center">SHUT_WR</td>
<td style="text-align:left">关闭sockfd上写的这一半。sockfd 的发送缓冲区中的数据会在真正关闭连接之前全部发送出去，应用程序不可再对该socket文件描述符执行写操作。这种情况下，连接处于半关闭状态。</td>
</tr>
<tr>
<td style="text-align:center">SHUT_RDWR</td>
<td style="text-align:left">同时关闭sockfd上的读和写。</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出<code>shutdown</code>可以灵活的关闭socket上的读或写。而<code>close</code>在关闭连接时只能将<code>socket</code>上的读和写同时关闭。</p>
<p><code>shutdown</code>成功时返回0，失败则返回-1并设置<code>errno</code>。</p>
<h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><h3 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h3><p>对文件的读写操作<code>read</code>和<code>write</code>同样适用于socket。但是socket编程接口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据的读写的控制。在TCP中流数据读写的系统调用是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p><code>recv</code>读取<code>sockfd</code>上的数据，<code>buf</code>和<code>len</code>参数分别指定读缓冲区的位置和大小。</p>
<p><code>recv</code>成功读取时返回实际读取到的数据长度，它可能小于我们期望的长度<code>len</code>。因此需要多次调用<code>recv</code>才能读取到完整的数据。<code>recv</code>返回0，意味着对方已经关闭连接。<code>recv</code>出错时返回-1并设置<code>errno</code>。</p>
<p><code>send</code>发送<code>sockfd</code>上的数据。<code>buf</code>和<code>len</code>参数分别指定写缓冲区的位置和大小。</p>
<p><code>send</code>成功读取时返回实际读取到的数据长度，出错时返回-1并设置<code>errno</code>。</p>
<p><code>flags</code>用于控制数据的接收和发送，一般来说设置为0，也可以进行设置，从而进行控制。</p>
<p>控制参数可以通过man手册进行查看，这里直接截取书上的表格</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220812171929139.png" alt="image-20220812171929139"></p>
<h3 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>针对UDP系统提供的是读写函数是<code>recvfrom</code>和<code>sendto</code>，其中函数<code>recvfrom</code>和<code>sendto</code>前4个参数和<code>recv</code>、<code>send</code>意义相同，最后两个是发送端/接收端的地址。因为UDP是没有连接的概念，所以调用这两个函数的时候都要指定地址。<code>recvfrom</code>和<code>sendto</code>的返回值和<code>recv</code>、<code>send</code>也相同，所以不用过多介绍。</p>
<p>除此之外，<code>recvfrom</code>和<code>sendto</code>也可以用于TCP使用，只需要把最后两个参数设置为NULL即可。</p>
<h3 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p><code>recvmsg</code>和<code>sendmsg</code>的参数中<code>sockfd</code>和<code>flags</code>比较简单，复杂一些的参数就是<code>msg</code>。<code>msg</code>的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span>                    <span class="comment">/* Scatter/gather array items */</span></span><br><span class="line">   <span class="type">void</span>  *iov_base;              <span class="comment">/* Starting address */</span></span><br><span class="line">   <span class="type">size_t</span> iov_len;               <span class="comment">/* Number of bytes to transfer */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">   <span class="type">void</span>         *msg_name;       <span class="comment">/* Optional address */</span></span><br><span class="line">   <span class="type">socklen_t</span>     msg_namelen;    <span class="comment">/* Size of address */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">/* Scatter/gather array */</span></span><br><span class="line">   <span class="type">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">   <span class="type">void</span>         *msg_control;    <span class="comment">/* Ancillary data, see below */</span></span><br><span class="line">   <span class="type">size_t</span>        msg_controllen; <span class="comment">/* Ancillary data buffer len */</span></span><br><span class="line">   <span class="type">int</span>           msg_flags;      <span class="comment">/* Flags on received message */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>msg_name</code>指向socket地址，对于TCP协议无意义，所以在TCP协议中设置为NULL，而对于UDP等其他协议就说明了发送或者接收的地址。<code>msg_namelen</code>指定socket地址的长度。</p>
<p><code>msg_iov</code>是<code>iovec</code>类型的指针，根据注释来判断应该是个数组。<code>iovec</code>结构体封装了一块内存的起始位置和长度。<code>msg_iovlen</code>指定这样的<code>iovec</code>结构对象有多少个。</p>
<p>对于<code>recvmsg</code>而言，数据将被读取并存放在<code>msg_iovlen</code>块分散的内存中，这些内存的位置和长度则由<code>msg_iov</code>指向的数组指定，这称为分散读( scatter read);对于<code>sendmsg</code>而言，<code>msg_iovlen</code>块分散内存中的数据将被一并发送，这称为集中写( gather write)。</p>
<p>为什么要有分散读和集中写呢，这其实是一个非常方便的使用，方便传输结构不同的数据。比如：发送http应答时，我们可以把前面的<strong>请求头</strong>和<strong>请求的文件</strong>分为两个buffer，但是最终一起进行写入，减少了拼接带来的麻烦。同理我接收的时候也是想<strong>请求头</strong>和<strong>请求的文件</strong>分开，所以使用分散读。</p>
<p><code>msg_flags</code>成员无须设定，它会复制<code>recvmsg/sendmsg</code>的<code>flags</code>参数的内容以影响数据读写过程。<code>recvmsg</code>还会在调用结束前，将某些更新后的标志设置到<code>msg_flags</code>中。</p>
<p><code>recvmsg/sendmsg</code>的 <code>flags</code>参数以及返回值的含义均与<code>sendrecv</code>的 <code>flags</code>参数及返回值相同。</p>
<p><code>msg_control</code>和 <code>msg_controllen</code>成员用于辅助数据的传送。目前书中并未进行讲解，后续再补充。</p>
<p><code>recvmsg</code>和<code>sendmsg</code>的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 256</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(sock, (sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = accept(sock, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> remote[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN), ntohs(client.sin_port));</span><br><span class="line">		</span><br><span class="line">        <span class="type">char</span> buffer1[<span class="number">6</span>];</span><br><span class="line">        <span class="type">char</span> buffer2[BUFFER_SIZE];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">        bzero(&amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="comment">//设置集中写</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovec_arry</span>[2];</span></span><br><span class="line">        iovec_arry[<span class="number">0</span>].iov_base = (<span class="type">void</span> *)buffer1;</span><br><span class="line">        iovec_arry[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(buffer1);</span><br><span class="line">        iovec_arry[<span class="number">1</span>].iov_base = (<span class="type">void</span> *)buffer2;</span><br><span class="line">        iovec_arry[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(buffer2);</span><br><span class="line"></span><br><span class="line">        msg.msg_iov = iovec_arry;</span><br><span class="line">        msg.msg_iovlen = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = recvmsg(connfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        assert(n != <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; have recv %d byte msg1 %s and msg2 %s \n&quot;</span>, n, buffer1, buffer2);</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sendmsg</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer1[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buffer2[] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    bzero(&amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="comment">// 因为是针对TCP，所以msg_name无意义</span></span><br><span class="line">    msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置集中写</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovec_arry</span>[2];</span></span><br><span class="line">    iovec_arry[<span class="number">0</span>].iov_base = (<span class="type">void</span> *)buffer1;</span><br><span class="line">    iovec_arry[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(buffer1);</span><br><span class="line">    iovec_arry[<span class="number">1</span>].iov_base = (<span class="type">void</span> *)buffer2;</span><br><span class="line">    iovec_arry[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(buffer2);</span><br><span class="line"></span><br><span class="line">    msg.msg_iov = iovec_arry;</span><br><span class="line">    msg.msg_iovlen = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = sendmsg(sock, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    assert(n != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; have send %d byte msg1 %s and msg2 %s \n&quot;</span>, n, buffer1, buffer2);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220813123219330.png" alt="image-20220813123219330"></p>
<p>需要注意的是<code>recvmsg</code>只有在前面的buffer使用完之后，才会使用后面的buffer。这也是为啥把<code>buffer1</code>的大小设置为6。</p>
<h2 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h2><p>如果我们要查询一个连接socket的本端socket地址，以及远端的socket地址，可以使用下面两个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p><code>getsockname</code>获得<code>sockfd</code>对应的本端地址（本地自己的地址），<code>getpeername</code>获得<code>sockfd</code>对应的远端地址（远端连接的地址）。两个函数都把地址存储在<code>addr</code>参数指定的内存中，将该地址的长度存放在<code>addrlen</code>当中。</p>
<p>如果实际socket地址的长度大于<code>addr</code>所指内存区的大小，那么该socket地址将被截断。两个函数成功时返回0，失败返回-1并设置<code>errno</code>。</p>
<p>我写了代码测试了一下，使用telnet进行连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 256</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(sock, (sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = accept(sock, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> remote[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN), ntohs(client.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得本端地址</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">        <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">        ret = getsockname(connfd, (sockaddr *)&amp;addr, &amp;addrlen);</span><br><span class="line">        assert(ret == <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getsockname info ip: %s and port: %d , addrlen is %d \n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;addr.sin_addr, remote, INET_ADDRSTRLEN), ntohs(addr.sin_port), addrlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得远端地址</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr2</span>;</span></span><br><span class="line">        <span class="type">socklen_t</span> addrlen2 = <span class="keyword">sizeof</span>(addr2);</span><br><span class="line">        ret = getpeername(connfd, (sockaddr *)&amp;addr2, &amp;addrlen2);</span><br><span class="line">        assert(ret == <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getpeername info ip: %s and port: %d , addrlen is %d \n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;addr2.sin_addr, remote, INET_ADDRSTRLEN), ntohs(addr2.sin_port), addrlen2);</span><br><span class="line"></span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220813163338463.png" alt="image-20220813163338463"></p>
<h2 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h2><p>读取和设置socket文件描述的方法如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure>
<p><code>sockfd</code>参数指定被操纵的目标socket，<code>level</code>参数指定要操作的协议选项，<code>optname</code>参数则指定选项的名字，<code>optval</code>和<code>optlen</code>参数分别是操作选项的值和长度。截图了一下书中的表格。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/socket选项.png" alt="socket选项"></p>
<p><code>getsockopt</code>和<code>setsockopt</code>这两个函数成功时返回0，失败时返回-1并设置<code>errno</code>。</p>
<p>需要注意的是，在服务器端<code>setsockopt</code>最好在<code>listen</code>之前进行调用（因为连接socket只能由accept调用返回，而accept 从 listen 监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤）。同理，对客户端而言，这些socket选项则应该在调用connect 函数之前设置，因为connect调用成功返回之后，TC三次握手已完成。</p>
<h3 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h3><p>设置服务器可以立即重启，不需要等待<code>TIME_WAIT</code>状态过去，可以使用<code>SO_REUSEADDR</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sock = socket( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">assert( sock &gt;= <span class="number">0</span> );</span><br><span class="line"><span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">setsockopt( sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>( reuse ) );</span><br></pre></td></tr></table></figure>
<p>经过setsockopt的设置之后，即使sock处于TIME_WAIT状态，与之绑定的socket地址也可以立即被重用。</p>
<h3 id="SO-RCVBUF和SO-SNDBUF"><a href="#SO-RCVBUF和SO-SNDBUF" class="headerlink" title="SO_RCVBUF和SO_SNDBUF"></a>SO_RCVBUF和SO_SNDBUF</h3><p><code>SO_RCVBUF</code>和<code>SO_SNDBUF</code>分别设置TCP接收缓冲区和发送缓冲区的大小。但是，当我们使用<code>setsockopt</code>设置TCP缓冲区大小时，系统都会将其值进行加倍，并且不会小于某个值。TCP接收缓冲区最小值是256字节，发送缓冲区最小是2048字节。小值是2048字节(不过，不同的系统可能有不同的默认最小值)。系统这样做的目的，主要是确保一个TCP连接拥有足够的空闲缓冲区来处理拥塞（比如快速重传算法就期望TCP接收缓冲区能至少容纳4个大小为SMSS的TCP报文段)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number receive_buffer_size\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> recvbuf = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(recvbuf);</span><br><span class="line">    setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line">    getsockopt(sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, (<span class="type">socklen_t</span> *)&amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the receive buffer size after settting is %d\n&quot;</span>, recvbuf);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sendbuf = atoi(argv[<span class="number">4</span>]);</span><br><span class="line">    len = <span class="keyword">sizeof</span>(sendbuf);</span><br><span class="line">    setsockopt(sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, <span class="keyword">sizeof</span>(sendbuf));</span><br><span class="line">    getsockopt(sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, (<span class="type">socklen_t</span> *)&amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the tcp send buffer size after setting is %d\n&quot;</span>, sendbuf);</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220813180440008.png" alt="image-20220813180440008"></p>
<p>emmm不知道为啥大小是这样，后续再看看。</p>
<h2 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h2><p>socket当中两要素：IP和端口号，都是用数值表示的。但是有时候我们可以使用主机名代替IP，使用服务名代替端口号。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">telnet 127.0.0.1 80</span><br><span class="line">telnet localhost www</span><br></pre></td></tr></table></figure>
<p>这个功能就是使用网络信息API实现的。</p>
<h3 id="gethostbyname和gethostbyaddr"><a href="#gethostbyname和gethostbyaddr" class="headerlink" title="gethostbyname和gethostbyaddr"></a>gethostbyname和gethostbyaddr</h3><p><code>gethostbyname</code>函数根据主机名称获取主机的完整信息，<code>gethostbyaddr</code>函数根据IP地址获取主机的完整信息。<code>gethostbyname</code>函数通常先在本地的<code>/etc/hosts</code>配置文件中查找主机，如果没有找到，再去访问DNS服务器。这两个函数的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> h_errno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>       <span class="comment">/* for AF_INET */</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">socklen_t</span> len, <span class="type">int</span> type)</span>;</span><br></pre></td></tr></table></figure>
<p><code>name</code>参数表示目标主机的主机名。</p>
<p><code>addr</code>参数指定目标主机的IP地址，<code>len</code>参数指定<code>addr</code>的所指定IP的长度</p>
<p><code>type</code>参数指定IP地址的类型，比如<code>AF_INET</code>等</p>
<p>其中<code>hostent</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">   <span class="type">char</span>  *h_name;            <span class="comment">/* official name of host */</span></span><br><span class="line">   <span class="type">char</span> **h_aliases;         <span class="comment">/* alias list */</span></span><br><span class="line">   <span class="type">int</span>    h_addrtype;        <span class="comment">/* host address type */</span></span><br><span class="line">   <span class="type">int</span>    h_length;          <span class="comment">/* length of address */</span></span><br><span class="line">   <span class="type">char</span> **h_addr_list;       <span class="comment">/* list of addresses */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数介绍</p>
<p><code>h_name</code>:主机名<br><code>h_aliases</code>:主机别名列表，可能有多个<br><code>h_addrtype</code>:地址类型（地址族）<br><code>h_length</code>:地址长度<br><code>h_addr_list</code>:按网络字节序列出的主机IP地址列表</p>
<p>从网上找了个图显示了一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/Center.png" alt="img"></p>
<p><code>gethostbyname</code>举例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Use example: %s www.baidu.com\n&quot;</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hptr</span>;</span></span><br><span class="line"></span><br><span class="line">    hptr = gethostbyname(name);</span><br><span class="line">    <span class="keyword">if</span> (hptr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gethostbyname error for host: %s: %s\n&quot;</span>, name, hstrerror(h_errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出主机名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tofficial: %s\n&quot;</span>, hptr-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出主机的别名</span></span><br><span class="line">    <span class="type">char</span> **pptr;</span><br><span class="line">    <span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">for</span> (pptr = hptr-&gt;h_aliases; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\talias: %s\n&quot;</span>, *pptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出ip地址</span></span><br><span class="line">    <span class="keyword">switch</span> (hptr-&gt;h_addrtype)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> AF_INET:</span><br><span class="line">        pptr = hptr-&gt;h_addr_list;</span><br><span class="line">        <span class="keyword">for</span> (; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\taddress: %s\n&quot;</span>,</span><br><span class="line">                   inet_ntop(hptr-&gt;h_addrtype, *pptr, str, <span class="keyword">sizeof</span>(str)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unknown address type\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814105118617.png" alt="image-20220814105118617"></p>
<p><code>gethostbyaddr</code>举例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Use example: %s 127.0.0.1\n&quot;</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, ip, &amp;addr);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hptr</span>;</span></span><br><span class="line"></span><br><span class="line">    hptr = gethostbyaddr(&amp;addr, <span class="keyword">sizeof</span>(addr), AF_INET);</span><br><span class="line">    <span class="keyword">if</span> (hptr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gethostbyaddr error for host: %s: %s\n&quot;</span>, ip, hstrerror(h_errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出主机名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tofficial: %s\n&quot;</span>, hptr-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出主机的别名</span></span><br><span class="line">    <span class="type">char</span> **pptr;</span><br><span class="line">    <span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">for</span> (pptr = hptr-&gt;h_aliases; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\talias: %s\n&quot;</span>, *pptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出ip地址</span></span><br><span class="line">    <span class="keyword">switch</span> (hptr-&gt;h_addrtype)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> AF_INET:</span><br><span class="line">        pptr = hptr-&gt;h_addr_list;</span><br><span class="line">        <span class="keyword">for</span> (; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\taddress: %s\n&quot;</span>,</span><br><span class="line">                   inet_ntop(hptr-&gt;h_addrtype, *pptr, str, <span class="keyword">sizeof</span>(str)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unknown address type\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814105222471.png" alt="image-20220814105222471"></p>
<h3 id="getservbyname和getservbyport"><a href="#getservbyname和getservbyport" class="headerlink" title="getservbyname和getservbyport"></a>getservbyname和getservbyport</h3><p><code>getservbyname</code>函数根据名称获取某个服务的完整信息，<code>getservbyport</code>函数根据端口号获取某个服务的完整信息。它们实际上都是通过读取<code>/etc/services</code>文件来获取服务的信息的。这两个函数的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyport</span><span class="params">(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br></pre></td></tr></table></figure>
<p><code>name</code>参数指定目标服务的名字。</p>
<p><code>port</code>参数指定目标服务对应的端口号。</p>
<p><code>proto</code>参数指定服务类型，给它传递“tcp”表示获取流服务，给它传递“udp”表示获取数据报服务，给它传递NULL则表示获取所有类型的服务。</p>
<p>函数返回的<code>servent</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">   <span class="type">char</span>  *s_name;       <span class="comment">/* official service name */</span></span><br><span class="line">   <span class="type">char</span> **s_aliases;    <span class="comment">/* alias list */</span></span><br><span class="line">   <span class="type">int</span>    s_port;       <span class="comment">/* port number */</span></span><br><span class="line">   <span class="type">char</span>  *s_proto;      <span class="comment">/* protocol to use */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>s_name</code>：服务名称</p>
<p><code>s_aliases</code>：服务别名列表，可能有多个</p>
<p><code>s_port</code>：端口号</p>
<p><code>s_proto</code>：服务类型，通常是tcp或者udp</p>
<p><code>getservbyname</code>举例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">servent</span> *<span class="title">servinfo</span> =</span> getservbyname(<span class="string">&quot;ssh&quot;</span>, <span class="string">&quot;tcp&quot;</span>);</span><br><span class="line">    assert(servinfo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>, servinfo-&gt;s_name);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> **pptr;</span><br><span class="line">    <span class="keyword">for</span> (pptr = servinfo-&gt;s_aliases; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alias: %s\n&quot;</span>, *pptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;port is %d\n&quot;</span>, ntohs(servinfo-&gt;s_port));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;protocol is %s\n&quot;</span>, servinfo-&gt;s_proto);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814141312451.png" alt="image-20220814141312451"></p>
<p><code>getservbyport</code>举例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> port = <span class="number">80</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">servent</span> *<span class="title">servinfo</span> =</span> getservbyport(htons(port), <span class="string">&quot;tcp&quot;</span>);</span><br><span class="line">    assert(servinfo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>, servinfo-&gt;s_name);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> **pptr;</span><br><span class="line">    <span class="keyword">for</span> (pptr = servinfo-&gt;s_aliases; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alias: %s\n&quot;</span>, *pptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;port is %d\n&quot;</span>, ntohs(servinfo-&gt;s_port));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;protocol is %s\n&quot;</span>, servinfo-&gt;s_proto);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814142922859.png" alt="image-20220814142922859"></p>
<p>需要指出的是，上面讨论的4个函数都是不可重入的，即非线程安全的。不过<code>netdb.h</code>头文件给出了它们的可重入版本。正如Linux下所有其他函数的可重入版本的命名规则那样，这些函数的函数名是在原函数名尾部加上_<code>r (re-entrant)</code>。</p>
<h3 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h3><p><code>getaddrinfo</code>函数既能通过主机名获得IP地址（内部使用的是<code>gethostbyname</code>函数),也能通过服务名获得端口号（内部使用的是<code>getservbyname</code>函数)。它是否可重人取决于其内部调用的<code>gethostbyname</code>和<code>getservbyname</code>函数是否是它们的可重入版本。该函数的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *node, <span class="type">const</span> <span class="type">char</span> *service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **res)</span>;</span><br></pre></td></tr></table></figure>
<p><code>node</code>参数可以接收主机名，也可以接收字符串表示的IP地址，用点分十分制。</p>
<p><code>service</code>参数可以接收服务名，也可以接收字符串表示的十进制端口。</p>
<p><code>hints</code>参数是给<code>getaddrinfo</code>的一个提示，以对<code>getaddrinfo</code>的输出进行更精确的控制。<code>hints</code>参数可以设置为NULL，表示允许<code>getaddrinfo</code>反馈任何可用的结果。</p>
<p><code>res</code>参数返回一个链表，这个链表用于存储<code>getaddrinfo</code>反馈的结果。</p>
<p>除此之外，在我们调用完<code>getaddrinfo</code>之后，需要使用<code>freeaddrinfo</code>对res进行内存释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo *res)</span>;</span><br></pre></td></tr></table></figure>
<p><code>addrinfo</code>的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">   <span class="type">int</span>              ai_flags;</span><br><span class="line">   <span class="type">int</span>              ai_family;</span><br><span class="line">   <span class="type">int</span>              ai_socktype;</span><br><span class="line">   <span class="type">int</span>              ai_protocol;</span><br><span class="line">   <span class="type">socklen_t</span>        ai_addrlen;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span></span><br><span class="line">   <span class="type">char</span>            *ai_canonname;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ai_family</code>：地址族，比如：<code>AF_INET</code></p>
<p><code>ai_socktype</code>：服务类型，比如：<code>SOCK_STREAM</code></p>
<p><code>ai_protocol</code>：指具体的网络协议</p>
<p><code>ai_addrlen</code>：地址<code>ai_addr</code>的长度</p>
<p><code>ai_addr</code>：指向socket的地址</p>
<p><code>ai_canonname</code>：主机的别名</p>
<p><code>ai_next</code>：链表的下一个对象</p>
<p><code>ai_flags</code>可以取下表中标志</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814160248251.png" alt="image-20220814160248251"></p>
<p>当我们使用hints参数的时候，可以设置其<code>ai_flags</code>，<code>ai_family</code>，<code>ai_socktype</code>和<code>ai_protocol</code>四个字段，其他字段则必须被设置为NULL。</p>
<p><strong>根据主机名获取IP地址：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Use example: %s www.baidu.com\n&quot;</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">res</span>, *<span class="title">cur</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">char</span> ipbuf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_INET;   <span class="comment">/* Allow IPv4 */</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE; <span class="comment">/* For wildcard IP address */</span></span><br><span class="line">    hints.ai_protocol = <span class="number">0</span>;       <span class="comment">/* Any protocol */</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line"></span><br><span class="line">    ret = getaddrinfo(name, <span class="literal">NULL</span>, &amp;hints, &amp;res);</span><br><span class="line">    assert(ret &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (cur = res; cur != <span class="literal">NULL</span>; cur = cur-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        addr = (<span class="keyword">struct</span> sockaddr_in *)cur-&gt;ai_addr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip: %s\n&quot;</span>, inet_ntop(AF_INET, &amp;addr-&gt;sin_addr, ipbuf, cur-&gt;ai_addrlen));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alias: %s\n&quot;</span>, cur-&gt;ai_canonname);</span><br><span class="line">    &#125;</span><br><span class="line">    freeaddrinfo(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814165923059.png" alt="image-20220814165923059"></p>
<p>不过不知道为啥别名为null</p>
<p><strong>根据主机名和端口号获取地址信息：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Use example: %s 80\n&quot;</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *port = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> *hostname = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">res</span>, *<span class="title">cur</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">char</span> ipbuf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_UNSPEC; <span class="comment">/* Allow IPv4 */</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE; <span class="comment">/* For wildcard IP address */</span></span><br><span class="line">    hints.ai_protocol = <span class="number">0</span>;       <span class="comment">/* Any protocol */</span></span><br><span class="line">    hints.ai_socktype = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = getaddrinfo(hostname, port, &amp;hints, &amp;res);</span><br><span class="line"></span><br><span class="line">    assert(ret &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (cur = res; cur != <span class="literal">NULL</span>; cur = cur-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        addr = (<span class="keyword">struct</span> sockaddr_in *)cur-&gt;ai_addr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip: %s\n&quot;</span>, inet_ntop(AF_INET, &amp;addr-&gt;sin_addr, ipbuf, cur-&gt;ai_addrlen));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;port: %d\n&quot;</span>, ntohs(addr-&gt;sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alias: %s\n&quot;</span>, cur-&gt;ai_canonname);</span><br><span class="line">    &#125;</span><br><span class="line">    freeaddrinfo(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814170106763.png" alt="image-20220814170106763"></p>
<p>不过不知道为啥别名为null</p>
<h3 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h3><p><code>getnameinfo</code>函数能通过socket地址同时获得以字符串表示的<strong>主机名</strong>（内部使用的是<code>gethostbyaddr</code>函数）和<strong>服务名</strong>（内部使用的是<code>getservbyport</code>函数)。它是否可重入取决于其内部调用的gethostbyaddr和 getservbyport函数是否是它们的可重入版本。该函数的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen,<span class="type">char</span> *host, <span class="type">socklen_t</span> hostlen,</span></span><br><span class="line"><span class="params">                <span class="type">char</span> *serv, <span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p><code>getnameinfo</code>将返回的主机名存储在host参数指向的缓存中，将服务名存储在serv参数指向的缓存中，<code>hostlen</code>和 <code>servlen</code>参数分别指定这两块缓存的长度。flags参数控制<code>getnameinfo</code>的行为，它可以接收下表中的选项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814171842523.png" alt="image-20220814171842523"></p>
<p><code>getaddrinfo</code>和 <code>getnameinfo</code>函数成功时返回0，失败则返回错误码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Use example: %s 127.0.0.1 80\n&quot;</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">char</span> hostname[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> servername[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_dst</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_dst, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_dst));</span><br><span class="line">    addr_dst.sin_family = AF_INET;</span><br><span class="line">    addr_dst.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line">    addr_dst.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = getnameinfo((<span class="keyword">struct</span> sockaddr *)&amp;addr_dst, <span class="keyword">sizeof</span>(addr_dst), hostname, <span class="keyword">sizeof</span>(hostname), servername, <span class="keyword">sizeof</span>(servername), <span class="number">0</span>);</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hostname IP: %s \n&quot;</span>, hostname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;servername : %s \n&quot;</span>, servername);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/bugcat9/blog-image-bed@main/Linux/image-20220814181037933.png" alt="image-20220814181037933"></p>
]]></content>
      <categories>
        <category>Linux网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux高性能服务器编程</tag>
        <tag>计算机网络</tag>
        <tag>Linux网络编程</tag>
      </tags>
  </entry>
</search>
